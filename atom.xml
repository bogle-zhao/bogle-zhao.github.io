<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.shagle.cn/"/>
  <updated>2019-03-13T06:57:31.000Z</updated>
  <id>http://blog.shagle.cn/</id>
  
  <author>
    <name>bogle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rpc</title>
    <link href="http://blog.shagle.cn/2019/03/12/rpc/"/>
    <id>http://blog.shagle.cn/2019/03/12/rpc/</id>
    <published>2019-03-12T13:11:05.000Z</published>
    <updated>2019-03-13T06:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPC:Remote Procedure Call,远程过程调用，很多RPC框架是夸语言的</p><ol><li>定义一个接口说明文件：描述了对象(结构图体)，对象成员，接口方法等一系列信息</li><li>通过RPC框架所提供的编码器，将接口说明文件编译成集体的语言文件</li><li>在客户端和服务端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法</li></ol><h1 id="1-Protocol-buffers"><a href="#1-Protocol-buffers" class="headerlink" title="1. Protocol buffers"></a>1. Protocol buffers</h1><p>Protocol buffers 是语言中立的，平台无关的，可扩展的用于序列化结构化数据</p><p><strong>1.1. What are protocol buffers?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = <span class="number">1</span>;</span><br><span class="line">  required int32 id = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Protocol buffers是google提供的语言中立，平台中立，用于数据结构化，可扩展化的结构化数据–就像xml，但是它的提交更小，速度更快，更加简单。你只需要定义一次你的数据结构，然后使用特殊生成的源代码轻松地将结构化数据写入和读取各种数据流，并使用各种语言。</p><p><strong>1.2. Pick your favorite language</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person john = Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">"John Doe"</span>)</span><br><span class="line">    .setEmail(<span class="string">"jdoe@example.com"</span>)</span><br><span class="line">    .build();</span><br><span class="line">output = <span class="keyword">new</span> FileOutputStream(args[<span class="number">0</span>]);</span><br><span class="line">john.writeTo(output);</span><br></pre></td></tr></table></figure></p><p>Protocol buffers当前支持生成的代码Java，Python，Objective-C和C++语言。使用我们新的proto3语言版本，您还可以使用Dart，Go，Ruby和C＃，以及更多语言。</p><p><strong>1.3 How do I start?</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person john;</span><br><span class="line"><span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">    ios::in | ios::binary)</span></span>;</span><br><span class="line">john.ParseFromIstream(&amp;input);</span><br><span class="line">id = john.id();</span><br><span class="line">name = john.name();</span><br><span class="line">email = john.email();</span><br></pre></td></tr></table></figure></p><ol><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">下载</a>并安装protocol buffer 编译器</li><li>阅读<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">指南</a>。</li><li>尝试使用您选择的语言的<a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">教程</a>。</li></ol><h1 id="2-Protocol-Buffer-Basics-Java"><a href="#2-Protocol-Buffer-Basics-Java" class="headerlink" title="2. Protocol Buffer Basics: Java"></a>2. Protocol Buffer Basics: Java</h1><p>本教程提供了一个基本的Java程序员介绍如何使用Protocol buffers。它向您展示如何通过创建一个简单的示例应用程序，</p><ul><li>在.proto文件中定义消息格式。</li><li>使用protocol buffer编译器</li><li>使用Java protocol buffer API来编写和读取消息。</li></ul><p>这不是在Java中使用protocol buffer的综合指南。有关更详细的参考信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">Protocol Buffer Language Guide</a>,<a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html" target="_blank" rel="noopener">Java API Reference</a>, <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Encoding Reference</a>.</p><h2 id="2-1-Why-Use-Protocol-Buffers"><a href="#2-1-Why-Use-Protocol-Buffers" class="headerlink" title="2.1 Why Use Protocol Buffers?"></a>2.1 Why Use Protocol Buffers?</h2><p>我们将要使用的示例是一个非常简单的“address book”应用程序，可以在文件中读取和写入人员的联系人详细信息。address book中的每个人都有姓名，ID，电子邮件地址和联系电话号码。</p><p>你如何序列化和检索这样的结构化数据？有几种方法可以解决这个问题：</p><ul><li>使用java的序列化:这是默认方法，因为它内置于语言中，但它有许多众所周知的问题(参见Effective Java，作者：Josh Bloch，第213页),并且如果您需要与使用C ++或Python编写的应用程序共享数据，也无法正常工作。</li><li>您可以发明一种特殊的方法将数据项编码为单个字符串 - 例如将4个整数编码为“12:3:-23:67”，这是一种简单而灵活的方法，虽然它确实需要编写一次性编码和解析代码，并且解析会产生很小的运行时成本。这最适合编码非常简单的数据。</li><li>将数据序列化为XML。这种方法非常有吸引力，因为XML是人类可读的，并且有许多语言的绑定库。如果您想与其他应用程序/项目共享数据，这可能是一个不错的选择。然而，XML是众所周知的空间密集型，并且编码/解码它会对应用程序造成巨大的性能损失。此外，导航XML DOM树比通常在类中导航简单字段要复杂得多。</li></ul><p>Protocol Buffers是灵活，高效，自动化的解决方案，可以解决这个问题。使用Protocol Buffers，您可以编写要存储的数据结构的.proto描述。根据这个.proto文件，Protocol Buffers编译器创建一个class，该类使用有效的二进制格式实现Protocol Buffers数据的自动编码和解析。生成的类为构成Protocol Buffers针对字段提供getter和setter，并负责Protocol Buffers作为一个单元读取和写入的细节。重要的是，Protocol Buffers格式支持随着时间的推移扩展格式的想法，使得代码仍然可以读取用旧格式编码的数据。</p><h2 id="2-2-Where-to-Find-the-Example-Code"><a href="#2-2-Where-to-Find-the-Example-Code" class="headerlink" title="2.2 Where to Find the Example Code"></a>2.2 Where to Find the Example Code</h2><p>示例代码包含在源代码包中的“examples”目录下。<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">Download it here.</a></p><h2 id="2-3-Defining-Your-Protocol-Format"><a href="#2-3-Defining-Your-Protocol-Format" class="headerlink" title="2.3 Defining Your Protocol Format"></a>2.3 Defining Your Protocol Format</h2><p>要创建address book应用程序，您需要从.proto文件开始。.proto文件中的定义很简单：为要序列化的每个数据结构添加消息，然后为消息中的每个字段指定名称和类型。这是定义结构消息的.proto文件<code>addressbook.proto</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">"com.example.tutorial"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"AddressBookProtos"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  required string name = <span class="number">1</span>;</span><br><span class="line">  required int32 id = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number = <span class="number">1</span>;</span><br><span class="line">    optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，语法类似于C ++或Java。接下来让我们浏览文件的每个部分，看看它的作用。</p><p>.proto文件以package声明开头，这有助于防止不同项目之间的命名冲突。在Java中，包名称用作Java包，除非您已经明确指定了java_package，就像我们在这里一样。即使你确实提供了java_package，你仍然应该定义一个普通的package，以避免在Protocol Buffers名称空间和非Java语言中发生名称冲突。</p><p>在声明package之后，您可以看到两个特定于Java的选项：<code>java_package</code>和<code>java_outer_classname</code>.java_package指定生成的classes应该位于什么Java包中存在。如果没有明确指定它，它只是匹配package声明给出的包名中，但这些名称通常不是合适的Java包名（因为它们通常不以域名开头）。java_outer_classname选项定义应包含此文件中所有类的类名。如果未明确提供java_outer_classname，则将通过将文件名转换为驼峰形式来生成它。例如，默认情况下，“my_proto.proto”将使用“MyProto”作为外部类名。</p><p>接下来，您有消息定义。 消息只是包含一组类型字段的聚合。许多标准的简单数据类型都可用作字段类型，包括bool，int32，float，double和string。您还可以使用其他消息类型作为字段类型向消息中添加更多结构 - 在上面的示例中，Person消息包含PhoneNumber消息，而AddressBook消息包含Person消息。您甚至可以定义嵌套在其他消息中的消息类型 -​​ 如您所见，PhoneNumber类型在Person中定义。如果您希望其中一个字段具有预定义的值列表之一，您还可以定义枚举类型 - 此处您要指定电话号码可以是MOBILE，HOME或WORK之一。</p><p>每个元素上的“= 1”，“= 2”标记标识该字段在二进制编码中使用的唯一“标记”。标签号1-15需要少于一个字节来编码而不是更高的数字，因此作为优化，您可以决定将这些标签用于常用或重复的元素，将标签16和更高版本留给不太常用的可选元素。重复字段中的每个元素都需要重新编码标记号，因此重复字段特别适合此优化。</p><p>必须使用以下修饰符之一注释每个字段：</p><ul><li><p><code>required</code>：必须提供该字段的值，否则该消息将被视为“未初始化”。尝试构建未初始化的消息将抛出RuntimeException。解析未初始化的消息将抛出IOException。除此之外，必填字段的行为与可选字段完全相同。</p></li><li><p><code>optional</code>：可以设置也可以不设置字段。如果未设置可选字段值，则使用默认值。对于简单类型，您可以指定自己的默认值，就像我们在示例中为电话号码类型所做的那样。否则，使用系统默认值：数字类型为0，字符串为空字符串，bools为false。对于嵌入式消息，默认值始终是消息的“默认实例”或“原型”，其中没有设置其字段。调用访问器以获取尚未显式设置的可选（或必需）字段的值始终返回该字段的默认值。</p></li><li><p><code>repeated</code>：该字段可以重复任意次数（包括0次）。重复值的顺序将保留在protocol buffer中。将重复字段视为动态大小的数组。</p></li></ul><blockquote><p>必需永远您应该非常小心地将字段标记为<code>required</code>。如果您希望在某个时刻停止写入或不发送必填字段，则将字段更改为optional字段会有问题 - 旧readers会认为没有此字段，可能会无意中拒绝或丢弃它们。您应该考虑为protocol buffer编写特定于应用程序的自定义验证例程。谷歌的一些工程师得出的结论是，使用<code>repeated</code>的弊大于利;他们更喜欢只使用<code>optional</code>和<code>repeated</code>。但是，这种观点并不普遍。</p></blockquote><p>您将在<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">Protocol Buffer Language Guide</a>中找到编写.proto文件的完整指南 - 包括所有可能的字段类型。不要去寻找类继承类似方式，但protocol buffer不支持继承。</p><h2 id="2-4-Compiling-Your-Protocol-Buffers"><a href="#2-4-Compiling-Your-Protocol-Buffers" class="headerlink" title="2. 4. Compiling Your Protocol Buffers"></a>2. 4. Compiling Your Protocol Buffers</h2><p>现在你已经有一个.proto，你接下来需要做的下一件事是生成你需要读取和写入AddressBook（以及Person和PhoneNumber）消息所需的类。为此，您需要在.proto上运行Protocol Buffers编译器protoc：</p><ol><li>如果尚未安装Protocol Buffers编译器，请<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">下载</a>该软件包并按照自述文件中的说明进行操作。</li><li>现在运行编译器，指定source代码目录（应用程序的源代码所在的位置 - 如果不提​​供值，则使用当前目录），目标目录（您希望生成的代码在哪里;通常与$SRC_DIR），以及.proto的路径。在这种情况下，你…：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto</span><br></pre></td></tr></table></figure><p>因为您需要Java class，所以使用–java_out选项 - 为其他受支持的语言提供了类似的选项。</p><p>这将在指定的目标目录中生成com/example/tutorial/AddressBookProtos.java。</p><h2 id="2-5-The-Protocol-Buffer-API"><a href="#2-5-The-Protocol-Buffer-API" class="headerlink" title="2.5 The Protocol Buffer API"></a>2.5 The Protocol Buffer API</h2><p>让我们看看一些生成的代码，看看编译器为您创建了哪些类和方法。如果你查看AddressBookProtos.java，你会发现它定义了一个名为AddressBookProtos的类，在addressbook.proto中指定的每个消息都嵌套在AddressBookProtos类中。每个类都有自己的Builder类，可用于创建该类的实例。您可以在下面的“<a href="https://developers.google.com/protocol-buffers/docs/javatutorial#builders" target="_blank" rel="noopener">Builders vs. Messages</a>”部分中找到有关构建器的更多信息。</p><p>消息和构建器都为消息的每个字段都有自动生成的访问器方法;消息只有getter，而构建器有getter和setter。以下是Person类的一些访问器（为简洁起见省略了实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title">getPhonesList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhonesCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">getPhones</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>同时，Person.Builder拥有相同的getter加setter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setEmail</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearEmail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title">getPhonesList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhonesCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">getPhones</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setPhones</span><span class="params">(<span class="keyword">int</span> index, PhoneNumber value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addPhones</span><span class="params">(PhoneNumber value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addAllPhones</span><span class="params">(Iterable&lt;PhoneNumber&gt; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearPhones</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如您所见，每个字段都有简单的JavaBeans样式的getter和setter。针对每个字段都有getter，如果已设置该字段，则返回true。最后，每个字段都有一个<code>clear</code>方法，将字段取消设置回其空状态。</p><p>重复字段有一些额外的方法 - 一个Count方法（它只是列表大小的简写），getter和setter通过索引获取或设置列表的特定元素，add方法将一个新元素附加到列表，以及一个addAll方法，它将整个容器中的元素添加到列表中。</p><p>有关protocol编译器为任何特定字段定义生成的确切成员的更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="noopener">Java generated code reference</a>。</p><h2 id="2-6-Enums-and-Nested-Classes"><a href="#2-6-Enums-and-Nested-Classes" class="headerlink" title="2.6 Enums and Nested Classes"></a>2.6 Enums and Nested Classes</h2><p>生成的代码包含一个嵌套在Person中的PhoneType枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">  MOBILE(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  HOME(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">  WORK(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">  ;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所期望的那样，生成嵌套类型Person.PhoneNumber，作为Person中的嵌套类。</p><h2 id="2-7-Builders-vs-Messages"><a href="#2-7-Builders-vs-Messages" class="headerlink" title="2.7 Builders vs. Messages"></a>2.7 Builders vs. Messages</h2><p>Protocol Buffer编译器生成的消息类都是不可变的。一旦构造了消息对象，就像Java String那样不能修改它。要构造消息，必须首先构造构建器，将要设置的任何字段设置为所选值，然后调用构建器的<code>build()</code>方法。</p><p>您可能已经注意到构建器的每个修改消息的方法都会返回另一个构建器。返回的对象实际上是您调用该方法的同一个构建器。为方便起见，它会返回，以便您可以在一行代码中将多个setter串在一起。</p><p>这是一个如何创建Person实例的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person john =</span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">"John Doe"</span>)</span><br><span class="line">    .setEmail(<span class="string">"jdoe@example.com"</span>)</span><br><span class="line">    .addPhones(</span><br><span class="line">      Person.PhoneNumber.newBuilder()</span><br><span class="line">        .setNumber(<span class="string">"555-4321"</span>)</span><br><span class="line">        .setType(Person.PhoneType.HOME))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="2-8-Standard-Message-Methods"><a href="#2-8-Standard-Message-Methods" class="headerlink" title="2.8. Standard Message Methods"></a>2.8. Standard Message Methods</h2><p>每个消息和构建器类还包含许多其他方法，可用于检查或操作整个消息，包括：</p><ul><li><code>isInitialized()</code>: 检查是否已设置所有必填字段。</li><li><code>toString()</code>:返回人类可读消息，对调试特别有用</li><li><code>mergeFrom(Message other)</code>:(仅限构建器)将其他内容合并到此消息中，覆盖单个标量字段，合并复合字段以及连接重复字段。</li><li><code>clear()</code>:（仅限构建器）将所有字段清除回空状态。</li></ul><p>这些方法实现了所有Java消息和构建器共享的Message和Message.Builder接口。有关更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener">complete API documentation for <code>Message</code></a>。</p><h2 id="2-9-Parsing-and-Serialization"><a href="#2-9-Parsing-and-Serialization" class="headerlink" title="2.9 Parsing and Serialization"></a>2.9 Parsing and Serialization</h2><p>最后，每个protocol buffer类都有相应的方法使用protocol buffer二进制格式去编写和读取所选类型的消息的方法。这些包括：</p><ul><li><code>byte[] toByteArray();</code>: 序列化消息并返回包含其原始字节的字节数组。</li><li><code>static Person parseFrom(byte[] data);</code>: 根据字节数组来解析消息。</li><li><code>void writeTo(OutputStream output);</code>: 序列化消息并将其写入<code>OutputStream</code>。</li><li><code>static Person parseFrom(InputStream input);</code>: 从InputStream读取和解析消息。</li></ul><p>这些只是解析和序列化提供的几个选项。再次，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener"><code>Message</code> API reference</a>以获取完整列表。</p><h1 id="3-Developer-Guide"><a href="#3-Developer-Guide" class="headerlink" title="3. Developer Guide"></a>3. Developer Guide</h1><p>欢迎开发者来到Protocol buffers文档 – 一种与语言无关，平台无关，可扩展的序列化结构化数据的方法，用于通信协议，数据存储等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RPC:Remote Procedure Call,远程过程调用，很多RPC框架是夸语言的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个接口说明文件：描述了对象(结构图体)，对象成员，接口方法等一系列信息&lt;/li&gt;
&lt;li&gt;通过RPC框架所提供的编码器，将接口说明文件编译成集体的语言
      
    
    </summary>
    
      <category term="Protocol buffer" scheme="http://blog.shagle.cn/categories/Protocol-buffer/"/>
    
    
      <category term="rpc" scheme="http://blog.shagle.cn/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较</title>
    <link href="http://blog.shagle.cn/2019/03/12/IO%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/03/12/IO复用/</id>
    <published>2019-03-12T06:48:27.000Z</published>
    <updated>2019-03-12T06:49:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较</p><p><a href="http://www.cnblogs.com/wujing-hubei/p/6111347.html" target="_blank" rel="noopener">http://www.cnblogs.com/wujing-hubei/p/6111347.html</a><br><a href="https://www.cnblogs.com/bw13/p/6410877.html" target="_blank" rel="noopener">https://www.cnblogs.com/bw13/p/6410877.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wujing-hubei/p/6111347.html&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="rpc" scheme="http://blog.shagle.cn/categories/rpc/"/>
    
    
      <category term="I/O多路复用" scheme="http://blog.shagle.cn/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>grpc翻译</title>
    <link href="http://blog.shagle.cn/2019/03/10/grpc%E7%BF%BB%E8%AF%91/"/>
    <id>http://blog.shagle.cn/2019/03/10/grpc翻译/</id>
    <published>2019-03-10T07:48:49.000Z</published>
    <updated>2019-03-10T10:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>grpc 官网<a href="https://grpc.io" target="_blank" rel="noopener">https://grpc.io</a></p><p>grpc 是一个高效的，开源的，统一的rpc框架</p><h1 id="grpc-的基本特点是："><a href="#grpc-的基本特点是：" class="headerlink" title="grpc 的基本特点是："></a>grpc 的基本特点是：</h1><ul><li>简单的服务定义：可以使用protocol buffers来定义你的服务，protocol buffers本身是一个强大的，二进制序列化工具集和语言</li><li>可以跨越语言和平台：可以为你的服务自动的生成习惯使用的客户端和服务端的stubs语言和平台</li><li>快速启动或扩展：通过一个简单的命令安装到开发环境或运行是环境并扩展为百万级别的rpc框架</li><li>双向的流并集成授权：基于http 2传输的二进制双向流并完全集成可插拔的身份验证</li></ul><h1 id="guides"><a href="#guides" class="headerlink" title="guides"></a>guides</h1><h2 id="1-what-is-grpc"><a href="#1-what-is-grpc" class="headerlink" title="1. what is grpc"></a>1. what is grpc</h2><p>这个文档介绍了grpc和protocol buffers，grpc可以使用protocol buffers即作为它的IDL(接口描述语言，接口定义语言)，可以使用它作为它底层的消息交换格式，如果你是一个不了解grpc或protocol buffers的就继续往下读</p><h3 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1. Overview"></a>1.1. Overview</h3><p><code>在Grpc客户端应用中可以调用各机器上各服务上的各方法，就好像是一个本地对象一样，这使的你可以创建分布式应用与服务</code>。就像很多RPC系统一样，gRPC是基于这样一个想法，定义一个服务，指定好可以远程调用的方法，同时带上参数和返回值，在服务器端，实现接口，然后运行一个gRPC服务器来处理客户端的调用。另外在客户端有一个stub(在某些语言中也叫client)，它提供了可服务器相同的方法</p><p><img src="20190310162030.png" alt=""></p><p>gRPC客户端和服务器可以在各种环境中相互运行和通信 - 从Google内部的服务器到您自己的桌面 - 并且可以使用任何gRPC支持的语言编写。例如，您可以使用Go，Python或Ruby轻松创建Java中的gRPC服务器。此外，最新的Google API将具有gRPC版本的界面，让您可以轻松地在应用程序中构建Google功能。</p><h3 id="1-2-Working-with-Protocol-Buffers"><a href="#1-2-Working-with-Protocol-Buffers" class="headerlink" title="1.2. Working with Protocol Buffers"></a>1.2. Working with Protocol Buffers</h3><h4 id="1-2-1-Protocol-buffer-versions"><a href="#1-2-1-Protocol-buffer-versions" class="headerlink" title="1.2.1 Protocol buffer versions"></a>1.2.1 Protocol buffer versions</h4><p>虽然Protocol buffer对用户已经开源了一段时间了，但是他们的实例使用的Proto3，它提供了稍微简介的语法，新的特效，并支持更多的语言，目前可以使用到Java, C++, Python, Objective-C, C#, a lite-runtime (Android Java), Ruby, and JavaScript，Go 或更多的语言开发。您可以在proto3语言指南和每种语言的参考文档中找到更多信息。参考文档还包括.proto文件格式的正式规范。</p><p>一般来说你可以使用proto2(当前Protocol buffer默认版本号)，在使用gRPC中我们建议你使用Proto3，以便于支持更多的功能和特效，以便于出现如下错误，一端使用的Proto2，一边使用的Proto3，版本不一样出现一下兼容性问题，</p><h2 id="2-gRPC-Concepts"><a href="#2-gRPC-Concepts" class="headerlink" title="2. gRPC Concepts"></a>2. gRPC Concepts</h2><h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h3><h4 id="2-1-2-Service-definition"><a href="#2-1-2-Service-definition" class="headerlink" title="2.1.2 Service definition"></a>2.1.2 Service definition</h4><p>与许多RPC系统一样，gRPC基于定义服务的思想，指定可以使用的参数和返回类型远程调用的方法，默认情况下，gRPC使用Protocol buffer作为接口定义语言（IDL）来描述服务接口和有效负载消息的结构。如果需要，可以使用其他替代方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service HelloService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">  string reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gRPC可以让我们定义四种方法</strong></p><ul><li>客户端向服务器发送单个请求并返回单个响应，就像正常的函数调用一样。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">SayHello</span><span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务器流式RPC，客户端向服务器发送请求并获取流以读取消息序列。客户端从返回的流中读取，直到没有更多消息。gRPC保证单个RPC调用中的消息排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">LotsOfReplies</span><span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(stream HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端流式RPC，客户端再次使用提供的流写入一系列消息并将其发送到服务器。一旦客户端写完消息，它就等待服务器读取它们并返回它的响应。gRPC再次保证在单个RPC调用中的消息排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">LotsOfGreetings</span><span class="params">(stream HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向流式RPC，双方使用读写流发送一系列消息。 两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序进行读写：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替地读取消息然后写入消息，或者其他一些读写组合。保留每个流中的消息顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">BidiHello</span><span class="params">(stream HelloRequest)</span> <span class="title">returns</span> <span class="params">(stream HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在下面的RPC生命周期部分中更详细地介绍不同类型的RPC。</p><h3 id="2-1-2-Using-the-API-surface"><a href="#2-1-2-Using-the-API-surface" class="headerlink" title="2.1.2 Using the API surface"></a>2.1.2 Using the API surface</h3><p>开始在.proto文件中的定义service，gRPC提供了生成客户端和服务器端代码的Protocol buffer编译器插件。gRPC用户通常在客户端调用这些API，并在服务器端实现相应的API。</p><ul><li><p>在服务器端，服务器实现service声明的方法，并运行gRPC服务器来处理客户端调用。gRPC基础结构解码传入请求，执行server方法并对服务响应进行编码。</p></li><li><p>在客户端，客户端有一个称为存根的本地对象（对于某些语言，首选术语是客户端），它实现与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的protocol buffer 消息类型中 - gRPC在将请求发送到服务器并返回服务器的protocol buffer响应之后查看。</p></li></ul><h3 id="2-1-3-Synchronous-vs-asynchronous"><a href="#2-1-3-Synchronous-vs-asynchronous" class="headerlink" title="2.1.3 Synchronous vs. asynchronous"></a>2.1.3 Synchronous vs. asynchronous</h3><p>在响应从服务器到达之前阻塞的同步RPC调用最接近RPC所期望的过程调用的抽象。 另一方面，网络本质上是异步的，在许多情况下，能够在不阻塞当前线程的情况下启动RPC是有用的。</p><p>大多数语言的gRPC编程表面都有同步和异步两种版本。您可以在每种语言的教程和参考文档中找到更多信息（完整的参考文档即将推出）。</p><h2 id="3-RPC-life-cycle"><a href="#3-RPC-life-cycle" class="headerlink" title="3. RPC life cycle"></a>3. RPC life cycle</h2><p>现在让我们仔细看看当gRPC客户端调用gRPC服务器方法时会发生什么。我们不会查看实现细节，您可以在我们特定语言的页面中找到有关这些内容的更多信息。</p><h3 id="3-1-Unary-RPC"><a href="#3-1-Unary-RPC" class="headerlink" title="3.1 Unary RPC"></a>3.1 Unary RPC</h3><p>首先让我们看一下最简单的RPC类型，客户端发送单个请求并返回单个响应</p><ul><li>一旦点用客户端的stub/client对象，这个服务器被通知此次RPC被调用已使用的客户端元数据，调用方法，并在指定时间内，</li><li>然后，服务器可以立即发送回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息 - 首先发生的是特定于应用程序的消息。</li><li>一旦服务器具有客户端的请求消息，它就会执行创建和填充其响应所需的任何工作。然后将响应与状态详细信息（状态代码和可选状态消息）以及可选的尾随元数据一起返回（如果成功）到客户端。</li><li>如果状态为OK，则客户端获取响应，从而完成客户端的调用。</li></ul><h3 id="3-2-Server-streaming-RPC"><a href="#3-2-Server-streaming-RPC" class="headerlink" title="3.2 Server streaming RPC"></a>3.2 Server streaming RPC</h3><p>服务器流RPC类似于我们的简单示例，除了服务器在获取客户端的请求消息后返回响应流。在返回所有响应之后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将被发送回服务器端完成。一旦客户端拥有所有服务器的响应，客户端就会完成</p><h3 id="3-3-Client-streaming-RPC"><a href="#3-3-Client-streaming-RPC" class="headerlink" title="3.3 Client streaming RPC"></a>3.3 Client streaming RPC</h3><p>客户端流式RPC也类似于我们的简单示例，除了客户端向服务器发送请求流而不是单个请求。服务器发送回单个响应，通常但不一定在收到所有客户端请求后，以及其状态详细信息和可选的尾随元数据。</p><h3 id="3-4-Bidirectional-streaming-RPC"><a href="#3-4-Bidirectional-streaming-RPC" class="headerlink" title="3.4 Bidirectional streaming RPC"></a>3.4 Bidirectional streaming RPC</h3><p>在双向流式RPC中，调用再次由调用方法的客户端和接收客户端元数据，方法名称和截止时间的服务器启动。服务器再次可以选择发回其初始元数据或等待客户端开始发送请求。</p><p>接下来会发生什么取决于应用程序，因为客户端和服务器可以按任何顺序读写 - 流完全独立地运行。例如，服务器可以等到它收到所有客户端的消息之后再写入其响应，或者服务器和客户端可以“ping-pong”：服务器获取请求，然后发回响应，然后客户端发送另一个基于响应的请求，等等。</p><h3 id="3-5-Deadlines-Timeouts"><a href="#3-5-Deadlines-Timeouts" class="headerlink" title="3.5 Deadlines/Timeouts"></a>3.5 Deadlines/Timeouts</h3><p>gRPC允许客户端指定在RPC终止之前愿意等待RPC完成的时间，错误为DEADLINE_EXCEEDED,在服务器端，服务器可以查询特定RPC是否已超时，或者剩余多少时间来完成RPC。</p><p>指定截止日期或超时的方式因语言而异 - 例如，并非所有语言都有默认截止日期，某些语言API在截止日期（固定时间点）工作，某些语言API在超时方面工作（持续时间）</p><h3 id="RPC-termination"><a href="#RPC-termination" class="headerlink" title="RPC termination"></a>RPC termination</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;grpc 官网&lt;a href=&quot;https://grpc.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://grpc.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;grpc 是一个高效的，开源的，统一的rpc框架&lt;/p&gt;
&lt;h1 id=&quot;grpc-的基本特
      
    
    </summary>
    
      <category term="rpc" scheme="http://blog.shagle.cn/categories/rpc/"/>
    
    
      <category term="grpc" scheme="http://blog.shagle.cn/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>Redis之字符串</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之字符串/</id>
    <published>2019-03-08T05:21:20.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h1><p>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。<br>举个例子，如果客户端执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS。</li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS。<br>又比如，如果客户端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串”fruits”的SDS。</p></li><li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串”apple”，第二个SDS保存着字符串”banana”，第三个SDS保存着字符串”cherry”。</li></ul><h2 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1 SDS的定义"></a>1.1 SDS的定义</h2><p>每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图2-1展示了一个SDS示例：</p><p><img src="20190308132256.png" alt=""></p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存</li></ul><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</p><h1 id="2。2-对c和sds之间区别进行总结"><a href="#2。2-对c和sds之间区别进行总结" class="headerlink" title="2。2 对c和sds之间区别进行总结"></a>2。2 对c和sds之间区别进行总结</h1><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(N)</td><td style="text-align:left">获取字符串长度复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API思安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重新分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存分配</td></tr><tr><td style="text-align:left">只能保持文本数据</td><td style="text-align:left">可以保存文本或二进制数据</td></tr><tr><td style="text-align:left">可以使用所有&lt;string.h&gt;库中的函数</td><td style="text-align:left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p>SDS 主要API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table><p>sdsnew|    创建一个包含给定 C 字符串的 SDS 。    |O(N) ， N 为给定 C 字符串的长度。<br>sdsempty|    创建一个不包含任何内容的空 SDS 。    |O(1)<br>sdsfree|    释放给定的 SDS 。    |O(1)<br>sdslen|    返回 SDS 的已使用空间字节数。    |这个值可以通过读取 SDS 的 len 属性来直接获得， 复杂度为 O(1) 。<br>sdsavail|    返回 SDS 的未使用空间字节数。    |这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1) 。<br>sdsdup|    创建一个给定 SDS 的副本（copy）。    |O(N) ， N 为给定 SDS 的长度。<br>sdsclear|    清空 SDS 保存的字符串内容。|    因为惰性空间释放策略，复杂度为 O(1) 。<br>sdscat|    将给定 C 字符串拼接到 SDS 字符串的末尾。    |O(N) ， N 为被拼接 C 字符串的长度。<br>sdscatsds|    将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。    |O(N) ， N 为被拼接 SDS 字符串的长度。<br>sdscpy|    将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。    |O(N) ， N 为被复制 C 字符串的长度。<br>sdsgrowzero|    用空字符将 SDS 扩展至给定长度。|    O(N) ， N 为扩展新增的字节数。<br>sdsrange|    保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。    |O(N) ， N 为被保留数据的字节数。<br>sdstrim|    接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。    |O(M*N) ， M 为 SDS 的长度， N 为给定 C 字符串的长度。<br>sdscmp|    对比两个 SDS 字符串是否相同。    |O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单动态字符串&quot;&gt;&lt;a href=&quot;#1-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;1. 简单动态字符串&quot;&gt;&lt;/a&gt;1. 简单动态字符串&lt;/h1&gt;&lt;p&gt;当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Re
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之链表</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之链表/</id>
    <published>2019-03-08T05:17:42.000Z</published>
    <updated>2019-03-08T05:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h1><h2 id="1-1-链表和链表节点的实现"><a href="#1-1-链表和链表节点的实现" class="headerlink" title="1.1 链表和链表节点的实现"></a>1.1 链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    struct listNode * prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    struct listNode * next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line"></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表，如图3-1所示。</p><p><img src="20190304174146.png" alt=""></p><p>虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    unsigned <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>图3-2是由一个list结构和三个listNode结构组成的链表。</li></ul><p><img src="20190304180006.png" alt=""></p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free […]</li></ul><h2 id="1-2-链表和链表节点的API"><a href="#1-2-链表和链表节点的API" class="headerlink" title="1.2 链表和链表节点的API"></a>1.2 链表和链表节点的API</h2><p>表3-1列出了所有用于操作链表和链表节点的API。</p><p>表 3-1 链表和链表节点 API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数。</td><td style="text-align:left">复制函数可以通过链表的 dup 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数。</td><td style="text-align:left">释放函数可以通过链表的 free 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数。</td><td style="text-align:left">对比函数可以通过链表的 match 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）。</td><td style="text-align:left">链表长度可以通过链表的 len 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点。</td><td style="text-align:left">表头节点可以通过链表的 head 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表尾节点。</td><td style="text-align:left">表尾节点可以通过链表的 tail 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点。</td><td style="text-align:left">前置节点可以通过节点的 prev 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点。</td><td style="text-align:left">后置节点可以通过节点的 next 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值。</td><td style="text-align:left">节点值可以通过节点的 value 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr></tbody></table><h2 id="1-3-重点回顾"><a href="#1-3-重点回顾" class="headerlink" title="1.3 重点回顾"></a>1.3 重点回顾</h2><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-链表&quot;&gt;&lt;a href=&quot;#1-链表&quot; class=&quot;headerlink&quot; title=&quot;1. 链表&quot;&gt;&lt;/a&gt;1. 链表&lt;/h1&gt;&lt;h2 id=&quot;1-1-链表和链表节点的实现&quot;&gt;&lt;a href=&quot;#1-1-链表和链表节点的实现&quot; class=&quot;header
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之对象</title>
    <link href="http://blog.shagle.cn/2019/03/07/Redis%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.shagle.cn/2019/03/07/Redis之对象/</id>
    <published>2019-03-07T09:32:18.000Z</published>
    <updated>2019-03-07T09:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="redis设计与实现.md">在前面的数个章节里</a>，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p><p>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><p>本章接下来将逐一介绍以上提到的Redis对象系统的各个特性。</p><h1 id="1-对象的类型与编码"><a href="#1-对象的类型与编码" class="headerlink" title="1. 对象的类型与编码"></a>1. 对象的类型与编码</h1><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。<br>举个例子，以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值”msg”的对象，而键值对的值则是一个包含了字符串值”hello world”的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    unsigned type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1 类型"></a>1.1 类型</h2><p>对象的type属性记录了对象的类型，这个属性的值可以是表8-1列出的常量的其中一个。</p><p><img src="20190307173736.png" alt=""></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为哈希对象</span><br><span class="line"></span><br><span class="line">redis&gt; HMSET profile name Tom age 25 career Programmer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE profile</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE fruits</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为有序集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE price</span><br><span class="line">zset</span><br></pre></td></tr></table></figure><p><img src="20190307174110.png" alt=""></p><h2 id="1-2-编码和底层实现"><a href="#1-2-编码和底层实现" class="headerlink" title="1.2 编码和底层实现"></a>1.2 编码和底层实现</h2><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表8-3列出的常量的其中一个。</p><p><img src="20190307174221.png" alt=""></p><p>每种类型的对象都至少使用了两种不同的编码，表8-4列出了每种类型的对象可以使用的编码。</p><p><img src="20190307174256.png" alt=""></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SET story &quot;long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers &quot;seven&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>表8-5列出了不同编码的对象所对应的OBJECT ENCODING命令输出。</p><p><img src="20190307174357.png" alt=""></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><p>在接下来的内容中，我们将分别介绍Redis中的五种不同类型的对象，说明这些对象底层所使用的编码方式，列出对象从一种编码转换成另一种编码所需的条件，以及同一个命令在多种不同编码上的实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;redis设计与实现.md&quot;&gt;在前面的数个章节里&lt;/a&gt;，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。&lt;/p&gt;
&lt;p&gt;Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>压缩列表zipList</title>
    <link href="http://blog.shagle.cn/2019/03/07/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8zipList/"/>
    <id>http://blog.shagle.cn/2019/03/07/压缩列表zipList/</id>
    <published>2019-03-07T02:11:07.000Z</published>
    <updated>2019-03-07T05:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表(<code>ziplist</code>)是列表键和哈希键的底层实现之一。</p><h1 id="1-压缩列表的构成"><a href="#1-压缩列表的构成" class="headerlink" title="1. 压缩列表的构成"></a>1. 压缩列表的构成</h1><p>压缩列表是<code>Redis</code>为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点,每个节点可以保存一个字节数组或者一个整数值。</p><p>当一个哈希键只包含少量key-value对，且每个key-value对的key和value要么是小整数，要么是较短字符串，那么redis就会使用<code>ziplist</code>作为哈希键的底层实现。</p><h1 id="2-ziplist的实现："><a href="#2-ziplist的实现：" class="headerlink" title="2. ziplist的实现："></a>2. ziplist的实现：</h1><p>ziplist的内存布局如下所示：</p><p><img src="20160505101226534.png.png" alt="ziplist的内存布局"></p><ul><li><code>zlbytes</code>：4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</li><li><code>zltail</code>：4字节，记录压缩列表尾部节点距离起始地址的偏移量：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址</li><li><code>zllen</code>：2字节，记录压缩列表包含的节点数量</li><li><code>entry</code>：不定，列表中的每个节点,节点的长度由节点保存的内存决定</li><li><code>zlend</code>：1字节，特殊值0xFF，标记压缩列表的结束</li></ul><p>因此通过下面的宏定义可以非常方便的求出各个字段的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span><br><span class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span><br><span class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span><br><span class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span><br><span class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span><br><span class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span><br><span class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span><br></pre></td></tr></table></figure><p><strong>一个简单的ziplist示意图如下：</strong></p><p><img src="20160505100030534.png" alt=""></p><ul><li>列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。</li><li>列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li><li>列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。</li></ul><h1 id="3-压缩列表节点的构成"><a href="#3-压缩列表节点的构成" class="headerlink" title="3. 压缩列表节点的构成"></a>3. 压缩列表节点的构成</h1><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p><img src="20190307102401.png" alt=""></p><h2 id="3-1-previous-entry-length"><a href="#3-1-previous-entry-length" class="headerlink" title="3.1 previous_entry_length"></a>3.1 previous_entry_length</h2><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>图7-5展示了一个包含一字节长previous_entry_length属性的压缩列表节点，属性的值为0x05，表示前一节点的长度为5字节。</p><p><img src="20190307111032.png" alt="图7-5"></p><p>图7-6展示了一个包含五字节长previous_entry_length属性的压缩节点，属性的值为0xFE00002766，其中值的最高位字节0xFE表示这是一个五字节长的previous_entry_length属性，而之后的四字节0x00002766（十进制值10086）才是前一节点的实际长度。</p><p><img src="20190307111127.png" alt="图7-6"></p><p>因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。<br>举个例子，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p，如图7-7所示。</p><p><img src="20190307111221.png" alt="图7-7"></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。</p><p>图7-8展示了一个从表尾节点向表头节点进行遍历的完整过程：</p><p><img src="20190307111316.png" alt="图7-8"></p><ul><li>首先，我们拥有指向压缩列表表尾节点entry4起始地址的指针p1（指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail属性的值得出）；</li><li>通过用p1减去entry4节点previous_entry_length属性的值，我们得到一个指向entry4前一节点entry3起始地址的指针p2；</li><li>通过用p2减去entry3节点previous_entry_length属性的值，我们得到一个指向entry3前一节点entry2起始地址的指针p3；</li><li>通过用p3减去entry2节点previous_entry_length属性的值，我们得到一个指向entry2前一节点entry1起始地址的指针p4，entry1为压缩列表的表头节点；</li><li>最终，我们从表尾节点向表头节点遍历了整个列表。</li></ul><h2 id="3-2-encoding"><a href="#3-2-encoding" class="headerlink" title="3.2 encoding"></a>3.2 encoding</h2><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；<br>表7-2记录了所有可用的字节数组编码，而表7-3则记录了所有可用的整数编码。表格中的下划线“_”表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。</li></ul><p><img src="20190307111918.png" alt=""></p><p><img src="20190307130819.png" alt=""></p><h2 id="3-3-content"><a href="#3-3-content" class="headerlink" title="3.3 content"></a>3.3 content</h2><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p>图7-9展示了一个保存字节数组的节点<code>示例</code>：</p><p><img src="20190307131023.png" alt="图7-9"></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值”hello world”。</li></ul><p>图7-10展示了一个保存整数值的节点<code>示例</code>：</p><p><img src="20190307131251.png" alt=""></p><ul><li>编码11000000表示节点保存的是一个int16_t类型的整数值；</li><li>content属性保存着节点的值10086。</li></ul><h2 id="3-4-连锁更新"><a href="#3-4-连锁更新" class="headerlink" title="3.4. 连锁更新"></a>3.4. 连锁更新</h2><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如图7-11所示。</p><p><img src="20190307132432.png" alt="图7-11"></p><p>因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性，换句话说，e1至eN的所有节点的previous_entry_length属性都是1字节长的。<br>这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点，如图7-12所示。</p><p><img src="20190307132535.png" alt="图7-12"></p><p>因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。</p><p>因此，为了让e2的previous_entry_length属性可以记录下e1的长度，程序需要再次对压缩列表执行空间重分配操作，并将e2节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展……为了让每个节点的previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update），图7-13展示了这一过程。</p><p><img src="20190307132704.png" alt="图7-13"></p><p>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</p><p>考虑图7-14所示的压缩列表，如果e1至eN都是大小介于250字节至253字节的节点，big节点的长度大于等于254字节（需要5字节的previous_entry_length来保存），而small节点的长度小于254字节（只需要1字节的previous_entry_length来保存），那么当我们将small节点从压缩列表中删除之后，为了让e1的previous_entry_length属性可以记录big节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。</p><p><img src="20190307132846.png" alt="图7-14"></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N2)。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;压缩列表(&lt;code&gt;ziplist&lt;/code&gt;)是列表键和哈希键的底层实现之一。&lt;/p&gt;
&lt;h1 id=&quot;1-压缩列表的构成&quot;&gt;&lt;a href=&quot;#1-压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;1. 压缩列表的构成&quot;&gt;&lt;/a&gt;1. 压缩列表的
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>算法之SkipList跳表</title>
    <link href="http://blog.shagle.cn/2019/03/06/%E7%AE%97%E6%B3%95%E4%B9%8BSkipList%E8%B7%B3%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/06/算法之SkipList跳表/</id>
    <published>2019-03-06T07:10:11.000Z</published>
    <updated>2019-03-06T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么选择跳表"><a href="#1-为什么选择跳表" class="headerlink" title="1. 为什么选择跳表"></a>1. 为什么选择跳表</h1><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。</p><p>想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树</p><p>出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，</p><p>还要参考网上的代码，相当麻烦。</p><p>用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，</p><p>它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，</p><p>就能轻松实现一个 SkipList。</p><h1 id="2-有序表的搜索"><a href="#2-有序表的搜索" class="headerlink" title="2. 有序表的搜索"></a>2. 有序表的搜索</h1><p>考虑一个有序表：</p><p><img src="d5d03b36-abff-34ea-9c40-a1fbfb709a81.jpg" alt=""></p><p>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="7c904c3f-1f39-31af-b8cd-b6de27a94061.jpg" alt=""></p><p>这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：</p><p><img src="96983cb0-d60a-31da-953d-2dde4036ea6b.jpg" alt=""></p><p>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p><h1 id="3-跳表"><a href="#3-跳表" class="headerlink" title="3. 跳表"></a>3. 跳表</h1><p>下面的结构是就是跳表：</p><p>其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。</p><p><img src="f4c149bd-d8ea-39ff-813f-93d809c90966.jpg" alt=""></p><p>跳表具有如下性质：</p><ul><li>(1) 由很多层结构组成</li><li>(2) 每一层都是一个有序的链表</li><li>(3) 最底层(Level 1)的链表包含所有元素</li><li>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li><li>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ul><h1 id="4-跳表的搜索"><a href="#4-跳表的搜索" class="headerlink" title="4. 跳表的搜索"></a>4. 跳表的搜索</h1><p><img src="ec9fd643-f85c-3072-8634-60cfc88ab334.jpg" alt=""></p><p>例子：查找元素 117</p><ul><li>(1) 比较 21， 比 21 大，往后面找</li><li>(2) 比较 37,   比 37大，比链表最大值小，从 37 的下面一层开始找</li><li>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</li><li>(4) 比较 85， 比 85 大，从后面找</li><li>(5) 比较 117， 等于 117， 找到了节点。</li></ul><p>具体的搜索算法如下： </p><p><strong>C代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果存在 x, 返回 x 所在的节点， </span></span><br><span class="line"><span class="comment"> * 否则返回 x 的后继节点 */</span>  </span><br><span class="line">find(x)   </span><br><span class="line">&#123;  </span><br><span class="line">    p = top;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;key &lt; x)  </span><br><span class="line">            p = p-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;down == NULL)   </span><br><span class="line">            <span class="keyword">return</span> p-&gt;next;  </span><br><span class="line">        p = p-&gt;down;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-跳表的插入"><a href="#5-跳表的插入" class="headerlink" title="5. 跳表的插入"></a>5. 跳表的插入</h1><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K = 2</p><p><img src="bb72be16-6162-3fee-b680-311f25dd7c3a.jpg" alt=""></p><p>如果 K 大于链表的层数，则要添加新的层。</p><p>例子：插入 119， K = 4</p><p><img src="6eac083f-45d9-37f9-867f-0d709d9659d3.jpg" alt=""></p><h1 id="6-丢硬币决定-K"><a href="#6-丢硬币决定-K" class="headerlink" title="6. 丢硬币决定 K"></a>6. 丢硬币决定 K</h1><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    K = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (random(<span class="number">0</span>,<span class="number">1</span>))  </span><br><span class="line">        K++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> K;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，<br>用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，<br>K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p><h1 id="7-跳表的高度。"><a href="#7-跳表的高度。" class="headerlink" title="7. 跳表的高度。"></a>7. 跳表的高度。</h1><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，跳表的高度等于这 n 次实验中产生的最大 K，待续。。。</p><h1 id="8-跳表的空间复杂度分析"><a href="#8-跳表的空间复杂度分析" class="headerlink" title="8. 跳表的空间复杂度分析"></a>8. 跳表的空间复杂度分析</h1><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的期望值是 2n。</p><h1 id="9-跳表的删除"><a href="#9-跳表的删除" class="headerlink" title="9. 跳表的删除"></a>9. 跳表的删除</h1><p>在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。</p><p>例子：删除 71</p><p><img src="7bab9ad1-9f5a-37d0-bc38-89ee50d1bc0d.jpg" alt=""></p><p><a href="https://kenby.iteye.com/blog/1187303" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么选择跳表&quot;&gt;&lt;a href=&quot;#1-为什么选择跳表&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么选择跳表&quot;&gt;&lt;/a&gt;1. 为什么选择跳表&lt;/h1&gt;&lt;p&gt;目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, T
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.shagle.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="SkipList跳表" scheme="http://blog.shagle.cn/tags/SkipList%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现</title>
    <link href="http://blog.shagle.cn/2019/03/04/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.shagle.cn/2019/03/04/redis设计与实现/</id>
    <published>2019-03-04T06:45:49.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库键总是一个字符串对象（string object）；</li><li>而数据库键的值则可以是字符串对象、列表对象（list object）、哈希对象（hash object）、集合对象（set object）、有序集合对象（sorted set object）这五种对象中的其中一种。</li></ul><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. <a href="Redis之字符串.md">字符串</a></h1><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. <a href="Redis之链表.md">链表</a></h1><h1 id="4-字典"><a href="#4-字典" class="headerlink" title="4. 字典"></a>4. 字典</h1><h1 id="5-跳跃表"><a href="#5-跳跃表" class="headerlink" title="5. 跳跃表"></a>5. <a href="算法之SkipList跳表.md">跳跃表</a></h1><h1 id="6-整数集合"><a href="#6-整数集合" class="headerlink" title="6. 整数集合"></a>6. 整数集合</h1><h1 id="7-压缩列表"><a href="#7-压缩列表" class="headerlink" title="7. 压缩列表"></a>7. <a href="压缩列表zipList.md">压缩列表</a></h1><p>压缩列表参考：<a href="https://blog.csdn.net/u012658346/article/details/51321337" target="_blank" rel="noopener">https://blog.csdn.net/u012658346/article/details/51321337</a></p><h1 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. <a href="Redis之对象.md">对象</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock源码解析</title>
    <link href="http://blog.shagle.cn/2019/02/28/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.shagle.cn/2019/02/28/Java技术之ReentrantReadWriteLock源码解析/</id>
    <published>2019-02-28T07:14:17.000Z</published>
    <updated>2019-02-28T07:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-阅读须知"><a href="#1-阅读须知" class="headerlink" title="1. 阅读须知"></a>1. 阅读须知</h1><ul><li><p>JDK版本：1.8</p></li><li><p>文章中使用/**/注释的方法会做深入分析</p></li></ul><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><p><code>ReentrantReadWriteLock</code>，从字面上理解为可重入读写锁，基于<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>，不了解AQS的读者可以去看笔者关于AQS源码解析的文章进行学习）实现，根据读写锁的特性，我们可以猜测，读锁应该是基于AQS的共享锁实现，而写锁应该是基于AQS的独占锁实现，我们来验证这个猜想，首先看一下<code>ReentrantReadWriteLock</code>的构造方法：</p><p><strong>ReentrantReadWriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的boolean变量fair来确定使用公平锁或非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>默认的无参构造方法使用的是非公平锁。我们来介绍一下<code>ReentrantReadWriteLock</code>中的同步器<code>Sync</code>中的一些变量：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁占用高16位表示持有读锁的线程的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//根据SHARED_SHIFT变量的含义，每增加一个持有读锁的线程，state变量就需要累加这个值，也就是1左移16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">//持有读锁的线程的最大数量（65535）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//用于计算写锁的重入计数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//当前线程持有的读锁的重入数量。只在构造函数和readObject方法中初始化。线程的锁重入计数降至0时删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"><span class="comment">//最后一个成功获取readLock的线程的持有锁计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="comment">//firstReader是获取读锁的第一个线程。</span></span><br><span class="line"><span class="comment">//更确切地说，firstReader是最后一次将共享计数从0更改为1的唯一线程，</span></span><br><span class="line"><span class="comment">//并且自那以后未释放读锁; 如果没有这样的线程，则返回null。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//firstReaderHoldCount是firstReader的锁重入计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>使用<code>AQS</code>的<code>state</code>的高16位表示持有读锁的线程的数量，低16位表示写锁被同一个线程申请的次数，也就是锁重入的次数。接下来我们来看加锁实现，我们首先来看读锁部分：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（共享锁部分）这篇文章中进行过详细分析，方法的开始会调用有子类实现的<code>tryAcquireShared</code>方法尝试以共享模式获得锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquireShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果独占锁的重入计数不为0（说明有线程持有独占锁）并且持有独占锁的线程不是当前线程返回-1代表获取共享锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">//共享锁的持有线程数量</span></span><br><span class="line">    <span class="comment">/*判断当前获取读锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//共享锁的持有线程的数量是否超过了最大值</span></span><br><span class="line">    <span class="comment">//CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//满足条件说明当前没有任何任何线程持有共享锁，则将当前线程设置为获取共享锁的第一个线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">//锁重入数量初始化为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果当前获取共享锁的线程是获取共享锁的第一个线程，则递增锁重入数量</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">//如果最后一个成功获取readLock的线程的锁重入计数对象还未初始化或者对象内部维护的线程id不是当前线程id</span></span><br><span class="line">                <span class="comment">//则将cachedHoldCounter赋值为当前线程的锁重入计数对象</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++; <span class="comment">//递增当前线程的锁重入计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*tryAcquireShared方法的完整版*/</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下方法的执行过程：</p><ul><li><ol><li>如果另一个线程持有写锁，则获取共享锁失败。</li></ol></li><li><ol start="2"><li>否则，此线程符合锁定状态，判断是否应该因为队列策略而阻塞。如果没有，尝试通过CAS增加共享锁的持有线程的数量。请注意，这步不会检查重入获取，它会被推迟到<code>fullTryAcquireShared</code>方法执行，以避免在更典型的非重入情况下检查锁重入计数。</li></ol></li><li><ol start="3"><li>如果步骤2因线程需要阻塞或CAS失败或计数饱和而失败，则调用<code>fullTryAcquireShared</code>方法。 关于<code>readerShouldBlock</code>（判断当前获取读锁的线程是否需要阻塞）方法，有公平和非公平两种实现，我们首先来看非公平的实现：</li></ol></li></ul><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apparentlyFirstQueuedIsExclusive</code>方法来自AQS，主要用于判断等待队列的头结点的下一个节点也就是第一个排队的线程是否以独占模式等待。这里我们要结合调用<code>readerShouldBlock</code>方法之前的if判断进行分析，如果这个if判断不满足，说明有两种情况可能发生：</p><ul><li><ol><li>当前没有线程占用写锁，这种情况readerShouldBlock方法会返回false。</li></ol></li><li><ol start="2"><li>当前有线程占用写锁，并且占用写锁的线程就是当前线程（当前线程是<code>head</code>节点），这时就发生了锁降级的情况，也就是当前线程持有写锁，并在申请读锁，这时就要判断<code>head</code>节点的下一个节点是否要申请写锁，如果是则<code>readerShouldBlock</code>方法返回<code>true</code>，说明本次申请读锁的操作需要阻塞。</li></ol></li></ul><p>接下来我们来看<code>readerShouldBlock</code>方法公平锁的实现：</p><p><strong>ReentrantReadWriteLock.FairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasQueuedPredecessors</code>方法我们在<code>ReentrantLock</code>源码解析这篇文章中分析过，它的主要作用是确认当前线程是否是下一个能够优先获得锁的线程，公平性也就是通过这个判断来保证的。公平锁我们很好理解，就是根据等待队列中节点的顺序来保证获取锁的顺序。</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//同样的判断是否有非当前线程持有独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//同样的判断当前获取读锁操作是否需要阻塞</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//确保没有重复获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">//这里如果当前线程持有的共享锁重入计数为0，则移除锁重入计数对象</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//锁重入计数为0时，返回-1代表获取共享锁失败，要进行排队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="comment">//超过最大持有读锁线程数量抛出Error</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//再次尝试获取共享锁，判断CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">        <span class="comment">//整体共享锁获取成功的处理逻辑与tryAcquireShared方法基本一致</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看读锁释放的实现：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>releaseShared</code>释放共享锁方法同样来自于<code>AQS</code>，方法中首先会调用由子类覆盖的<code>tryReleaseShared</code>方法，通过尝试设置<code>state</code>变量来释放共享锁，我们来看<code>ReentrantReadWriteLock</code>对于<code>tryReleaseShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//判断当前线程是否是获取读锁的第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果锁重入计数为1，直接将获取读锁的第一个线程置为null，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果锁重入计数不为1（大于1），则在释放时递减锁重入计数</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">//这里的判断上文分析过</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count; <span class="comment">//当前线程的锁重入计数</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//小于等于1时说明这是最后一个重入锁，则移除锁重入计数对象</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//锁重入计数小于等于0说明本次解锁操作没有对应的加锁操作，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count; <span class="comment">//递减锁重入计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的自旋操作为递减共享锁持有的线程数量，与加锁时的递增操作正好相反</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，读锁的加锁和解锁操作就分析完了，下面我们来分析写锁的加锁和解锁操作，首先来看加锁：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，写锁是基于<code>AQS</code>的独占锁实现，这里的<code>acquire</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（独占锁部分）这篇文章中已经详细分析过，方法的第一步就是调用由子类实现的<code>tryAcquire</code>方法通过操作<code>state</code>变量尝试以独占模式获取锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquire</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">//如果AQS的state变量不为0，说明当前读锁或写锁有被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的判断如果成立说明读锁被占用写锁未被占用</span></span><br><span class="line">        <span class="comment">//或者写锁被占用但占用的线程不是当前线程，这是返回false代表获取写锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//写锁最大重入数量的判断</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//走到这里说明是写锁重入，则递增写锁重入计数</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里说明当前读锁和写锁都未被任何线程占用</span></span><br><span class="line">    <span class="comment">/*判断获取写锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//判断CAS递增写锁重入计数是否失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//设置写锁的拥有者线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>writerShouldBlock</code>方法同样区分公平和非公平两个版本的实现，我们先来看非公平版本的实现：</p><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现方法直接返回<code>false</code>，也就是说每个想要获取非公平写锁的线程都可以直接参与竞争。而<code>writerShouldBlock</code>方法公平锁的版本与读锁的<code>readerShouldBlock</code>方法的公平版本是一样的，都是需要确认当前线程是否是下一个能够优先获得锁的线程，以此来保证公平性。最后我们来看写锁的解锁操作：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>release</code>方法我们在<code>AQS</code>独占锁源码解析的文章中同样进行过详细的分析，<code>AQS</code>的<code>release</code>方法首先会尝试调用由子类实现的<code>tryRelease</code>方法来尝试设置<code>state</code>变量来释放独占锁，锁完全释放后，会对后继节点进行唤醒操作，这个流程我们已经分析过，不再赘述。我们来看<code>ReentrantReadWriteLock</code>的对<code>tryRelease</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁和解锁的线程必须是同一个，不然抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//递减写锁的重入计数</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果递减后的锁重入计数为0，说明锁已经被完全释放，这时将锁的拥有者线程置为null</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc); <span class="comment">//设置最新的锁重入计数</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解锁的流程就分析完成了。</p><p><code>ReentrantReadWriteLock</code>的写锁还支持<code>Condition</code>，与<code>ReentrantLock</code>一样完全基于<code>AQS</code>的<code>ConditionObject</code>实现，我们已经分析过<code>ConditionObject</code>源码，不明白的同学可以前往进行查阅学习。到这里，<code>ReentrantReadWriteLock</code>的源码分析就完成了。</p><p><a href="http://www.linkedkeeper.com/1118.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-阅读须知&quot;&gt;&lt;a href=&quot;#1-阅读须知&quot; class=&quot;headerlink&quot; title=&quot;1. 阅读须知&quot;&gt;&lt;/a&gt;1. 阅读须知&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK版本：1.8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文章中使用/**/注释的方法会做
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之CPU使用率为什么飚升？</title>
    <link href="http://blog.shagle.cn/2019/02/27/Java%E6%8A%80%E6%9C%AF%E4%B9%8BCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A3%9A%E5%8D%87%EF%BC%9F/"/>
    <id>http://blog.shagle.cn/2019/02/27/Java技术之CPU使用率为什么飚升？/</id>
    <published>2019-02-27T09:07:00.000Z</published>
    <updated>2019-02-27T09:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>频繁 Young GC 会不会引起 CPU 使用率飚升？</p><p>线程数很高的应用，CPU 使用率一定高么？</p><p>CPU 使用率高的应用，线程数一定高么？</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>分时操作系统 CPU 是耗费 us ？ 还是耗费 sy ？</p><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><p><strong>CPU 使用率怎么算？</strong></p><p>CPU% = 1 - idleTime / sysTime * 100</p><ul><li><p>idleTime：CPU处于空闲状态的时间</p></li><li><p>sysTime：CPU处于用户态和内核台的时间总和</p></li></ul><p><strong>CPU 使用率跟啥有关系？</strong></p><p>我们常听说计算密集型的程序是比较耗 CPU 使用率的。</p><p>那 JAVA 应用中哪些操作是比较耗 CPU 使用的？</p><p>列举下日常程序中常见的耗CPU的操作：</p><ul><li><p>频繁GC，访问量高时，有可能造成频繁的GC、甚至FGC。当调用量大时，内存分配过快，就会造成GC线程不停的执行，导致CPU飙高。</p></li><li><p>序列化与反序列化，后文中举了一个真实的案例，程序执行xml解析的时，调用量增大的情况下，导致了CPU被打满。</p></li><li><p>加密、解密。</p></li><li><p>正则表达式校验，曾经线上发生一次血案，正则校验将CPU打满。大概原因是：Java 正则表达式使用的引擎实现是 NFA 自动机，这种引擎在进行字符匹配会发生回溯（backtracking）。</p></li><li><p>线程上下文切换、当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待、IO等待等）和执行状态的变化过程中。当锁竞争激烈时，很容易出现这种情况。</p></li><li><p>某些线程在做无阻塞的运算，简单的例子while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的计算，可以适当将程序sleep下。</p></li></ul><p><strong>CPU 与进程、线程有关系么？</strong></p><p>现在分时操作系统是通过循轮方式分配时间片进行进程调度的，如果进程在等待或阻塞，不会造成 CPU 资源使用。线程称为轻进程，共享进程资源，关于线程的调度，CPU 对于线程也是分时调度。而在 Java 中，线程的调用由 JVM 负责，线程的调度一般有两种模式，分时调度和抢占式调度。</p><h1 id="我的解惑"><a href="#我的解惑" class="headerlink" title="我的解惑"></a>我的解惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>会的。先不说别的，死循环会调用 CPU 寄存器进行计数，这个操作就会占用 CPU。其次，如果线程一直处于死循环状态，CPU 调用会进行线程切换么？</p><p>死循环不会让出 CPU，除非操作系统时间片到期，但死循环会不断向系统申请时间片，直到系统没有空闲时间做别的事情。</p><p>这个问题在 stackoverflow 也有人提问：why does an infinite loop of the unintended kind increase the CPU use?</p><p>地址：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use</a></p><p><strong>频繁 Young GC 会不会引起 CPU 使用率飚升？</strong></p><p>会的。Young GC 本身是 JVM 进行垃圾回收的操作，会计算内存和调用寄存器，频繁 Young GC 一定是会占用 CPU。</p><p>之前有个一个案例，for 循环从数据库查询数据集合，二次封装新的数据集合，这时如果量比较大时，内存没有足够的空间存储，那么 JVM 就会 GC 回收那些不再使用的数据，因此量大的时候，就会收到 CPU 使用率报警。</p><p><strong>线程数很高的应用，CPU 使用率一定高么？</strong></p><p>不会。通过 jstack 查看系统线程状态，查看整个线程数很多，但 Runable 和 Running 状态的线程不多，这时 CPU 使用率不一定会高。</p><p>之前有过一个案例，查看系统线程数 1000+，jstack 分析 900多个线程是 BLOCKED 和 WAITING 状态的，这种线程是不会占用 CPU 的。</p><p>如果线程数很高，其实大多数原因是死锁，大量线程处于 BLOCKED 和 WAITING 状态。</p><p><strong>CPU 使用率高的应用，线程数一定高么？</strong></p><p>不会。同上，CPU 使用率高的关键因素还是计算密集型操作，一个线程如果有大量计算，也会造成 CPU 使用率高，也是现在为什么一个大数据脚本任务，要大规模集群共同运算才能运行的原因。</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>不一定，CPU使用率的飙升，更多是因为上下文的切换或者runnable状态线程过多导致。Blocked状态，未必会引起CPU上升。</p><p><strong>分时操作系统 CPU us高或者sy高是什么意思？</strong></p><p>通过top命令，我们可以观察到cpu的us，sy值，示例如下：</p><p><img src="linkedkeeper0_2fe93bbe-a4b1-4083-9288-56657fdb5ee5.jpg" alt=""></p><ul><li><p>Us 用户空间占用CPU百分比，简单来说，us高是因为我们的程序导致的，通过分析线程堆栈，可以很容易的定位到问题线程。</p></li><li><p>Sy 内核空间占用CPU百分比，sy高的时候，如果是程序问题导致，基本是因为线程上下文切换造成的。</p></li></ul><h1 id="我的经验"><a href="#我的经验" class="headerlink" title="我的经验"></a>我的经验</h1><p>平时怎么定位 CPU 使用率高的原因的？</p><p>其实网上有个教程和方法，我简述我的分析过程。</p><p>首先发现某台应用 CPU 使用率高，一要看先线程数、JVM、系统 load 等参数，共同作证。二要打印 jstack，通过工具分析线程情况，推荐 fastThread 这个在线的 Thread 分析工具。</p><p>以下是线上发生的真实案例，简要介绍下：</p><p>某日晚，突然收到短信报警，CPU利用率100%。立刻dump该机器jstack，通过 <a href="http://fastthread.io/" target="_blank" rel="noopener">http://fastthread.io/</a> 查看日志如下：</p><p><img src="linkedkeeper0_2d349092-9402-48ac-b7dc-763afa7bf4a4.jpg" alt=""></p><p>进一步查看具体日志：</p><p><img src="linkedkeeper0_dca206cc-cecc-4f3a-95fd-a937450712a2.jpg" alt=""></p><p>通过这段日志，已经定位到了具体CPU被打满的方法，接收MQ之后，MQ消息体为xml，反序列化的时候，造成了CPU飙高。</p><p><strong>希望本文对大家有所帮助。</strong> </p><p><a href="http://www.linkedkeeper.com/1310.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我的疑惑&quot;&gt;&lt;a href=&quot;#我的疑惑&quot; class=&quot;headerlink&quot; title=&quot;我的疑惑&quot;&gt;&lt;/a&gt;我的疑惑&lt;/h1&gt;&lt;p&gt;一个 while 死循环，会不会引起 CPU 使用率飚升？&lt;/p&gt;
&lt;p&gt;频繁 Young GC 会不会引起 CPU 使用率
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cpu" scheme="http://blog.shagle.cn/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之引用类型</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之引用类型/</id>
    <published>2019-02-26T05:40:42.000Z</published>
    <updated>2019-02-26T05:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-了解-强引用、软引用、弱引用、虚引用的概念"><a href="#一-了解-强引用、软引用、弱引用、虚引用的概念" class="headerlink" title="一.了解 强引用、软引用、弱引用、虚引用的概念"></a>一.了解 强引用、软引用、弱引用、虚引用的概念</h1><p>在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。</p><p>从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。下面来阐述一下这四种类型引用的概念：</p><h1 id="1-1-强引用（StrongReference）"><a href="#1-1-强引用（StrongReference）" class="headerlink" title="1.1.强引用（StrongReference）"></a>1.1.强引用（StrongReference）</h1><p>强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Object[] objArr = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p><p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><p>比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> element that was removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    Object oldValue = elementData[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                 numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (E)oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-软引用（SoftReference）"><a href="#1-2-软引用（SoftReference）" class="headerlink" title="1.2.软引用（SoftReference）"></a>1.2.软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        SoftReference&lt;String&gt; sr = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-弱引用（WeakReference）"><a href="#1-3-弱引用（WeakReference）" class="headerlink" title="1.3.弱引用（WeakReference）"></a>1.3.弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                <span class="comment">//通知JVM的gc进行垃圾回收</span></span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。</p><h2 id="1-4-虚引用（PhantomReference）"><a href="#1-4-虚引用（PhantomReference）" class="headerlink" title="1.4.虚引用（PhantomReference）"></a>1.4.虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p><p>要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>虚引用主要用于检测对象是否已经从内存中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br><span class="line">        System.out.println(pr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-进一步理解软引用和弱引用"><a href="#二-进一步理解软引用和弱引用" class="headerlink" title="二.进一步理解软引用和弱引用"></a>二.进一步理解软引用和弱引用</h1><p>对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><p>在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：</p><p>两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。</p><p>在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</p><h1 id="三-如何利用软引用和弱引用解决OOM问题"><a href="#三-如何利用软引用和弱引用解决OOM问题" class="headerlink" title="三.如何利用软引用和弱引用解决OOM问题"></a>三.如何利用软引用和弱引用解决OOM问题</h1><p>前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？</p><p>下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p><p>设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。</p><p>下面这段代码是摘自博客：</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 强引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加该对象到Map中使其缓存</span></span><br><span class="line"></span><br><span class="line">    imageCache.put(path, softBitmap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从缓存中取软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在软引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (softBitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = softBitmap.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里我们把缓存替换策略交给了JVM去执行，这是一种比较简单的处理方法。复杂一点的缓存，我们可以自己单独设计一个类，这里面就涉及到缓存策略的问题了，具体可以参考之前的一篇博文：<a href="http://www.cnblogs.com/dolphin0520/p/3749259.html" target="_blank" rel="noopener">《缓存算法（页面置换算法）-FIFO、LFU、LRU》</a></p><p>参考资料：</p><p>《深入理解JVM虚拟机》</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><p><a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">http://blog.csdn.net/zsuguangh/article/details/6429592</a></p><p><a href="http://mobile.51cto.com/abased-406998.htm" target="_blank" rel="noopener">http://mobile.51cto.com/abased-406998.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-了解-强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;a href=&quot;#一-了解-强引用、软引用、弱引用、虚引用的概念&quot; class=&quot;headerlink&quot; title=&quot;一.了解 强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;/a&gt;一.了解 强引用、软引用、弱引用、
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="强引用、软引用、弱引用、虚引用" scheme="http://blog.shagle.cn/tags/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之深入分析ThreadLocal</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ThreadLocal/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之深入分析ThreadLocal/</id>
    <published>2019-02-26T01:36:46.000Z</published>
    <updated>2019-02-26T06:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLoacal是什么？"><a href="#ThreadLoacal是什么？" class="headerlink" title="ThreadLoacal是什么？"></a>ThreadLoacal是什么？</h1><p>ThreadLocal是啥？以前面试别人时就喜欢问这个，有些伙伴喜欢把它和线程同步机制混为一谈，事实上ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？</p><p>API是这样介绍它的：</p><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code>或<code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。 <code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><ul><li>get()：返回此线程局部变量的当前线程副本中的值。</li><li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li><li>remove()：移除此线程局部变量当前线程的值。</li><li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li></ul><p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p><p>对于ThreadLocal需要注意的有两点：</p><ul><li><ol><li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li></ol></li><li><ol start="2"><li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li></ol></li></ul><p>下图是Thread、ThreadLocal、ThreadLocalMap的关系（<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）</a></p><p><img src="640.jpeg" alt=""></p><h1 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h1><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seqCount.set(seqCount.get() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seqCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SeqCount seqCount = <span class="keyword">new</span> SeqCount();</span><br><span class="line">        SeqThread thread1 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread2 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread3 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread4 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SeqCount seqCount;</span><br><span class="line">        SeqThread(SeqCount seqCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.seqCount = seqCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">" seqCount :"</span> + seqCount.nextSeq());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="641.jpeg" alt=""></p><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。这里我们想一个问题，在上面的代码中ThreadLocal的initialValue()方法返回的是0，加入该方法返回得是一个对象呢，会产生什么后果呢？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;A&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;A&gt;()&#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程请参考：对ThreadLocal实现原理的一点思考</p><h1 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h1><p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line"></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href="Java技术之引用类型.md">Java技术之引用类型</a>）</p><p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal key, Object value)方法。</p><p><strong>set(ThreadLocal key, Object value)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 采用“线性探测法”，寻找合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key 存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots 清楚陈旧的Entry（key == null）</span></span><br><span class="line">    <span class="comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; (sz &gt;= threshold)) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考散列冲突处理系列博客）。掌握了开放地址法该方法就一目了然了。</p><p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p><p><strong>getEntry()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> ((e != <span class="keyword">null</span>) &amp;&amp; (e.get() == key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><blockquote><p>返回当前线程所对应的线程变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocal</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取目标值         </span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p><p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h1><blockquote><p>设置当前线程的线程局部变量的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h1><blockquote><p>返回该线程局部变量的初始值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h1><blockquote><p>将当前线程局部变量的值删除。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p><h1 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h1><p>前面提到每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下（图片来自<a href="http://www.jianshu.com/p/ee8c9dccc953）：" target="_blank" rel="noopener">http://www.jianshu.com/p/ee8c9dccc953）：</a></p><p><img src="642.png" alt=""></p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</p><p>那么要怎么避免这个问题呢？</p><p>在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</p><p>下面再对ThreadLocal进行简单的总结：</p><blockquote><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLoacal是什么？&quot;&gt;&lt;a href=&quot;#ThreadLoacal是什么？&quot; class=&quot;headerlink&quot; title=&quot;ThreadLoacal是什么？&quot;&gt;&lt;/a&gt;ThreadLoacal是什么？&lt;/h1&gt;&lt;p&gt;ThreadLocal是啥？
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ThreadLocal" scheme="http://blog.shagle.cn/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock的实现原理</title>
    <link href="http://blog.shagle.cn/2019/02/25/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.shagle.cn/2019/02/25/Java技术之ReentrantReadWriteLock的实现原理/</id>
    <published>2019-02-25T02:42:29.000Z</published>
    <updated>2019-02-25T10:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><strong>ReentrantReadWriteLock支持以下功能：</strong></p><ul><li><p>1）支持公平和非公平的获取锁的方式；</p></li><li><p>2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p></li><li><p>3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</p></li><li><p>4）读取锁和写入锁都支持锁获取期间的中断；</p></li><li><p>5）Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </p></li></ul><h1 id="2-ReadWriteLock接口简单说明"><a href="#2-ReadWriteLock接口简单说明" class="headerlink" title="2. ReadWriteLock接口简单说明"></a>2. ReadWriteLock接口简单说明</h1><p>ReadWriteLock接口只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是Lock接口的实现，可以如同使用Lock接口一样使用（其实也有一些特性是不支持的）。</p><h1 id="3-ReentrantReadWriteLock使用示例"><a href="#3-ReentrantReadWriteLock使用示例" class="headerlink" title="3. ReentrantReadWriteLock使用示例"></a>3. ReentrantReadWriteLock使用示例</h1><p>读写锁的使用并不复杂，可以参考以下使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通重入锁使用的主要区别在于需要使用不同的锁对象引用读写锁，并且在读写时分别调用对应的锁。</p><h1 id="4-ReentrantReadWriteLock锁实现分析"><a href="#4-ReentrantReadWriteLock锁实现分析" class="headerlink" title="4. ReentrantReadWriteLock锁实现分析"></a>4. ReentrantReadWriteLock锁实现分析</h1><p>本节通过学习源码分析可重入读写锁的实现。</p><h2 id="4-1-图解重要函数及对象关系"><a href="#4-1-图解重要函数及对象关系" class="headerlink" title="4.1 图解重要函数及对象关系"></a>4.1 图解重要函数及对象关系</h2><p>根据示例代码可以发现，读写锁需要关注的重点函数为获取读锁及写锁的函数，对于读锁及写锁对象则主要关注加锁和解锁函数，这几个函数及对象关系如下图：<br><img src="3356096377-5b58800bcda35.png" alt=""></p><p>从图中可见读写锁的加锁解锁操作最终都是调用<code>ReentrantReadWriteLock</code>类的内部类<code>Sync</code>提供的方法。与<a href="Java技术之ReentrantLock的实现原理.md">Java技术之ReentrantLock的实现原理</a>一文中描述相似，<code>Sync</code>对象通过继承<code>AbstractQueuedSynchronizer</code>进行实现，故后续分析主要基于<code>Sync</code>类进行。</p><h2 id="4-2-读写锁Sync结构分析"><a href="#4-2-读写锁Sync结构分析" class="headerlink" title="4.2. 读写锁Sync结构分析"></a>4.2. 读写锁Sync结构分析</h2><p><code>Sync</code>继承于<code>AbstractQueuedSynchronizer</code>，其中主要功能均在<code>AbstractQueuedSynchronizer</code>中完成，其中最重要功能为控制线程获取锁失败后转换为等待状态及在满足一定条件后唤醒等待状态的线程。先对<code>AbstractQueuedSynchronizer</code>进行观察。</p><h3 id="4-2-1-AbstractQueuedSynchronizer图解"><a href="#4-2-1-AbstractQueuedSynchronizer图解" class="headerlink" title="4.2.1. AbstractQueuedSynchronizer图解"></a>4.2.1. AbstractQueuedSynchronizer图解</h3><p>为了更好理解<code>AbstractQueuedSynchronizer</code>的运行机制，可以首先研究其内部数据结构，如下图：</p><p><img src="3868270967-5b58800c21220.png" alt=""></p><p>图中展示AQS类较为重要的数据结构，包括<code>int</code>类型变量<code>state</code>用于记录锁的状态，继承自<code>AbstractOwnableSynchronizer</code>类的<code>Thread</code>类型变量<code>exclusiveOwnerThread</code>用于指向当前排他的获取锁的线程，<code>AbstractQueuedSynchronizer.Node</code>类型的变量<code>head</code>及<code>tail</code>。<br>其中<code>Node</code>对象表示当前等待锁的节点，<code>Node</code>中<code>thread</code>变量指向等待的线程，<code>waitStatus</code>表示当前等待节点状态，<code>mode</code>为节点类型。多个节点之间使用<code>prev</code>及<code>next</code>组成双向链表，参考CLH锁队列的方式进行锁的获取，但其中与CLH队列的重要区别在于CLH队列中后续节点需要自旋轮询前节点状态以确定前置节点是否已经释放锁，期间不释放CPU资源，而<code>AQS</code>中<code>Node</code>节点指向的线程在获取锁失败后调用<code>LockSupport.park</code>函数使其进入阻塞状态，让出CPU资源，故在前置节点释放锁时需要调用<code>unparkSuccessor</code>函数唤醒后继节点。<br><strong>根据以上说明可得知此上图图主要表现当前<code>thread0</code>线程获取了锁，<code>thread1</code>线程正在等待。</strong></p><h3 id="4-2-2-读写锁Sync对于AQS使用"><a href="#4-2-2-读写锁Sync对于AQS使用" class="headerlink" title="4.2.2. 读写锁Sync对于AQS使用"></a>4.2.2. 读写锁Sync对于AQS使用</h3><p>读写锁中<code>Sync</code>类是继承于<code>AQS</code>，并且主要使用上文介绍的数据结构中的<code>state</code>及<code>waitStatus</code>变量进行实现。<br>实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。<br><code>Sync</code>使用<code>state</code>变量同时记录读锁与写锁状态，将<code>int</code>类型的<code>state</code>变量分为高16位与第16位，高16位记录读锁状态，低16位记录写锁状态，如下图所示：</p><p><img src="3877233723-5b58800addacf.png" alt=""></p><p><code>Sync</code>使用不同的<code>mode</code>描述等待队列中的节点以区分读锁等待节点和写锁等待节点。<code>mode</code>取值包括<code>SHARED</code>及<code>EXCLUSIVE</code>两种，分别代表当前等待节点为读锁和写锁。</p><h2 id="4-3-读写锁Sync代码过程分析"><a href="#4-3-读写锁Sync代码过程分析" class="headerlink" title="4.3. 读写锁Sync代码过程分析"></a>4.3. 读写锁Sync代码过程分析</h2><h3 id="4-3-1-写锁加锁"><a href="#4-3-1-写锁加锁" class="headerlink" title="4.3.1. 写锁加锁"></a>4.3.1. 写锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquire</code>函数（继承自<code>AQS</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分情况图解分析</p><h4 id="4-3-1-1-无锁状态"><a href="#4-3-1-1-无锁状态" class="headerlink" title="4.3.1.1. 无锁状态"></a>4.3.1.1. 无锁状态</h4><p>无锁状态<code>AQS</code>内部数据结构如下图所示：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>其中<code>state</code>变量为0，表示高位地位地位均为0，没有任何锁，且等待节点的首尾均指向空（此处特指head节点没有初始化时），锁的所有者线程也为空。<br>在无锁状态进行加锁操作，线程调用<code>acquire</code>函数，首先使用<code>tryAcquire</code>函数判断锁是否可获取成功，由于当前是无锁状态必然成功获取锁（如果多个线程同时进入此函数，则有且只有一个线程可调用<code>compareAndSetState</code>成功，其他线程转入获取锁失败的流程）。获取锁成功后<code>AQS</code>状态为：</p><p><img src="1886151432-5b58800ad557b.png" alt=""></p><h4 id="4-3-1-2-有锁状态"><a href="#4-3-1-2-有锁状态" class="headerlink" title="4.3.1.2. 有锁状态"></a>4.3.1.2. 有锁状态</h4><p>在加写锁时如果当前<code>AQS</code>已经是有锁状态，则需要进一步处理。有锁状态主要分为已有写锁和已有读锁状态，并且根据最终当前线程是否可直接获取锁分为两种情况：</p><ul><li><ol><li>非重入：如果满足一下两个条件之一，当前线程必须加入等待队列（暂不考虑非公平锁抢占情况） <ul><li>a. 已有读锁；</li><li>b. 有写锁且获取写锁的线程不为当前请求锁的线程。</li></ul></li></ol></li><li><ol start="2"><li>重入：有写锁且当前获取写锁的线程与当前请求锁的线程为同一线程，则直接获取锁并将写锁状态值加1。</li></ol></li></ul><p>写锁重入状态如图：</p><p><img src="454804165-5b58800ae5824.png" alt=""></p><p>写锁非重入等待状态如图：</p><p><img src="3879161302-5b58800a41983.png" alt=""></p><p>在非重入状态，当前线程创建等待节点追加到等待队列队尾，如果当前头结点为空，则需要创建一个默认的头结点。<br>之后再当前获取锁的线程释放锁后，会唤醒等待中的节点，即为<code>thread1</code>。如果当前等待队列存在多个等待节点，由于<code>thread1</code>等待节点为<code>EXCLUSIVE</code>模式，则只会唤醒当前一个节点，不会传播唤醒信号。</p><h3 id="4-3-2-读锁加锁"><a href="#4-3-2-读锁加锁" class="headerlink" title="4.3.2. 读锁加锁"></a>4.3.2. 读锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquireShared</code>函数（继承自<code>AQS</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上文，现在分情况图解分析</p><h4 id="4-3-2-1-无锁状态"><a href="#4-3-2-1-无锁状态" class="headerlink" title="4.3.2.1. 无锁状态"></a>4.3.2.1. 无锁状态</h4><p>无所状态<code>AQS</code>内部数据状态图与写加锁是无锁状态一致：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>在无锁状态进行加锁操作，线程调用<code>acquireShared</code>函数，首先使用<code>tryAcquireShared</code>函数判断共享锁是否可获取成功，由于当前为无锁状态则获取锁一定成功（如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取，该函数在后文说明）。当前线程获取读锁成功后，<code>AQS</code>内部结构如图所示：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>其中有两个新的变量：<code>firstReader</code>及<code>firstReaderHoldCount</code>。<code>firstReader</code>指向在无锁状态下第一个获取读锁的线程，<code>firstReaderHoldCount</code>记录第一个获取读锁的线程持有当前锁的计数（主要用于重入）。</p><h4 id="4-3-2-2-有锁状态"><a href="#4-3-2-2-有锁状态" class="headerlink" title="4.3.2.2. 有锁状态"></a>4.3.2.2. 有锁状态</h4><p>无锁状态获取读锁比较简单，在有锁状态则需要分情况讨论。其中需要分当前被持有的锁是读锁还是写锁，并且每种情况需要区分等待队列中是否有等待节点。</p><p><strong>已有读锁且等待队列为空</strong><br>此状态比较简单，图示如：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>此时线程申请读锁，首先调用<code>readerShouldBlock</code>函数进行判断，该函数根据当前锁是否为公平锁判断规则稍有不同。如果为非公平锁，则只需要当前第一个等待节点不是写锁就可以尝试获取锁（考虑第一点为写锁主要为了方式写锁“饿死”）；如果是公平锁则只要有等待节点且当前锁不为重入就需要等待。<br>由于本节的前提是等待队列为空的情况，故<code>readerShouldBlock</code>函数一定返回<code>false</code>，则当前线程使用<code>CAS</code>对读锁计数进行增加（同上文，如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取）。<br>在成功对读锁计数器进行增加后，当前线程需要继续对当前线程持有读锁的计数进行增加。此时分为两种情况：</p><ul><li><ol><li>当前线程是第一个获取读锁的线程，此时由于第一个获取读锁的线程已经通过<code>firstReader</code>及<code>firstReaderHoldCount</code>两个变量进行存储，则仅仅需要将<code>firstReaderHoldCount</code>加1即可;</li></ol></li><li><ol start="2"><li>当前线程不是第一个获取读锁的线程，则需要使用<code>readHolds</code>进行存储，<code>readHolds</code>是<code>ThreadLoca</code>l的子类，通过<code>readHolds</code>可获取当前线程对应的<code>HoldCounter</code>类的对象，该对象保存了当前线程获取读锁的计数。考虑程序的局部性原理，又使用<code>cachedHoldCounter</code>缓存最近使用的<code>HoldCounter</code>类的对象，如在一段时间内只有一个线程请求读锁则可加速对读锁获取的计数。</li></ol></li></ul><p>第一个读锁线程重入如图：</p><p><img src="1282819964-5b5880089f6c9.png" alt=""></p><p>非首节点获取读锁</p><p><img src="2489231474-5b5880083f137.png" alt=""></p><p>根据上图所示，<code>thread0</code>为首节点，<code>thread1</code>线程继续申请读锁，获取成功后使用<code>ThreadLocal</code>链接的方式进行存储计数对象，并且由于其为最近获取读锁的线程，则<code>cachedHoldCounter</code>对象设置指向<code>thread1</code>对应的计数对象。</p><p><strong>已有读锁且等待队列不为空</strong></p><p>在当前锁已经被读锁获取，且等待队列不为空的情况下 ，可知等待队列的头结点一定为<strong>写锁获取等待</strong>，这是由于在读写锁实现过程中，如果某线程获取了读锁，则会唤醒当前等到节点之后的所有等待模式为<code>SHARED</code>的节点，直到队尾或遇到<code>EXCLUSIVE</code>模式的等待节点（具体实现函数为<code>setHeadAndPropagate</code>后续还会遇到）。所以可以确定当前为读锁状态其有等待节点情况下，首节点一定是写锁等待。如图所示：</p><p><img src="790767399-5b58800924c87.png" alt=""></p><p>上图展示当前<code>thread0</code>与<code>thread1</code>线程获取读锁，<code>thread0</code>为首个获取读锁的节点，并且<code>thread2</code>线程在等待获取写锁。<br>在上图显示的状态下，无论公平锁还是非公平锁的实现，新的读锁加锁一定会进行排队，添加等待节点在写锁等待节点之后，这样可以防止写操作的饿死。申请读锁后的状态如图所示：</p><p><img src="3433646749-5b58800a4cd7a.png" alt=""></p><p>如图所示，在当前锁被为读锁且有等待队列情况下，<code>thread3</code>及<code>thread4</code>线程申请读锁，则被封装为等待节点追加到当前等待队列后，节点模式为<code>SHARED</code>，线程使用<code>LockSupport.park</code>函数进入阻塞状态，让出CPU资源，直到前驱的等待节点完成锁的获取和释放后进行唤醒。</p><p><strong>已有写锁被获取</strong></p><p>当前线程申请读锁时发现写锁已经被获取，则无论等待队列是否为空，线程一定会需要加入等待队列（注意在非公平锁实现且前序没有写锁申请的等待，线程有机会抢占获取锁而不进入等待队列）。写锁被获取的情况下，<code>AQS</code>状态为如下状态</p><p><img src="3131560188-5b588009a8253.png" alt=""></p><p>在两种情况下，读锁获取都会进入等待队列等待前序节点唤醒，这里不再赘述。</p><h4 id="4-3-2-3-读锁加锁读等待节点被唤醒"><a href="#4-3-2-3-读锁加锁读等待节点被唤醒" class="headerlink" title="4.3.2.3. 读锁加锁读等待节点被唤醒"></a>4.3.2.3. 读锁加锁读等待节点被唤醒</h4><p>读写锁与单纯的排他锁主要区别在于读锁的共享性，在读写锁实现中保证读锁能够共享的其中一个机制就在于，如果一个读锁等待节点被唤醒后其会继续唤醒拍在当前唤醒节点之后的<code>SHARED</code>模式等待节点。查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">   <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">           <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">               <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">               <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//注意看这里</span></span><br><span class="line">                   setHeadAndPropagate(node, r);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   <span class="keyword">if</span> (interrupted)</span><br><span class="line">                       selfInterrupt();</span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">               parkAndCheckInterrupt())</span><br><span class="line">               interrupted = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (failed)</span><br><span class="line">           cancelAcquire(node);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，线程如果获取读锁成功后，需要调用<code>setHeadAndPropagate</code>方法。查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">   Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">   setHead(node);</span><br><span class="line">   <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">       (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">           doReleaseShared();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在满足传播条件情况下，获取读锁后继续唤醒后续节点，所以如果当前锁是读锁状态则等待节点第一个节点一定是写锁等待节点。</p><h4 id="4-3-2-4-锁降级"><a href="#4-3-2-4-锁降级" class="headerlink" title="4.3.2.4. 锁降级"></a>4.3.2.4. 锁降级</h4><p>锁降级算是获取读锁的特例，如在<code>t0</code>线程已经获取写锁的情况下，再调取读锁加锁函数则可以直接获取读锁，但此时其他线程仍然无法获取读锁或写锁，在<code>t0</code>线程释放写锁后，如果有节点等待则会唤醒后续节点，后续节点可见的状态为目前有t0线程获取了读锁。<br>所降级有什么应用场景呢？引用读写锁中使用示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中针对变量<code>cacheValid</code>的使用主要过程为加读锁、读取、释放读锁、加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁。其中后续几步（加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁）为典型的锁降级。如果不使用锁降级，则过程可能有三种情况：</p><ul><li>第一种：加写锁、修改值、释放写锁、使用数据，即使用写锁修改数据后直接使用刚修改的数据，这样可能有数据的不一致，如当前线程释放写锁的同时其他线程（如<code>t0</code>）获取写锁准备修改（还没有改）<code>cacheValid</code>变量，而当前线程却继续运行，则当前线程读到的<code>cacheValid</code>变量的值为<code>t0</code>修改前的老数据；</li><li>第二种：加写锁、修改值、使用数据、释放写锁，即将修改数据与再次使用数据合二为一，这样不会有数据的不一致，但是由于混用了读写两个过程，以排它锁的方式使用读写锁，减弱了读写锁读共享的优势，增加了写锁（独占锁）的占用时间；</li><li>第三种：加写锁、修改值、释放写锁、加读锁、使用数据、释放读锁，即使用写锁修改数据后再请求读锁来使用数据，这是时数据的一致性是可以得到保证的，但是由于释放写锁和获取读锁之间存在时间差，则当前想成可能会需要进入等待队列进行等待，可能造成线程的阻塞降低吞吐量。</li></ul><p>因此针对以上情况提供了锁的降级功能，可以在完成数据修改后尽快读取最新的值，且能够减少写锁占用时间。</p><p>最后注意，读写锁<strong>不支持锁升级</strong>，即获取读锁、读数据、获取写锁、释放读锁、释放写锁这个过程，因为读锁为共享锁，如同时有多个线程获取了读锁后有一个线程进行锁升级获取了写锁，这会造成同时有读锁（其他线程）和写锁的情况，造成其他线程可能无法感知新修改的数据（此为逻辑性错误），并且在JAVA读写锁实现上由于当前线程获取了读锁，再次请求写锁时必然会阻塞而导致后续释放读锁的方法无法执行，这回造成死锁（此为功能性错误）。</p><h3 id="4-3-3-写锁释放锁过程"><a href="#4-3-3-写锁释放锁过程" class="headerlink" title="4.3.3. 写锁释放锁过程"></a>4.3.3. 写锁释放锁过程</h3><p>了解了加锁过程后解锁过程就非常简单，每次调用解锁方法都会减少重入计数次数，直到减为0则唤醒后续第一个等待节点，如唤醒的后续节点为读等待节点，则后续节点会继续传播唤醒状态。</p><h3 id="4-3-4-读锁释放过程"><a href="#4-3-4-读锁释放过程" class="headerlink" title="4.3.4. 读锁释放过程"></a>4.3.4. 读锁释放过程</h3><p>读锁释放过比写锁稍微复杂，因为是共享锁，所以可能会有多个线程同时获取读锁，故在解锁时需要做两件事：</p><ul><li><ol><li>获取当前线程对应的重入计数，并进行减1，此处天生为线程安全的，不需要特殊处理；</li></ol></li><li><ol start="2"><li>当前读锁获取次数减1，此处由于可能存在多线程竞争，故使用自旋CAS进行设置。<br>完成以上两步后，如读状态为0，则唤醒后续等待节点。</li></ol></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>根据以上分析，本文主要展示了读写锁的场景及方式，并分析读写锁核心功能（加解锁）的代码实现。Java读写锁同时附带了更多其他方法，包括锁状态监控和带超时机制的加锁方法等，本文不在赘述。并且读写锁中写锁可使用Conditon机制也不在详细说明。</p><p><a href="https://segmentfault.com/a/1190000015768003#articleHeader3" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ThreadLocal的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8BThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之ThreadLocal的使用/</id>
    <published>2019-02-21T09:21:01.000Z</published>
    <updated>2019-02-21T09:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类ThreadLocal的使用"><a href="#1-类ThreadLocal的使用" class="headerlink" title="1. 类ThreadLocal的使用"></a>1. 类ThreadLocal的使用</h1><p>变量值的共享可以使用<code>public static</code>变量的形式，所有的线程都使用同一个<code>public static</code>变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的类<code>ThreadLocal</code>正是为了解决这样的问题。<br>类<code>ThreadLocal</code>主要解决的就是每个线程绑定自己的值，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><h1 id="2-解决get（）返回null问题"><a href="#2-解决get（）返回null问题" class="headerlink" title="2. 解决get（）返回null问题"></a>2. 解决get（）返回null问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是默认值 第一次get不再为null"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖initialValue（）方法具有初始值。</p><h1 id="3-类InheritableThreadLocal的使用"><a href="#3-类InheritableThreadLocal的使用" class="headerlink" title="3. 类InheritableThreadLocal的使用"></a>3. 类InheritableThreadLocal的使用</h1><p>使用类<code>InheritableThreadLocal</code>可以在子线程中取得父线程继承下来的值。</p><h2 id="3-1-值继承"><a href="#3-1-值继承" class="headerlink" title="3.1 值继承"></a>3.1 值继承</h2><p>使用InheritableThreadLocal类可以让子线程从父线程中取得值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Tools.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tools;</span><br><span class="line"><span class="keyword">import</span> ext.InheritableThreadLocalExt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocalExt tl = <span class="keyword">new</span> InheritableThreadLocalExt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadA.java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"在ThreadA线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"       在Main线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-64所示。</p><p><img src="20190221172614.png" alt=""></p><h1 id="3-2-值继承再修改"><a href="#3-2-值继承再修改" class="headerlink" title="3.2 值继承再修改"></a>3.2 值继承再修改</h1><p>如果在继承的同时还可以对值进行进一步的处理那就更好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">childValue</span><span class="params">(Object parentValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> parentValue + <span class="string">" 我在子线程加的~!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-65所示。</p><p><img src="20190221173005.png" alt=""></p><p>但在使用InheritableThreadLocal类需要注意一点的是，如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的值还是旧值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-类ThreadLocal的使用&quot;&gt;&lt;a href=&quot;#1-类ThreadLocal的使用&quot; class=&quot;headerlink&quot; title=&quot;1. 类ThreadLocal的使用&quot;&gt;&lt;/a&gt;1. 类ThreadLocal的使用&lt;/h1&gt;&lt;p&gt;变量值的共享可以
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="threadLocal" scheme="http://blog.shagle.cn/tags/threadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之join的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8Bjoin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之join的使用/</id>
    <published>2019-02-21T06:28:50.000Z</published>
    <updated>2019-02-21T08:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销毁。</p><h1 id="1-学习方法join前的铺垫"><a href="#1-学习方法join前的铺垫" class="headerlink" title="1. 学习方法join前的铺垫"></a>1. 学习方法join前的铺垫</h1><p>在介绍join方法之前，先来看一个实验。<br>创建测试用的java项目，名称为joinTest1，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">    threadTest.start();</span><br><span class="line">    <span class="comment">// Thread.sleep(?)</span></span><br><span class="line">    System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行"</span>);</span><br><span class="line">    System.out.println(<span class="string">"但上面代码中的sleep()中的值应该写多少呢？"</span>);</span><br><span class="line">    System.out.println(<span class="string">"答案是：根据不能确定:)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-44所示。</p><p><img src="20190221150830.png" alt=""></p><h1 id="2-20190221150830-png"><a href="#2-20190221150830-png" class="headerlink" title="2. 20190221150830.png"></a>2. 20190221150830.png</h1><p>方法join可以解决这个问题。新建java项目joinTest2，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">      threadTest.start();</span><br><span class="line">      threadTest.join();</span><br><span class="line">      System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行，我做到了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的结果如图3-45所示。</p><p><img src="20190221152636.png" alt=""></p><p>方法join的作用是使所属的线程对象x正常执行run（）方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。</p><p>方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait（）方法进行等待，而sychronized关键字使用的是“对象监视器”原理做为同步</p><h1 id="3-方法join与异常"><a href="#3-方法join与异常" class="headerlink" title="3. 方法join与异常"></a>3. 方法join与异常</h1><p>在join过程中，如果当前线程对象被中断，则当前线程出现异常。<br>创建测试用的项目joinException，类ThreadA.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">      String newString = <span class="keyword">new</span> String();</span><br><span class="line">      Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadB.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">      a.join();</span><br><span class="line">      System.out.println(<span class="string">"线程B在run end处打印了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"线程B在catch处打印了"</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadC.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadB threadB;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(ThreadB threadB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.threadB = threadB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadB.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.run;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadC;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">      b.start();</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      ThreadC c = <span class="keyword">new</span> ThreadC(b);</span><br><span class="line">      c.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-46所示。</p><p><img src="20190221154515.png" alt=""></p><p>说明方法join（）与interrupt（）方法如果彼此遇到，则会出现异常。但进程按钮还呈“红色”，原因是线程ThreadA还在继续运行，线程ThreadA并未出现异常，是正常执行的状态。</p><p>方法join（long）中的参数是设定等待的时间。</p><h1 id="4-方法join（long）与sleep（long）的区别"><a href="#4-方法join（long）与sleep（long）的区别" class="headerlink" title="4. 方法join（long）与sleep（long）的区别"></a>4. 方法join（long）与sleep（long）的区别</h1><p>方法join（long）的功能在内部是使用wait（long）方法来实现的，所以join（long）方法具有释放锁的特点。<br>方法join（long）源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码中可以了解到，当执行wait（long）方法后，当前线程的锁被释放，那么其他线程就可以调用此线程中的同步方法了。<br>Thread.sleep（long）方法不释放锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="join" scheme="http://blog.shagle.cn/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之线程通信</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之线程通信/</id>
    <published>2019-02-21T06:04:00.000Z</published>
    <updated>2019-02-21T06:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通过管道进行线程间通信：字节流"><a href="#1-通过管道进行线程间通信：字节流" class="headerlink" title="1. 通过管道进行线程间通信：字节流"></a>1. 通过管道进行线程间通信：字节流</h1><p>在Java语言中提供了各种各样的输入/输出流Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream）是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西。<br>在Java的JDK中提供了4个类来使线程间可以进行通信：</p><ul><li>1）PipedInputStream和PipedOutputStream</li><li>2）PipedReader和PipedWriter<br>创建测试用的项目pipeInputOutput。<br>类WriteData.java代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData.getBytes());</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-37所示：</p><p><img src="20190221140600.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">      PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码inputStream.connect（outputStream）或outputStream.connect（inputStream）的作用使两个Stream之间产生通信链接，这样才可以将数据进行输出与输入。<br>程序运行结果如图3-38所示：</p><p><img src="20190221140753.png" alt=""></p><h1 id="2-通过管道进行线程间通信：字符流"><a href="#2-通过管道进行线程间通信：字符流" class="headerlink" title="2. 通过管道进行线程间通信：字符流"></a>2. 通过管道进行线程间通信：字符流</h1><p>当然，在管道中还可以传递字符流。<br>创建测试用的项目pipeReaderWriter。</p><p>类WriteData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedWriter out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData);</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedReader input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">char</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-39所示：</p><p><img src="20190221141249.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedReader inputStream = <span class="keyword">new</span> PipedReader();</span><br><span class="line">      PipedWriter outputStream = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-40所示：</p><p><img src="20190221141423.png" alt=""></p><p>打印的结果和前一个示例基本一样，此实验是在两个线程中通过管道流进行字符数据的传输。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-通过管道进行线程间通信：字节流&quot;&gt;&lt;a href=&quot;#1-通过管道进行线程间通信：字节流&quot; class=&quot;headerlink&quot; title=&quot;1. 通过管道进行线程间通信：字节流&quot;&gt;&lt;/a&gt;1. 通过管道进行线程间通信：字节流&lt;/h1&gt;&lt;p&gt;在Java语言中
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="线程通信" scheme="http://blog.shagle.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://blog.shagle.cn/2019/01/31/jvm/"/>
    <id>http://blog.shagle.cn/2019/01/31/jvm/</id>
    <published>2019-01-31T05:45:53.000Z</published>
    <updated>2019-02-01T03:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li>在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的</li><li>提供了更大的灵活性，增加了更多的可能性</li><li>Java虚拟机与程序的生命周期</li><li>在如下几种情况下，java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致java虚拟机进程终止 </li></ul></li></ul><h1 id="类的加载，连接与初始化"><a href="#类的加载，连接与初始化" class="headerlink" title="类的加载，连接与初始化"></a>类的加载，连接与初始化</h1><ul><li>加载：查找并加载类的二进制数据</li><li>连接<ul><li>-验证：确保被加载的类的正确性</li><li>-准备：为类的<code>静态变量</code>分配内存，并将其初始化为<code>默认值</code></li><li>-解析：<code>把类中的符号引用转换为直接引用</code></li></ul></li><li><code>初始化：为类的静态变量赋予正确的初始值</code></li><li>使用</li><li>卸载</li><li>Java程序对类的使用方式可以分为两种<ul><li>-主动使用(七种)<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.tet.Test””))</li><li>初始化一个类的子类</li><li>java虚拟机启动时被标明为类的类(java test)</li><li>JDK 1.7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化</li></ul></li><li>-被动使用</li></ul></li><li>所有的Java虚拟机实现必须在每个类或接口被Java程序<code>首次主动使用</code>时才初始化他们</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的&lt;/
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jvm" scheme="http://blog.shagle.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>理解Callable 和 Spring DeferredResult（翻译）</title>
    <link href="http://blog.shagle.cn/2019/01/28/SpringMVC%E5%BC%82%E6%AD%A5/"/>
    <id>http://blog.shagle.cn/2019/01/28/SpringMVC异步/</id>
    <published>2019-01-28T02:37:00.000Z</published>
    <updated>2019-01-28T07:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1-介绍"></a>1-介绍</h1><p>Servlet 3中的异步支持为在另一个线程中处理HTTP请求提供了可能性。当有一个长时间运行的任务时，这是特别有趣的，因为当另一个线程处理这个请求时，容器线程被释放，并且可以继续为其他请求服务。<br>这个主题已经解释了很多次，Spring框架提供的关于这个功能的类似乎有一点混乱——在一个Controller中返回Callable 和 DeferredResult。<br>在这篇文章中，我将实施这两个例子，以显示其差异。<br>这里所显示的所有示例都包括执行一个控制器，该控制器将执行一个长期运行的任务，然后将结果返回给客户机。长时间运行的任务由taskservice处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(<span class="string">"Slow task executed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Task finished"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个web应用是用Spring Boot创建的，我们将执行下面的类来运行我们的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-阻塞的Controller"><a href="#2-阻塞的Controller" class="headerlink" title="2-阻塞的Controller"></a>2-阻塞的Controller</h1><p>在这个例子中，一个请求到达控制器。servlet线程不会被释放，直到长时间运行的方法被执行，我们退出<code>@requestmapping</code>注释的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/block"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        String result = taskService.execute();</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们运行这个例子<a href="http://localhost:8080/block，在日志里我们会发现servlet" target="_blank" rel="noopener">http://localhost:8080/block，在日志里我们会发现servlet</a> request不会被释放，直到长时间的任务执行完（5秒后）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 12:41:11.849  [nio-8080-exec-6] x.s.web.controller.BlockingController    : Request received</span><br><span class="line">2015-07-12 12:41:16.851  [nio-8080-exec-6] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br><span class="line">2015-07-12 12:41:16.851  [nio-8080-exec-6] x.s.web.controller.BlockingController    : Servlet thread released</span><br></pre></td></tr></table></figure><h1 id="3-返回Callable"><a href="#3-返回Callable" class="headerlink" title="3-返回Callable"></a>3-返回Callable</h1><p>在这个例子中，不是直接返回的结果，我们将返回一个Callable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallableController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncCallableController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/callable"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        Callable&lt;String&gt; callable = taskService::execute;</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> callable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回Callable意味着Spring MVC将调用在不同的线程中执行定义的任务。Spring将使用TaskExecutor来管理线程。在等待完成的长期任务之前，servlet线程将被释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 13:07:07.012  [nio-8080-exec-5] x.s.w.c.AsyncCallableController          : Request received</span><br><span class="line">2015-07-12 13:07:07.013  [nio-8080-exec-5] x.s.w.c.AsyncCallableController          : Servlet thread released</span><br><span class="line">2015-07-12 13:07:12.014  [      MvcAsync2] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br></pre></td></tr></table></figure><p>你可以看到我们在长时间运行的任务执行完毕之前就已经从servlet返回了。这并不意味着客户端收到了一个响应。与客户端的通信仍然是开放的等待结果，但接收到的请求的线程已被释放，并可以服务于另一个客户的请求。</p><h1 id="4-返回DeferredResult"><a href="#4-返回DeferredResult" class="headerlink" title="4-返回DeferredResult"></a>4-返回DeferredResult</h1><p>首先，我们需要创建一个deferredresult对象。此对象将由控制器返回。我们将完成和Callable相同的事，当我们在另一个线程处理长时间运行的任务的时候释放servlet线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDeferredController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncDeferredController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/deferred"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">        CompletableFuture.supplyAsync(taskService::execute)</span><br><span class="line">            .whenCompleteAsync((result, throwable) -&gt; deferredResult.setResult(result));</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，返回DeferredResult和返回Callable有什么区别？不同的是这一次线程是由我们管理。创建一个线程并将结果set到DeferredResult是由我们自己来做的。<br>用completablefuture创建一个异步任务。这将创建一个新的线程，在那里我们的长时间运行的任务将被执行。也就是在这个线程中，我们将set结果到DeferredResult并返回。<br>是在哪个线程池中我们取回这个新的线程？默认情况下，在completablefuture的supplyasync方法将在forkjoin池运行任务。如果你想使用一个不同的线程池，你可以通过传一个executor到supplyasync方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>如果我们运行这个例子，我们将得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 13:28:08.433  [io-8080-exec-10] x.s.w.c.AsyncDeferredController          : Request received</span><br><span class="line">2015-07-12 13:28:08.475  [io-8080-exec-10] x.s.w.c.AsyncDeferredController          : Servlet thread released</span><br><span class="line">2015-07-12 13:28:13.469  [onPool-worker-1] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br></pre></td></tr></table></figure><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5-结论"></a>5-结论</h1><p><strong>以下是Servlet异步请求处理的简要概述：</strong></p><ul><li><p>A ServletRequest可以通过调用置于异步模式request.startAsync()。这样做的主要作用是Servlet（以及任何过滤器）可以退出，但响应保持打开状态以便稍后处理完成。</p></li><li><p>对request.startAsync()返回的调用AsyncContext，可用于进一步控制异步处理。例如，它提供的dispatch方法类似于Servlet API的转发，但它允许应用程序在Servlet容器线程上恢复请求处理。</p></li><li><p>在ServletRequest提供对电流DispatcherType，它可以使用处理该初始请求，异步调度，正向，以及其他的调度类型之间进行区分。</p></li></ul><p><strong>DeferredResult 处理工作如下：</strong></p><ul><li><p>控制器返回a DeferredResult并将其保存在可以访问它的某个内存中队列或列表中。</p></li><li><p>Spring MVC调用request.startAsync()。</p></li><li><p>同时，DispatcherServlet所有已配置的过滤器都会退出请求处理线程，但响应仍保持打开状态。</p></li><li><p>应用程序DeferredResult从某个线程设置，Spring MVC将请求调度回Servlet容器。</p></li><li><p>将DispatcherServlet被再次调用，并且处理与异步生产返回值恢复。</p></li></ul><p><strong>Callable 处理工作如下：</strong></p><ul><li><p>控制器返回一个Callable。</p></li><li><p>Spring MVC调用request.startAsync()并将其提交Callable到a TaskExecutor以在单独的线程中进行处理。</p></li><li><p>同时，DispatcherServlet所有过滤器都退出Servlet容器线程，但响应仍保持打开状态。</p></li><li><p>最终Callable产生一个结果，Spring MVC将请求发送回Servlet容器以完成处理。</p></li><li><p>将DispatcherServlet被再次调用，并且处理从所述异步生产返回值恢复Callable。</p></li></ul><p><a href="https://docs.spring.io/spring/docs/5.1.4.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">官方文档</a></p><p>站在一定高度来看这问题，Callable和Deferredresult做的是同样的事情——释放容器线程，在另一个线程上异步运行长时间的任务。不同的是谁管理执行任务的线程。</p><p>文中涉及的代码<a href="https://github.com/aheizi/spring-rest" target="_blank" rel="noopener">spring-rest</a></p><p>翻译自<a href="https://xpadro.com/?blogger=http://xpadro.blogspot.com/2015/07/understanding-callable-and-spring.html" target="_blank" rel="noopener">Xavier Padró’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1-介绍&quot;&gt;&lt;/a&gt;1-介绍&lt;/h1&gt;&lt;p&gt;Servlet 3中的异步支持为在另一个线程中处理HTTP请求提供了可能性。当有一个长时间运行的任务时，这是特别有趣的，因为
      
    
    </summary>
    
      <category term="Spring MVC" scheme="http://blog.shagle.cn/categories/Spring-MVC/"/>
    
    
      <category term="异步controller" scheme="http://blog.shagle.cn/tags/%E5%BC%82%E6%AD%A5controller/"/>
    
  </entry>
  
  <entry>
    <title>springMVC与servlet3整合分析</title>
    <link href="http://blog.shagle.cn/2019/01/27/springMVC-servlet3/"/>
    <id>http://blog.shagle.cn/2019/01/27/springMVC-servlet3/</id>
    <published>2019-01-27T08:13:31.000Z</published>
    <updated>2019-01-28T05:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Tomcat对Servlet规范的支持说明</a><br><a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr315/index.html" target="_blank" rel="noopener">Servlet 3.0标准的官方说明文件</a></p><h1 id="一、Servlet3-0"><a href="#一、Servlet3-0" class="headerlink" title="一、Servlet3.0"></a>一、Servlet3.0</h1><p>我们可以知道，Servlet 3.0提供了两个非常重要的功能：<br>Shared libraries（共享库） / runtimes pluggability（运行时插件能力）</p><p>我们总结为以下两点：</p><p><strong>第一点：</strong><br>Servlet容器启动会扫描当前应用里面每一个jar包的ServletContainerInitializer的实现</p><p><strong>第二点：</strong><br>ServletContainerInitializer的实现类，必须要绑定到META-INF/services/javax.servlet.ServletContainerInitializer文件中。并且该文件中的内容就是ServletContainerInitializer实现类的全类名。</p><p><strong>总结</strong>：容器在启动应用的时候，会扫描当前应用每一个jar包里面META-INF/services/javax.servlet.ServletContainerInitializer，指定的实现类，启动并运行这个实现类的方法；利用@HandlesTypes传入感兴趣的类型；</p><p>Demo示例：</p><ol><li>创建web项目后（要选择3.0），在src目录下创建META-INF/services/并新建文件：javax.servlet.ServletContainerInitializer</li><li>新建HelloService接口，HelloService接口的实现类HelloServiceImpl、实现了HelloService的抽象类AbstractHelloService、实现了HelloService的接口HelloServiceExt。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelloService</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloServiceExt</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>新建ServletContainerInitializer实现类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器启动的时候会将@HandlesTypes指定的这个类型下面的子类（实现类，子接口等）传递过来；</span></span><br><span class="line"><span class="comment">//传入感兴趣的类型；</span></span><br><span class="line"><span class="meta">@HandlesTypes</span>(value=&#123;HelloService.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用启动的时候，会运行onStartup方法；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Set&lt;Class&lt;?&gt;&gt; arg0：感兴趣的类型的所有子类型；</span></span><br><span class="line"><span class="comment"> * ServletContext arg1:代表当前Web应用的ServletContext；一个Web应用一个ServletContext；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1）、使用ServletContext注册Web组件（Servlet、Filter、Listener）（可以导入第三方组件）</span></span><br><span class="line"><span class="comment"> * 2）、使用编码的方式，在项目启动的时候给ServletContext里面添加组件；</span></span><br><span class="line"><span class="comment"> * 必须在项目启动的时候来添加；</span></span><br><span class="line"><span class="comment"> * 1）、ServletContainerInitializer得到的ServletContext；</span></span><br><span class="line"><span class="comment"> * 2）、ServletContextListener得到的ServletContext；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; arg0, ServletContext sc)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"感兴趣的类型："</span>);</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; claz : arg0) &#123;</span><br><span class="line">System.out.println(claz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册组件  ServletRegistration  </span></span><br><span class="line">ServletRegistration.Dynamic servlet = sc.addServlet(<span class="string">"userServlet"</span>, <span class="keyword">new</span> UserServlet());</span><br><span class="line"><span class="comment">//配置servlet的映射信息</span></span><br><span class="line">servlet.addMapping(<span class="string">"/user"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册Listener</span></span><br><span class="line">sc.addListener(UserListener.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册Filter  FilterRegistration</span></span><br><span class="line">FilterRegistration.Dynamic filter = sc.addFilter(<span class="string">"userFilter"</span>, UserFilter.class);</span><br><span class="line"><span class="comment">//配置Filter的映射信息</span></span><br><span class="line">filter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), <span class="keyword">true</span>, <span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">感兴趣的类型：</span><br><span class="line">class com.my.spring.annotation.service.AbstractHelloService</span><br><span class="line">interface com.my.spring.annotation.service.HelloServiceExt</span><br><span class="line">class com.my.spring.annotation.service.HelloServiceImpl</span><br><span class="line">UserListener...contextInitialized...</span><br><span class="line">......</span><br><span class="line">UserFilter...doFilter...</span><br><span class="line">UserFilter...doFilter...</span><br></pre></td></tr></table></figure><p>Stop服务器后可以监听到，控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息: Stopping service Catalina</span><br><span class="line">UserListener...contextDestroyed...</span><br></pre></td></tr></table></figure><h1 id="二、Servelet3-0与SpringMVC整合分析"><a href="#二、Servelet3-0与SpringMVC整合分析" class="headerlink" title="二、Servelet3.0与SpringMVC整合分析"></a>二、Servelet3.0与SpringMVC整合分析</h1><p><strong>利用注解进行整合时，主要解决的问题是：原来在web.xml中初始化的组件如何在注解版本加载。</strong></p><p>这是下面讲解的主线，一定要抓住这个问题往下看，否则，看着看着很容易找不着北，甚至不知道在干什么。</p><h2 id="1-创建Maven项目，并导入依赖"><a href="#1-创建Maven项目，并导入依赖" class="headerlink" title="1. 创建Maven项目，并导入依赖"></a>1. 创建Maven项目，并导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my.springmvc.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>02-SpringmvcAnnotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webVersion</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">webVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0-alpha-1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-应用启动说明"><a href="#2-应用启动说明" class="headerlink" title="2. 应用启动说明"></a>2. 应用启动说明</h2><p>可以打开依赖包spring-web-xxx.RELEASE.jar下的META-INF/services/javax.servlet.ServletContainerInitializer看一下</p><ol><li><p>web容器在启动的时候，会扫描每个jar包下的META-INF/services/javax.servlet.ServletContainerInitializer</p></li><li><p>加载这个文件指定的类SpringServletContainerInitializer</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes</span>(WebApplicationInitializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line"><span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span><br><span class="line"><span class="comment">// no matter what @HandlesTypes says...</span></span><br><span class="line"><span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">servletContext.log(<span class="string">"No Spring WebApplicationInitializer types detected on classpath"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">servletContext.log(initializers.size() + <span class="string">" Spring WebApplicationInitializers detected on classpath"</span>);</span><br><span class="line">AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line"><span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>spring的应用一启动会加载感兴趣的WebApplicationInitializer接口的下的所有组件；</p></li><li><p>并且为WebApplicationInitializer组件创建对象（组件不是接口，不是抽象类）<br>WebApplicationInitializer有三层抽象类：<br>(1) AbstractContextLoaderInitializer：创建根容器；createRootApplicationContext()；<br>(2) AbstractDispatcherServletInitializer：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个web的ioc容器；createServletApplicationContext();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建了DispatcherServlet；createDispatcherServlet()；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将创建的DispatcherServlet添加到ServletContext中；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getServletMappings();<br>(3) AbstractAnnotationConfigDispatcherServletInitializer：注解方式配置的DispatcherServlet初始化器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个抽象方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建根容器：createRootApplicationContext()，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getRootConfigClasses();传入一个配置类<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建web的ioc容器： createServletApplicationContext();，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取配置类；getServletConfigClasses();// 留给用户自定义实现</p></li></ol><p><strong>Servlet 3.0与SpringMVC整合原理总结：</strong></p><p>以注解方式来启动SpringMVC；只需要继承AbstractAnnotationConfigDispatcherServletInitializer；，并且要实现抽象方法指定DispatcherServlet的配置信息。（会自动将创建的DispatcherServlet添加到ServletContext中；）</p><h1 id="三、Servelet3-0与SpringMVC整合"><a href="#三、Servelet3-0与SpringMVC整合" class="headerlink" title="三、Servelet3.0与SpringMVC整合"></a>三、Servelet3.0与SpringMVC整合</h1><p><a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">Spring官方推荐，两个父子容器的形式：</a></p><p><img src="20190123164923346.png" alt=""></p><ul><li><p>Servlet WebApplicationContext<br>WEB容器，只来扫描Controller、resolvers等与Web组件相关的组件。</p></li><li><p>Root WebApplicationContext<br>根容器，只来扫描业务逻辑组件。</p></li></ul><p>Coding：</p><ol><li>新建AbstractAnnotationConfigDispatcherServletInitializer 的子类 MyWebAppInitializer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.config.RootConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web容器启动的时候创建对象；调用方法来初始化容器以及前端控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根容器的配置类（就类似于Spring的配置文件，以前是利用监听器方式读取配置文件）创建父容器；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取web容器的配置类（相当于以前的SpringMVC配置文件）创建 子容器；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;AppConfig.class&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取DispatcherServlet的映射信息</span></span><br><span class="line"><span class="comment">//  /：拦截所有请求（包括静态资源（xx.js,xx.png）），但是不包括*.jsp；</span></span><br><span class="line"><span class="comment">//  /*：拦截所有请求；连*.jsp页面都拦截；jsp页面是tomcat的jsp引擎解析的；所以，不要写成/*</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建根容器(父容器)和子容器的配置类：RootConfig和AppConfig</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan.Filter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring的容器不扫描controller;父容器(根容器)</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,excludeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan.Filter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewResolverRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.controller.MyFirstInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringMVC只扫描Controller；子容器</span></span><br><span class="line"><span class="comment">//只扫描就必须加useDefaultFilters=false 禁用默认的过滤规则；(排除扫描是不用加的)</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,includeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//默认所有的页面都从 /WEB-INF/ xxx .jsp</span></span><br><span class="line"><span class="comment">//registry.jsp();</span></span><br><span class="line">registry.jsp(<span class="string">"/WEB-INF/views/"</span>, <span class="string">".jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源访问</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> MyFirstInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试用到的Controller：HelloController</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.service.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HelloService helloService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">String hello = helloService.sayHello(<span class="string">"tomcat.."</span>);</span><br><span class="line"><span class="keyword">return</span> hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  /WEB-INF/views/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/suc"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试用的Service：HelloService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello "</span>+name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行测试</li></ol><h1 id="四、定制与接管SpringMVC"><a href="#四、定制与接管SpringMVC" class="headerlink" title="四、定制与接管SpringMVC"></a>四、定制与接管SpringMVC</h1><p>原来会将所有的配置定义在web.xml文件中，如果用注解定制与接管SpringMVC则分两步：</p><ol><li>@EnableWebMvc:开启SpringMVC定制配置功能；<br>可以加到配置类上。@EnableWebMvc相当于在web.xml中“&lt; mvc:annotation-driven /&gt;”<br>官网上的原版解释如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.11</span>.1. Enable MVC Config</span><br><span class="line">Same in Spring WebFlux</span><br><span class="line"></span><br><span class="line">In Java config use the <span class="meta">@EnableWebMvc</span> annotation:</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">In XML use the &lt;mvc:annotation-driven&gt; element:</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">The above registers a number of Spring MVC infrastructure beans also adapting to dependencies available on the classpath: e.g. payload converters <span class="keyword">for</span> JSON, XML, etc.</span><br></pre></td></tr></table></figure><p>在官网上每一个注解都会有相应的解释和例子。</p><ol start="2"><li>配置组件（视图解析器、视图映射、静态资源映射、拦截器……）<br>官网上表示<code>In Java config implement WebMvcConfigurer interface:</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Validator <span class="title">getValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageCodesResolver <span class="title">getMessageCodesResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果是实现<code>WebMvcConfigurer</code>接口，则需要实现的方法太多，但是我们一般用不了这些方法，所以，可以继承<code>WebMvcConfigurer</code>的一个抽象类<code>WebMvcConfigurerAdapter</code>，这个抽象类已经实现了这些所有的方法（空的而已），所以，我们就可以有目的的进行定制。<br>比如：定制视图解析器、静态资源访问、拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringMVC只扫描Controller；子容器</span></span><br><span class="line"><span class="comment">//useDefaultFilters=false 禁用默认的过滤规则；</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,includeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//默认所有的页面都从 /WEB-INF/ xxx .jsp</span></span><br><span class="line"><span class="comment">//registry.jsp();</span></span><br><span class="line">registry.jsp(<span class="string">"/WEB-INF/views/"</span>, <span class="string">".jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源访问</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> MyFirstInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定制化中用到的拦截器定义如下MyFirstInterceptor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标方法运行之前执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"preHandle..."</span>+request.getRequestURI());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标方法执行正确以后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postHandle..."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面响应以后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"afterCompletion..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的定制方法可以参考官网：<a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config</a> 其中1.11 MVC Config章节有对每个组件的详细说明。（调用什么方法，相当于之前的什么写法）</p><h1 id="五、Servelet3-0与SpringMVC整合——异步请求"><a href="#五、Servelet3-0与SpringMVC整合——异步请求" class="headerlink" title="五、Servelet3.0与SpringMVC整合——异步请求"></a>五、Servelet3.0与SpringMVC整合——异步请求</h1><h2 id="1-servlet-3-0另外一个重大的更新功能是异步请求"><a href="#1-servlet-3-0另外一个重大的更新功能是异步请求" class="headerlink" title="1. servlet 3.0另外一个重大的更新功能是异步请求"></a>1. servlet 3.0另外一个重大的更新功能是异步请求</h2><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求。<br>即每一次Http请求都由某一个线程从头到尾负责处理。</p><p>如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。即便是像Spring、Struts这样的高层框架也脱离不了这样的桎梏，因为他们都是建立在Servlet之上的。为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</p><p>配置步骤：</p><ol><li>支持异步处理asyncSupported=true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value=<span class="string">"/async"</span>,asyncSupported=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>开启异步模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext startAsync = req.startAsync();</span><br></pre></td></tr></table></figure><p>startAsync 可以设置异步请求的监听器、异步处理的超时时间等等。</p><ol start="3"><li>业务逻辑进行异步处理;开始异步处理</li><li>在start方法中的run方法中获取相应<br>3和4的代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">startAsync.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"副线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">            sayHello();</span><br><span class="line">            startAsync.complete();</span><br><span class="line">            <span class="comment">//获取到异步上下文</span></span><br><span class="line">            AsyncContext asyncContext = req.getAsyncContext();</span><br><span class="line">            <span class="comment">// 4、获取响应</span></span><br><span class="line">            ServletResponse response = asyncContext.getResponse();</span><br><span class="line">            response.getWriter().write(<span class="string">"hello async..."</span>);</span><br><span class="line">            System.out.println(<span class="string">"副线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整的异步Servlet代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(value=<span class="string">"/async"</span>,asyncSupported=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、支持异步处理asyncSupported=true</span></span><br><span class="line"><span class="comment">//2、开启异步模式</span></span><br><span class="line">System.out.println(<span class="string">"主线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">AsyncContext startAsync = req.startAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、业务逻辑进行异步处理;开始异步处理</span></span><br><span class="line">startAsync.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"副线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">sayHello();</span><br><span class="line">startAsync.complete();</span><br><span class="line"><span class="comment">//获取到异步上下文</span></span><br><span class="line">AsyncContext asyncContext = req.getAsyncContext();</span><br><span class="line"><span class="comment">//4、获取响应</span></span><br><span class="line">ServletResponse response = asyncContext.getResponse();</span><br><span class="line">response.getWriter().write(<span class="string">"hello async..."</span>);</span><br><span class="line">System.out.println(<span class="string">"副线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"主线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread()+<span class="string">" processing..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主线程开始。。。Thread[http-nio-8080-exec-2,5,main]==&gt;1548248108792</span><br><span class="line">主线程结束。。。Thread[http-nio-8080-exec-2,5,main]==&gt;1548248108796</span><br><span class="line">副线程开始。。。Thread[http-nio-8080-exec-3,5,main]==&gt;1548248108796</span><br><span class="line">Thread[http-nio-8080-exec-3,5,main] processing...</span><br><span class="line">UserFilter...doFilter...</span><br><span class="line">主线程开始。。。Thread[http-nio-8080-exec-5,5,main]==&gt;1548248112056</span><br><span class="line">主线程结束。。。Thread[http-nio-8080-exec-5,5,main]==&gt;1548248112056</span><br><span class="line">副线程开始。。。Thread[http-nio-8080-exec-6,5,main]==&gt;1548248112056</span><br><span class="line">Thread[http-nio-8080-exec-6,5,main] processing...</span><br></pre></td></tr></table></figure><h2 id="2-Springmvc整合servlet-3-0异步请求功能"><a href="#2-Springmvc整合servlet-3-0异步请求功能" class="headerlink" title="2. Springmvc整合servlet 3.0异步请求功能"></a>2. Springmvc整合servlet 3.0异步请求功能</h2><p><a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Springmvc官网的Async Request说明</a><br>1.6章节Async Requests，该章节有详细的例子和说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Here is a very concise overview of Servlet asynchronous request processing:</span><br><span class="line"></span><br><span class="line">A ServletRequest can be put in asynchronous mode by calling request.startAsync(). The main effect of doing so is that the Servlet, as well as any Filters, can exit but the response will remain open to allow processing to complete later.</span><br><span class="line"></span><br><span class="line">The call to request.startAsync() returns AsyncContext which can be used for further control over async processing. For example it provides the method dispatch, that is similar to a forward from the Servlet API except it allows an application to resume request processing on a Servlet container thread.</span><br><span class="line"></span><br><span class="line">The ServletRequest provides access to the current DispatcherType that can be used to distinguish between processing the initial request, an async dispatch, a forward, and other dispatcher types.</span><br><span class="line"></span><br><span class="line">DeferredResult processing:</span><br><span class="line"></span><br><span class="line">Controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed.</span><br><span class="line"></span><br><span class="line">Spring MVC calls request.startAsync().</span><br><span class="line"></span><br><span class="line">Meanwhile the DispatcherServlet and all configured Filter’s exit the request processing thread but the response remains open.</span><br><span class="line"></span><br><span class="line">The application sets the DeferredResult from some thread and Spring MVC dispatches the request back to the Servlet container.</span><br><span class="line"></span><br><span class="line">The DispatcherServlet is invoked again and processing resumes with the asynchronously produced return value.</span><br><span class="line"></span><br><span class="line">Callable processing:</span><br><span class="line"></span><br><span class="line">Controller returns a Callable.</span><br><span class="line"></span><br><span class="line">Spring MVC calls request.startAsync() and submits the Callable to a TaskExecutor for processing in a separate thread.</span><br><span class="line"></span><br><span class="line">Meanwhile the DispatcherServlet and all Filter’s exit the Servlet container thread but the response remains open.</span><br><span class="line"></span><br><span class="line">Eventually the Callable produces a result and Spring MVC dispatches the request back to the Servlet container to complete processing.</span><br><span class="line"></span><br><span class="line">The DispatcherServlet is invoked again and processing resumes with the asynchronously produced return value from the Callable.</span><br></pre></td></tr></table></figure><p>上面英文的意思如下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/createOrder"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;Object&gt; <span class="title">createOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">DeferredResult&lt;Object&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;((<span class="keyword">long</span>)<span class="number">3000</span>, <span class="string">"create fail..."</span>);</span><br><span class="line"></span><br><span class="line">DeferredResultQueue.save(deferredResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/create"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建订单</span></span><br><span class="line">String order = UUID.randomUUID().toString();</span><br><span class="line">DeferredResult&lt;Object&gt; deferredResult = DeferredResultQueue.get();</span><br><span class="line">deferredResult.setResult(order);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success===&gt;"</span>+order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、控制器返回Callable</span></span><br><span class="line"><span class="comment"> * 2、Spring异步处理，将Callable 提交到 TaskExecutor 使用一个隔离的线程进行执行</span></span><br><span class="line"><span class="comment"> * 3、DispatcherServlet和所有的Filter退出web容器的线程，但是response 保持打开状态；</span></span><br><span class="line"><span class="comment"> * 4、Callable返回结果，SpringMVC将请求重新派发给容器，恢复之前的处理；</span></span><br><span class="line"><span class="comment"> * 5、根据Callable返回的结果。SpringMVC继续进行视图渲染流程等（从收请求-视图渲染）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * preHandle.../springmvc-annotation/async01</span></span><br><span class="line"><span class="comment">主线程开始...Thread[http-bio-8081-exec-3,5,main]==&gt;1513932494700</span></span><br><span class="line"><span class="comment">主线程结束...Thread[http-bio-8081-exec-3,5,main]==&gt;1513932494700</span></span><br><span class="line"><span class="comment">=========DispatcherServlet及所有的Filter退出线程============================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================等待Callable执行==========</span></span><br><span class="line"><span class="comment">副线程开始...Thread[MvcAsync1,5,main]==&gt;1513932494707</span></span><br><span class="line"><span class="comment">副线程开始...Thread[MvcAsync1,5,main]==&gt;1513932496708</span></span><br><span class="line"><span class="comment">================Callable执行完成==========</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================再次收到之前重发过来的请求========</span></span><br><span class="line"><span class="comment">preHandle.../springmvc-annotation/async01</span></span><br><span class="line"><span class="comment">postHandle...（Callable的之前的返回值就是目标方法的返回值）</span></span><br><span class="line"><span class="comment">afterCompletion...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">异步的拦截器:</span></span><br><span class="line"><span class="comment">1）、原生API的AsyncListener</span></span><br><span class="line"><span class="comment">2）、SpringMVC：实现AsyncHandlerInterceptor；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/async01"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">async01</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"主线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"副线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">"副线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Callable&lt;String&gt; async01()"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"主线程结束..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"><span class="keyword">return</span> callable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>Springmvc对异步请求主要分为两种：返回Callable和返回DeferredResult。</p><ol><li>返回Callable：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A controller may also wrap any supported <span class="keyword">return</span> value with java.util.concurrent.Callable:</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">processUpload</span><span class="params">(<span class="keyword">final</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"someView"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">The <span class="keyword">return</span> value will then be obtained by executing the the given task through the configured TaskExecutor.</span><br></pre></td></tr></table></figure><p>在实际的开发中，一般不会像返回Callable这么简单，一般都会用到返回DeferredResult。</p><ol start="2"><li>返回DeferredResult</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Once the asynchronous request processing feature is enabled in the Servlet container, controller methods can wrap any supported controller method <span class="keyword">return</span> value with DeferredResult:</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/quotes"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">quotes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From some other thread...</span></span><br><span class="line">deferredResult.setResult(data);</span><br><span class="line">The controller can produce the <span class="keyword">return</span> value asynchronously, from a different thread, <span class="function"><span class="keyword">for</span> example in response to an external <span class="title">event</span> <span class="params">(JMS message)</span>, a scheduled task, or other.</span></span><br></pre></td></tr></table></figure><p>上面官网的意思是：当请求不能得到及时响应时，先new DeferredResult();并立刻返回，并把这个对象保存到其他的地方。另外一个线程拿到这个对象后，进行真正的处理，处理完成后，通过调用setResult(data)方法，将结果响应出去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/whichversion.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tomcat对Servlet规范的支持说明&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://jcp.org
      
    
    </summary>
    
      <category term="servlet3.0" scheme="http://blog.shagle.cn/categories/servlet3-0/"/>
    
      <category term="spring mvc" scheme="http://blog.shagle.cn/categories/servlet3-0/spring-mvc/"/>
    
    
      <category term="servlet3.0" scheme="http://blog.shagle.cn/tags/servlet3-0/"/>
    
      <category term="spring mvc" scheme="http://blog.shagle.cn/tags/spring-mvc/"/>
    
  </entry>
  
</feed>
