<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.shagle.cn/"/>
  <updated>2019-03-08T05:23:54.000Z</updated>
  <id>http://blog.shagle.cn/</id>
  
  <author>
    <name>bogle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis之字符串</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之字符串/</id>
    <published>2019-03-08T05:21:20.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h1><p>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。<br>举个例子，如果客户端执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS。</li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS。<br>又比如，如果客户端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串”fruits”的SDS。</p></li><li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串”apple”，第二个SDS保存着字符串”banana”，第三个SDS保存着字符串”cherry”。</li></ul><h2 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1 SDS的定义"></a>1.1 SDS的定义</h2><p>每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图2-1展示了一个SDS示例：</p><p><img src="20190308132256.png" alt=""></p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存</li></ul><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</p><h1 id="2。2-对c和sds之间区别进行总结"><a href="#2。2-对c和sds之间区别进行总结" class="headerlink" title="2。2 对c和sds之间区别进行总结"></a>2。2 对c和sds之间区别进行总结</h1><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(N)</td><td style="text-align:left">获取字符串长度复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API思安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重新分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存分配</td></tr><tr><td style="text-align:left">只能保持文本数据</td><td style="text-align:left">可以保存文本或二进制数据</td></tr><tr><td style="text-align:left">可以使用所有&lt;string.h&gt;库中的函数</td><td style="text-align:left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p>SDS 主要API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table><p>sdsnew|    创建一个包含给定 C 字符串的 SDS 。    |O(N) ， N 为给定 C 字符串的长度。<br>sdsempty|    创建一个不包含任何内容的空 SDS 。    |O(1)<br>sdsfree|    释放给定的 SDS 。    |O(1)<br>sdslen|    返回 SDS 的已使用空间字节数。    |这个值可以通过读取 SDS 的 len 属性来直接获得， 复杂度为 O(1) 。<br>sdsavail|    返回 SDS 的未使用空间字节数。    |这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1) 。<br>sdsdup|    创建一个给定 SDS 的副本（copy）。    |O(N) ， N 为给定 SDS 的长度。<br>sdsclear|    清空 SDS 保存的字符串内容。|    因为惰性空间释放策略，复杂度为 O(1) 。<br>sdscat|    将给定 C 字符串拼接到 SDS 字符串的末尾。    |O(N) ， N 为被拼接 C 字符串的长度。<br>sdscatsds|    将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。    |O(N) ， N 为被拼接 SDS 字符串的长度。<br>sdscpy|    将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。    |O(N) ， N 为被复制 C 字符串的长度。<br>sdsgrowzero|    用空字符将 SDS 扩展至给定长度。|    O(N) ， N 为扩展新增的字节数。<br>sdsrange|    保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。    |O(N) ， N 为被保留数据的字节数。<br>sdstrim|    接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。    |O(M*N) ， M 为 SDS 的长度， N 为给定 C 字符串的长度。<br>sdscmp|    对比两个 SDS 字符串是否相同。    |O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单动态字符串&quot;&gt;&lt;a href=&quot;#1-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;1. 简单动态字符串&quot;&gt;&lt;/a&gt;1. 简单动态字符串&lt;/h1&gt;&lt;p&gt;当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Re
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之链表</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之链表/</id>
    <published>2019-03-08T05:17:42.000Z</published>
    <updated>2019-03-08T05:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h1><h2 id="1-1-链表和链表节点的实现"><a href="#1-1-链表和链表节点的实现" class="headerlink" title="1.1 链表和链表节点的实现"></a>1.1 链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    struct listNode * prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    struct listNode * next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line"></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表，如图3-1所示。</p><p><img src="20190304174146.png" alt=""></p><p>虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    unsigned <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>图3-2是由一个list结构和三个listNode结构组成的链表。</li></ul><p><img src="20190304180006.png" alt=""></p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free […]</li></ul><h2 id="1-2-链表和链表节点的API"><a href="#1-2-链表和链表节点的API" class="headerlink" title="1.2 链表和链表节点的API"></a>1.2 链表和链表节点的API</h2><p>表3-1列出了所有用于操作链表和链表节点的API。</p><p>表 3-1 链表和链表节点 API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数。</td><td style="text-align:left">复制函数可以通过链表的 dup 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数。</td><td style="text-align:left">释放函数可以通过链表的 free 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数。</td><td style="text-align:left">对比函数可以通过链表的 match 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）。</td><td style="text-align:left">链表长度可以通过链表的 len 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点。</td><td style="text-align:left">表头节点可以通过链表的 head 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表尾节点。</td><td style="text-align:left">表尾节点可以通过链表的 tail 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点。</td><td style="text-align:left">前置节点可以通过节点的 prev 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点。</td><td style="text-align:left">后置节点可以通过节点的 next 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值。</td><td style="text-align:left">节点值可以通过节点的 value 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr></tbody></table><h2 id="1-3-重点回顾"><a href="#1-3-重点回顾" class="headerlink" title="1.3 重点回顾"></a>1.3 重点回顾</h2><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-链表&quot;&gt;&lt;a href=&quot;#1-链表&quot; class=&quot;headerlink&quot; title=&quot;1. 链表&quot;&gt;&lt;/a&gt;1. 链表&lt;/h1&gt;&lt;h2 id=&quot;1-1-链表和链表节点的实现&quot;&gt;&lt;a href=&quot;#1-1-链表和链表节点的实现&quot; class=&quot;header
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之对象</title>
    <link href="http://blog.shagle.cn/2019/03/07/Redis%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.shagle.cn/2019/03/07/Redis之对象/</id>
    <published>2019-03-07T09:32:18.000Z</published>
    <updated>2019-03-07T09:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="redis设计与实现.md">在前面的数个章节里</a>，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p><p>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><p>本章接下来将逐一介绍以上提到的Redis对象系统的各个特性。</p><h1 id="1-对象的类型与编码"><a href="#1-对象的类型与编码" class="headerlink" title="1. 对象的类型与编码"></a>1. 对象的类型与编码</h1><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。<br>举个例子，以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值”msg”的对象，而键值对的值则是一个包含了字符串值”hello world”的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    unsigned type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1 类型"></a>1.1 类型</h2><p>对象的type属性记录了对象的类型，这个属性的值可以是表8-1列出的常量的其中一个。</p><p><img src="20190307173736.png" alt=""></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为哈希对象</span><br><span class="line"></span><br><span class="line">redis&gt; HMSET profile name Tom age 25 career Programmer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE profile</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE fruits</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为有序集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE price</span><br><span class="line">zset</span><br></pre></td></tr></table></figure><p><img src="20190307174110.png" alt=""></p><h2 id="1-2-编码和底层实现"><a href="#1-2-编码和底层实现" class="headerlink" title="1.2 编码和底层实现"></a>1.2 编码和底层实现</h2><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表8-3列出的常量的其中一个。</p><p><img src="20190307174221.png" alt=""></p><p>每种类型的对象都至少使用了两种不同的编码，表8-4列出了每种类型的对象可以使用的编码。</p><p><img src="20190307174256.png" alt=""></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SET story &quot;long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers &quot;seven&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>表8-5列出了不同编码的对象所对应的OBJECT ENCODING命令输出。</p><p><img src="20190307174357.png" alt=""></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><p>在接下来的内容中，我们将分别介绍Redis中的五种不同类型的对象，说明这些对象底层所使用的编码方式，列出对象从一种编码转换成另一种编码所需的条件，以及同一个命令在多种不同编码上的实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;redis设计与实现.md&quot;&gt;在前面的数个章节里&lt;/a&gt;，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。&lt;/p&gt;
&lt;p&gt;Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>压缩列表zipList</title>
    <link href="http://blog.shagle.cn/2019/03/07/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8zipList/"/>
    <id>http://blog.shagle.cn/2019/03/07/压缩列表zipList/</id>
    <published>2019-03-07T02:11:07.000Z</published>
    <updated>2019-03-07T05:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表(<code>ziplist</code>)是列表键和哈希键的底层实现之一。</p><h1 id="1-压缩列表的构成"><a href="#1-压缩列表的构成" class="headerlink" title="1. 压缩列表的构成"></a>1. 压缩列表的构成</h1><p>压缩列表是<code>Redis</code>为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点,每个节点可以保存一个字节数组或者一个整数值。</p><p>当一个哈希键只包含少量key-value对，且每个key-value对的key和value要么是小整数，要么是较短字符串，那么redis就会使用<code>ziplist</code>作为哈希键的底层实现。</p><h1 id="2-ziplist的实现："><a href="#2-ziplist的实现：" class="headerlink" title="2. ziplist的实现："></a>2. ziplist的实现：</h1><p>ziplist的内存布局如下所示：</p><p><img src="20160505101226534.png.png" alt="ziplist的内存布局"></p><ul><li><code>zlbytes</code>：4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</li><li><code>zltail</code>：4字节，记录压缩列表尾部节点距离起始地址的偏移量：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址</li><li><code>zllen</code>：2字节，记录压缩列表包含的节点数量</li><li><code>entry</code>：不定，列表中的每个节点,节点的长度由节点保存的内存决定</li><li><code>zlend</code>：1字节，特殊值0xFF，标记压缩列表的结束</li></ul><p>因此通过下面的宏定义可以非常方便的求出各个字段的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span><br><span class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span><br><span class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span><br><span class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span><br><span class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span><br><span class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span><br><span class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span><br></pre></td></tr></table></figure><p><strong>一个简单的ziplist示意图如下：</strong></p><p><img src="20160505100030534.png" alt=""></p><ul><li>列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。</li><li>列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li><li>列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。</li></ul><h1 id="3-压缩列表节点的构成"><a href="#3-压缩列表节点的构成" class="headerlink" title="3. 压缩列表节点的构成"></a>3. 压缩列表节点的构成</h1><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p><img src="20190307102401.png" alt=""></p><h2 id="3-1-previous-entry-length"><a href="#3-1-previous-entry-length" class="headerlink" title="3.1 previous_entry_length"></a>3.1 previous_entry_length</h2><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>图7-5展示了一个包含一字节长previous_entry_length属性的压缩列表节点，属性的值为0x05，表示前一节点的长度为5字节。</p><p><img src="20190307111032.png" alt="图7-5"></p><p>图7-6展示了一个包含五字节长previous_entry_length属性的压缩节点，属性的值为0xFE00002766，其中值的最高位字节0xFE表示这是一个五字节长的previous_entry_length属性，而之后的四字节0x00002766（十进制值10086）才是前一节点的实际长度。</p><p><img src="20190307111127.png" alt="图7-6"></p><p>因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。<br>举个例子，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p，如图7-7所示。</p><p><img src="20190307111221.png" alt="图7-7"></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。</p><p>图7-8展示了一个从表尾节点向表头节点进行遍历的完整过程：</p><p><img src="20190307111316.png" alt="图7-8"></p><ul><li>首先，我们拥有指向压缩列表表尾节点entry4起始地址的指针p1（指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail属性的值得出）；</li><li>通过用p1减去entry4节点previous_entry_length属性的值，我们得到一个指向entry4前一节点entry3起始地址的指针p2；</li><li>通过用p2减去entry3节点previous_entry_length属性的值，我们得到一个指向entry3前一节点entry2起始地址的指针p3；</li><li>通过用p3减去entry2节点previous_entry_length属性的值，我们得到一个指向entry2前一节点entry1起始地址的指针p4，entry1为压缩列表的表头节点；</li><li>最终，我们从表尾节点向表头节点遍历了整个列表。</li></ul><h2 id="3-2-encoding"><a href="#3-2-encoding" class="headerlink" title="3.2 encoding"></a>3.2 encoding</h2><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；<br>表7-2记录了所有可用的字节数组编码，而表7-3则记录了所有可用的整数编码。表格中的下划线“_”表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。</li></ul><p><img src="20190307111918.png" alt=""></p><p><img src="20190307130819.png" alt=""></p><h2 id="3-3-content"><a href="#3-3-content" class="headerlink" title="3.3 content"></a>3.3 content</h2><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p>图7-9展示了一个保存字节数组的节点<code>示例</code>：</p><p><img src="20190307131023.png" alt="图7-9"></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值”hello world”。</li></ul><p>图7-10展示了一个保存整数值的节点<code>示例</code>：</p><p><img src="20190307131251.png" alt=""></p><ul><li>编码11000000表示节点保存的是一个int16_t类型的整数值；</li><li>content属性保存着节点的值10086。</li></ul><h2 id="3-4-连锁更新"><a href="#3-4-连锁更新" class="headerlink" title="3.4. 连锁更新"></a>3.4. 连锁更新</h2><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如图7-11所示。</p><p><img src="20190307132432.png" alt="图7-11"></p><p>因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性，换句话说，e1至eN的所有节点的previous_entry_length属性都是1字节长的。<br>这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点，如图7-12所示。</p><p><img src="20190307132535.png" alt="图7-12"></p><p>因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。</p><p>因此，为了让e2的previous_entry_length属性可以记录下e1的长度，程序需要再次对压缩列表执行空间重分配操作，并将e2节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展……为了让每个节点的previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update），图7-13展示了这一过程。</p><p><img src="20190307132704.png" alt="图7-13"></p><p>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</p><p>考虑图7-14所示的压缩列表，如果e1至eN都是大小介于250字节至253字节的节点，big节点的长度大于等于254字节（需要5字节的previous_entry_length来保存），而small节点的长度小于254字节（只需要1字节的previous_entry_length来保存），那么当我们将small节点从压缩列表中删除之后，为了让e1的previous_entry_length属性可以记录big节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。</p><p><img src="20190307132846.png" alt="图7-14"></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N2)。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;压缩列表(&lt;code&gt;ziplist&lt;/code&gt;)是列表键和哈希键的底层实现之一。&lt;/p&gt;
&lt;h1 id=&quot;1-压缩列表的构成&quot;&gt;&lt;a href=&quot;#1-压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;1. 压缩列表的构成&quot;&gt;&lt;/a&gt;1. 压缩列表的
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>算法之SkipList跳表</title>
    <link href="http://blog.shagle.cn/2019/03/06/%E7%AE%97%E6%B3%95%E4%B9%8BSkipList%E8%B7%B3%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/06/算法之SkipList跳表/</id>
    <published>2019-03-06T07:10:11.000Z</published>
    <updated>2019-03-06T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么选择跳表"><a href="#1-为什么选择跳表" class="headerlink" title="1. 为什么选择跳表"></a>1. 为什么选择跳表</h1><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。</p><p>想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树</p><p>出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，</p><p>还要参考网上的代码，相当麻烦。</p><p>用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，</p><p>它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，</p><p>就能轻松实现一个 SkipList。</p><h1 id="2-有序表的搜索"><a href="#2-有序表的搜索" class="headerlink" title="2. 有序表的搜索"></a>2. 有序表的搜索</h1><p>考虑一个有序表：</p><p><img src="d5d03b36-abff-34ea-9c40-a1fbfb709a81.jpg" alt=""></p><p>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="7c904c3f-1f39-31af-b8cd-b6de27a94061.jpg" alt=""></p><p>这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：</p><p><img src="96983cb0-d60a-31da-953d-2dde4036ea6b.jpg" alt=""></p><p>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p><h1 id="3-跳表"><a href="#3-跳表" class="headerlink" title="3. 跳表"></a>3. 跳表</h1><p>下面的结构是就是跳表：</p><p>其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。</p><p><img src="f4c149bd-d8ea-39ff-813f-93d809c90966.jpg" alt=""></p><p>跳表具有如下性质：</p><ul><li>(1) 由很多层结构组成</li><li>(2) 每一层都是一个有序的链表</li><li>(3) 最底层(Level 1)的链表包含所有元素</li><li>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li><li>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ul><h1 id="4-跳表的搜索"><a href="#4-跳表的搜索" class="headerlink" title="4. 跳表的搜索"></a>4. 跳表的搜索</h1><p><img src="ec9fd643-f85c-3072-8634-60cfc88ab334.jpg" alt=""></p><p>例子：查找元素 117</p><ul><li>(1) 比较 21， 比 21 大，往后面找</li><li>(2) 比较 37,   比 37大，比链表最大值小，从 37 的下面一层开始找</li><li>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</li><li>(4) 比较 85， 比 85 大，从后面找</li><li>(5) 比较 117， 等于 117， 找到了节点。</li></ul><p>具体的搜索算法如下： </p><p><strong>C代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果存在 x, 返回 x 所在的节点， </span></span><br><span class="line"><span class="comment"> * 否则返回 x 的后继节点 */</span>  </span><br><span class="line">find(x)   </span><br><span class="line">&#123;  </span><br><span class="line">    p = top;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;key &lt; x)  </span><br><span class="line">            p = p-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;down == NULL)   </span><br><span class="line">            <span class="keyword">return</span> p-&gt;next;  </span><br><span class="line">        p = p-&gt;down;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-跳表的插入"><a href="#5-跳表的插入" class="headerlink" title="5. 跳表的插入"></a>5. 跳表的插入</h1><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K = 2</p><p><img src="bb72be16-6162-3fee-b680-311f25dd7c3a.jpg" alt=""></p><p>如果 K 大于链表的层数，则要添加新的层。</p><p>例子：插入 119， K = 4</p><p><img src="6eac083f-45d9-37f9-867f-0d709d9659d3.jpg" alt=""></p><h1 id="6-丢硬币决定-K"><a href="#6-丢硬币决定-K" class="headerlink" title="6. 丢硬币决定 K"></a>6. 丢硬币决定 K</h1><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    K = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (random(<span class="number">0</span>,<span class="number">1</span>))  </span><br><span class="line">        K++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> K;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，<br>用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，<br>K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p><h1 id="7-跳表的高度。"><a href="#7-跳表的高度。" class="headerlink" title="7. 跳表的高度。"></a>7. 跳表的高度。</h1><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，跳表的高度等于这 n 次实验中产生的最大 K，待续。。。</p><h1 id="8-跳表的空间复杂度分析"><a href="#8-跳表的空间复杂度分析" class="headerlink" title="8. 跳表的空间复杂度分析"></a>8. 跳表的空间复杂度分析</h1><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的期望值是 2n。</p><h1 id="9-跳表的删除"><a href="#9-跳表的删除" class="headerlink" title="9. 跳表的删除"></a>9. 跳表的删除</h1><p>在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。</p><p>例子：删除 71</p><p><img src="7bab9ad1-9f5a-37d0-bc38-89ee50d1bc0d.jpg" alt=""></p><p><a href="https://kenby.iteye.com/blog/1187303" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么选择跳表&quot;&gt;&lt;a href=&quot;#1-为什么选择跳表&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么选择跳表&quot;&gt;&lt;/a&gt;1. 为什么选择跳表&lt;/h1&gt;&lt;p&gt;目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, T
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.shagle.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="SkipList跳表" scheme="http://blog.shagle.cn/tags/SkipList%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现</title>
    <link href="http://blog.shagle.cn/2019/03/04/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.shagle.cn/2019/03/04/redis设计与实现/</id>
    <published>2019-03-04T06:45:49.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库键总是一个字符串对象（string object）；</li><li>而数据库键的值则可以是字符串对象、列表对象（list object）、哈希对象（hash object）、集合对象（set object）、有序集合对象（sorted set object）这五种对象中的其中一种。</li></ul><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. <a href="Redis之字符串.md">字符串</a></h1><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. <a href="Redis之链表.md">链表</a></h1><h1 id="4-字典"><a href="#4-字典" class="headerlink" title="4. 字典"></a>4. 字典</h1><h1 id="5-跳跃表"><a href="#5-跳跃表" class="headerlink" title="5. 跳跃表"></a>5. <a href="算法之SkipList跳表.md">跳跃表</a></h1><h1 id="6-整数集合"><a href="#6-整数集合" class="headerlink" title="6. 整数集合"></a>6. 整数集合</h1><h1 id="7-压缩列表"><a href="#7-压缩列表" class="headerlink" title="7. 压缩列表"></a>7. <a href="压缩列表zipList.md">压缩列表</a></h1><p>压缩列表参考：<a href="https://blog.csdn.net/u012658346/article/details/51321337" target="_blank" rel="noopener">https://blog.csdn.net/u012658346/article/details/51321337</a></p><h1 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. <a href="Redis之对象.md">对象</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock源码解析</title>
    <link href="http://blog.shagle.cn/2019/02/28/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.shagle.cn/2019/02/28/Java技术之ReentrantReadWriteLock源码解析/</id>
    <published>2019-02-28T07:14:17.000Z</published>
    <updated>2019-02-28T07:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-阅读须知"><a href="#1-阅读须知" class="headerlink" title="1. 阅读须知"></a>1. 阅读须知</h1><ul><li><p>JDK版本：1.8</p></li><li><p>文章中使用/**/注释的方法会做深入分析</p></li></ul><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><p><code>ReentrantReadWriteLock</code>，从字面上理解为可重入读写锁，基于<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>，不了解AQS的读者可以去看笔者关于AQS源码解析的文章进行学习）实现，根据读写锁的特性，我们可以猜测，读锁应该是基于AQS的共享锁实现，而写锁应该是基于AQS的独占锁实现，我们来验证这个猜想，首先看一下<code>ReentrantReadWriteLock</code>的构造方法：</p><p><strong>ReentrantReadWriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的boolean变量fair来确定使用公平锁或非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>默认的无参构造方法使用的是非公平锁。我们来介绍一下<code>ReentrantReadWriteLock</code>中的同步器<code>Sync</code>中的一些变量：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁占用高16位表示持有读锁的线程的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//根据SHARED_SHIFT变量的含义，每增加一个持有读锁的线程，state变量就需要累加这个值，也就是1左移16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">//持有读锁的线程的最大数量（65535）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//用于计算写锁的重入计数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//当前线程持有的读锁的重入数量。只在构造函数和readObject方法中初始化。线程的锁重入计数降至0时删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"><span class="comment">//最后一个成功获取readLock的线程的持有锁计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="comment">//firstReader是获取读锁的第一个线程。</span></span><br><span class="line"><span class="comment">//更确切地说，firstReader是最后一次将共享计数从0更改为1的唯一线程，</span></span><br><span class="line"><span class="comment">//并且自那以后未释放读锁; 如果没有这样的线程，则返回null。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//firstReaderHoldCount是firstReader的锁重入计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>使用<code>AQS</code>的<code>state</code>的高16位表示持有读锁的线程的数量，低16位表示写锁被同一个线程申请的次数，也就是锁重入的次数。接下来我们来看加锁实现，我们首先来看读锁部分：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（共享锁部分）这篇文章中进行过详细分析，方法的开始会调用有子类实现的<code>tryAcquireShared</code>方法尝试以共享模式获得锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquireShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果独占锁的重入计数不为0（说明有线程持有独占锁）并且持有独占锁的线程不是当前线程返回-1代表获取共享锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">//共享锁的持有线程数量</span></span><br><span class="line">    <span class="comment">/*判断当前获取读锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//共享锁的持有线程的数量是否超过了最大值</span></span><br><span class="line">    <span class="comment">//CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//满足条件说明当前没有任何任何线程持有共享锁，则将当前线程设置为获取共享锁的第一个线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">//锁重入数量初始化为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果当前获取共享锁的线程是获取共享锁的第一个线程，则递增锁重入数量</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">//如果最后一个成功获取readLock的线程的锁重入计数对象还未初始化或者对象内部维护的线程id不是当前线程id</span></span><br><span class="line">                <span class="comment">//则将cachedHoldCounter赋值为当前线程的锁重入计数对象</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++; <span class="comment">//递增当前线程的锁重入计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*tryAcquireShared方法的完整版*/</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下方法的执行过程：</p><ul><li><ol><li>如果另一个线程持有写锁，则获取共享锁失败。</li></ol></li><li><ol start="2"><li>否则，此线程符合锁定状态，判断是否应该因为队列策略而阻塞。如果没有，尝试通过CAS增加共享锁的持有线程的数量。请注意，这步不会检查重入获取，它会被推迟到<code>fullTryAcquireShared</code>方法执行，以避免在更典型的非重入情况下检查锁重入计数。</li></ol></li><li><ol start="3"><li>如果步骤2因线程需要阻塞或CAS失败或计数饱和而失败，则调用<code>fullTryAcquireShared</code>方法。 关于<code>readerShouldBlock</code>（判断当前获取读锁的线程是否需要阻塞）方法，有公平和非公平两种实现，我们首先来看非公平的实现：</li></ol></li></ul><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apparentlyFirstQueuedIsExclusive</code>方法来自AQS，主要用于判断等待队列的头结点的下一个节点也就是第一个排队的线程是否以独占模式等待。这里我们要结合调用<code>readerShouldBlock</code>方法之前的if判断进行分析，如果这个if判断不满足，说明有两种情况可能发生：</p><ul><li><ol><li>当前没有线程占用写锁，这种情况readerShouldBlock方法会返回false。</li></ol></li><li><ol start="2"><li>当前有线程占用写锁，并且占用写锁的线程就是当前线程（当前线程是<code>head</code>节点），这时就发生了锁降级的情况，也就是当前线程持有写锁，并在申请读锁，这时就要判断<code>head</code>节点的下一个节点是否要申请写锁，如果是则<code>readerShouldBlock</code>方法返回<code>true</code>，说明本次申请读锁的操作需要阻塞。</li></ol></li></ul><p>接下来我们来看<code>readerShouldBlock</code>方法公平锁的实现：</p><p><strong>ReentrantReadWriteLock.FairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasQueuedPredecessors</code>方法我们在<code>ReentrantLock</code>源码解析这篇文章中分析过，它的主要作用是确认当前线程是否是下一个能够优先获得锁的线程，公平性也就是通过这个判断来保证的。公平锁我们很好理解，就是根据等待队列中节点的顺序来保证获取锁的顺序。</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//同样的判断是否有非当前线程持有独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//同样的判断当前获取读锁操作是否需要阻塞</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//确保没有重复获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">//这里如果当前线程持有的共享锁重入计数为0，则移除锁重入计数对象</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//锁重入计数为0时，返回-1代表获取共享锁失败，要进行排队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="comment">//超过最大持有读锁线程数量抛出Error</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//再次尝试获取共享锁，判断CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">        <span class="comment">//整体共享锁获取成功的处理逻辑与tryAcquireShared方法基本一致</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看读锁释放的实现：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>releaseShared</code>释放共享锁方法同样来自于<code>AQS</code>，方法中首先会调用由子类覆盖的<code>tryReleaseShared</code>方法，通过尝试设置<code>state</code>变量来释放共享锁，我们来看<code>ReentrantReadWriteLock</code>对于<code>tryReleaseShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//判断当前线程是否是获取读锁的第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果锁重入计数为1，直接将获取读锁的第一个线程置为null，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果锁重入计数不为1（大于1），则在释放时递减锁重入计数</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">//这里的判断上文分析过</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count; <span class="comment">//当前线程的锁重入计数</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//小于等于1时说明这是最后一个重入锁，则移除锁重入计数对象</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//锁重入计数小于等于0说明本次解锁操作没有对应的加锁操作，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count; <span class="comment">//递减锁重入计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的自旋操作为递减共享锁持有的线程数量，与加锁时的递增操作正好相反</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，读锁的加锁和解锁操作就分析完了，下面我们来分析写锁的加锁和解锁操作，首先来看加锁：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，写锁是基于<code>AQS</code>的独占锁实现，这里的<code>acquire</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（独占锁部分）这篇文章中已经详细分析过，方法的第一步就是调用由子类实现的<code>tryAcquire</code>方法通过操作<code>state</code>变量尝试以独占模式获取锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquire</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">//如果AQS的state变量不为0，说明当前读锁或写锁有被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的判断如果成立说明读锁被占用写锁未被占用</span></span><br><span class="line">        <span class="comment">//或者写锁被占用但占用的线程不是当前线程，这是返回false代表获取写锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//写锁最大重入数量的判断</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//走到这里说明是写锁重入，则递增写锁重入计数</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里说明当前读锁和写锁都未被任何线程占用</span></span><br><span class="line">    <span class="comment">/*判断获取写锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//判断CAS递增写锁重入计数是否失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//设置写锁的拥有者线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>writerShouldBlock</code>方法同样区分公平和非公平两个版本的实现，我们先来看非公平版本的实现：</p><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现方法直接返回<code>false</code>，也就是说每个想要获取非公平写锁的线程都可以直接参与竞争。而<code>writerShouldBlock</code>方法公平锁的版本与读锁的<code>readerShouldBlock</code>方法的公平版本是一样的，都是需要确认当前线程是否是下一个能够优先获得锁的线程，以此来保证公平性。最后我们来看写锁的解锁操作：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>release</code>方法我们在<code>AQS</code>独占锁源码解析的文章中同样进行过详细的分析，<code>AQS</code>的<code>release</code>方法首先会尝试调用由子类实现的<code>tryRelease</code>方法来尝试设置<code>state</code>变量来释放独占锁，锁完全释放后，会对后继节点进行唤醒操作，这个流程我们已经分析过，不再赘述。我们来看<code>ReentrantReadWriteLock</code>的对<code>tryRelease</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁和解锁的线程必须是同一个，不然抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//递减写锁的重入计数</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果递减后的锁重入计数为0，说明锁已经被完全释放，这时将锁的拥有者线程置为null</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc); <span class="comment">//设置最新的锁重入计数</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解锁的流程就分析完成了。</p><p><code>ReentrantReadWriteLock</code>的写锁还支持<code>Condition</code>，与<code>ReentrantLock</code>一样完全基于<code>AQS</code>的<code>ConditionObject</code>实现，我们已经分析过<code>ConditionObject</code>源码，不明白的同学可以前往进行查阅学习。到这里，<code>ReentrantReadWriteLock</code>的源码分析就完成了。</p><p><a href="http://www.linkedkeeper.com/1118.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-阅读须知&quot;&gt;&lt;a href=&quot;#1-阅读须知&quot; class=&quot;headerlink&quot; title=&quot;1. 阅读须知&quot;&gt;&lt;/a&gt;1. 阅读须知&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK版本：1.8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文章中使用/**/注释的方法会做
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之CPU使用率为什么飚升？</title>
    <link href="http://blog.shagle.cn/2019/02/27/Java%E6%8A%80%E6%9C%AF%E4%B9%8BCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A3%9A%E5%8D%87%EF%BC%9F/"/>
    <id>http://blog.shagle.cn/2019/02/27/Java技术之CPU使用率为什么飚升？/</id>
    <published>2019-02-27T09:07:00.000Z</published>
    <updated>2019-02-27T09:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>频繁 Young GC 会不会引起 CPU 使用率飚升？</p><p>线程数很高的应用，CPU 使用率一定高么？</p><p>CPU 使用率高的应用，线程数一定高么？</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>分时操作系统 CPU 是耗费 us ？ 还是耗费 sy ？</p><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><p><strong>CPU 使用率怎么算？</strong></p><p>CPU% = 1 - idleTime / sysTime * 100</p><ul><li><p>idleTime：CPU处于空闲状态的时间</p></li><li><p>sysTime：CPU处于用户态和内核台的时间总和</p></li></ul><p><strong>CPU 使用率跟啥有关系？</strong></p><p>我们常听说计算密集型的程序是比较耗 CPU 使用率的。</p><p>那 JAVA 应用中哪些操作是比较耗 CPU 使用的？</p><p>列举下日常程序中常见的耗CPU的操作：</p><ul><li><p>频繁GC，访问量高时，有可能造成频繁的GC、甚至FGC。当调用量大时，内存分配过快，就会造成GC线程不停的执行，导致CPU飙高。</p></li><li><p>序列化与反序列化，后文中举了一个真实的案例，程序执行xml解析的时，调用量增大的情况下，导致了CPU被打满。</p></li><li><p>加密、解密。</p></li><li><p>正则表达式校验，曾经线上发生一次血案，正则校验将CPU打满。大概原因是：Java 正则表达式使用的引擎实现是 NFA 自动机，这种引擎在进行字符匹配会发生回溯（backtracking）。</p></li><li><p>线程上下文切换、当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待、IO等待等）和执行状态的变化过程中。当锁竞争激烈时，很容易出现这种情况。</p></li><li><p>某些线程在做无阻塞的运算，简单的例子while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的计算，可以适当将程序sleep下。</p></li></ul><p><strong>CPU 与进程、线程有关系么？</strong></p><p>现在分时操作系统是通过循轮方式分配时间片进行进程调度的，如果进程在等待或阻塞，不会造成 CPU 资源使用。线程称为轻进程，共享进程资源，关于线程的调度，CPU 对于线程也是分时调度。而在 Java 中，线程的调用由 JVM 负责，线程的调度一般有两种模式，分时调度和抢占式调度。</p><h1 id="我的解惑"><a href="#我的解惑" class="headerlink" title="我的解惑"></a>我的解惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>会的。先不说别的，死循环会调用 CPU 寄存器进行计数，这个操作就会占用 CPU。其次，如果线程一直处于死循环状态，CPU 调用会进行线程切换么？</p><p>死循环不会让出 CPU，除非操作系统时间片到期，但死循环会不断向系统申请时间片，直到系统没有空闲时间做别的事情。</p><p>这个问题在 stackoverflow 也有人提问：why does an infinite loop of the unintended kind increase the CPU use?</p><p>地址：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use</a></p><p><strong>频繁 Young GC 会不会引起 CPU 使用率飚升？</strong></p><p>会的。Young GC 本身是 JVM 进行垃圾回收的操作，会计算内存和调用寄存器，频繁 Young GC 一定是会占用 CPU。</p><p>之前有个一个案例，for 循环从数据库查询数据集合，二次封装新的数据集合，这时如果量比较大时，内存没有足够的空间存储，那么 JVM 就会 GC 回收那些不再使用的数据，因此量大的时候，就会收到 CPU 使用率报警。</p><p><strong>线程数很高的应用，CPU 使用率一定高么？</strong></p><p>不会。通过 jstack 查看系统线程状态，查看整个线程数很多，但 Runable 和 Running 状态的线程不多，这时 CPU 使用率不一定会高。</p><p>之前有过一个案例，查看系统线程数 1000+，jstack 分析 900多个线程是 BLOCKED 和 WAITING 状态的，这种线程是不会占用 CPU 的。</p><p>如果线程数很高，其实大多数原因是死锁，大量线程处于 BLOCKED 和 WAITING 状态。</p><p><strong>CPU 使用率高的应用，线程数一定高么？</strong></p><p>不会。同上，CPU 使用率高的关键因素还是计算密集型操作，一个线程如果有大量计算，也会造成 CPU 使用率高，也是现在为什么一个大数据脚本任务，要大规模集群共同运算才能运行的原因。</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>不一定，CPU使用率的飙升，更多是因为上下文的切换或者runnable状态线程过多导致。Blocked状态，未必会引起CPU上升。</p><p><strong>分时操作系统 CPU us高或者sy高是什么意思？</strong></p><p>通过top命令，我们可以观察到cpu的us，sy值，示例如下：</p><p><img src="linkedkeeper0_2fe93bbe-a4b1-4083-9288-56657fdb5ee5.jpg" alt=""></p><ul><li><p>Us 用户空间占用CPU百分比，简单来说，us高是因为我们的程序导致的，通过分析线程堆栈，可以很容易的定位到问题线程。</p></li><li><p>Sy 内核空间占用CPU百分比，sy高的时候，如果是程序问题导致，基本是因为线程上下文切换造成的。</p></li></ul><h1 id="我的经验"><a href="#我的经验" class="headerlink" title="我的经验"></a>我的经验</h1><p>平时怎么定位 CPU 使用率高的原因的？</p><p>其实网上有个教程和方法，我简述我的分析过程。</p><p>首先发现某台应用 CPU 使用率高，一要看先线程数、JVM、系统 load 等参数，共同作证。二要打印 jstack，通过工具分析线程情况，推荐 fastThread 这个在线的 Thread 分析工具。</p><p>以下是线上发生的真实案例，简要介绍下：</p><p>某日晚，突然收到短信报警，CPU利用率100%。立刻dump该机器jstack，通过 <a href="http://fastthread.io/" target="_blank" rel="noopener">http://fastthread.io/</a> 查看日志如下：</p><p><img src="linkedkeeper0_2d349092-9402-48ac-b7dc-763afa7bf4a4.jpg" alt=""></p><p>进一步查看具体日志：</p><p><img src="linkedkeeper0_dca206cc-cecc-4f3a-95fd-a937450712a2.jpg" alt=""></p><p>通过这段日志，已经定位到了具体CPU被打满的方法，接收MQ之后，MQ消息体为xml，反序列化的时候，造成了CPU飙高。</p><p><strong>希望本文对大家有所帮助。</strong> </p><p><a href="http://www.linkedkeeper.com/1310.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我的疑惑&quot;&gt;&lt;a href=&quot;#我的疑惑&quot; class=&quot;headerlink&quot; title=&quot;我的疑惑&quot;&gt;&lt;/a&gt;我的疑惑&lt;/h1&gt;&lt;p&gt;一个 while 死循环，会不会引起 CPU 使用率飚升？&lt;/p&gt;
&lt;p&gt;频繁 Young GC 会不会引起 CPU 使用率
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cpu" scheme="http://blog.shagle.cn/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之引用类型</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之引用类型/</id>
    <published>2019-02-26T05:40:42.000Z</published>
    <updated>2019-02-26T05:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-了解-强引用、软引用、弱引用、虚引用的概念"><a href="#一-了解-强引用、软引用、弱引用、虚引用的概念" class="headerlink" title="一.了解 强引用、软引用、弱引用、虚引用的概念"></a>一.了解 强引用、软引用、弱引用、虚引用的概念</h1><p>在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。</p><p>从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。下面来阐述一下这四种类型引用的概念：</p><h1 id="1-1-强引用（StrongReference）"><a href="#1-1-强引用（StrongReference）" class="headerlink" title="1.1.强引用（StrongReference）"></a>1.1.强引用（StrongReference）</h1><p>强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Object[] objArr = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p><p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><p>比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> element that was removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    Object oldValue = elementData[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                 numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (E)oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-软引用（SoftReference）"><a href="#1-2-软引用（SoftReference）" class="headerlink" title="1.2.软引用（SoftReference）"></a>1.2.软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        SoftReference&lt;String&gt; sr = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-弱引用（WeakReference）"><a href="#1-3-弱引用（WeakReference）" class="headerlink" title="1.3.弱引用（WeakReference）"></a>1.3.弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                <span class="comment">//通知JVM的gc进行垃圾回收</span></span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。</p><h2 id="1-4-虚引用（PhantomReference）"><a href="#1-4-虚引用（PhantomReference）" class="headerlink" title="1.4.虚引用（PhantomReference）"></a>1.4.虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p><p>要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>虚引用主要用于检测对象是否已经从内存中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br><span class="line">        System.out.println(pr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-进一步理解软引用和弱引用"><a href="#二-进一步理解软引用和弱引用" class="headerlink" title="二.进一步理解软引用和弱引用"></a>二.进一步理解软引用和弱引用</h1><p>对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><p>在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：</p><p>两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。</p><p>在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</p><h1 id="三-如何利用软引用和弱引用解决OOM问题"><a href="#三-如何利用软引用和弱引用解决OOM问题" class="headerlink" title="三.如何利用软引用和弱引用解决OOM问题"></a>三.如何利用软引用和弱引用解决OOM问题</h1><p>前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？</p><p>下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p><p>设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。</p><p>下面这段代码是摘自博客：</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 强引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加该对象到Map中使其缓存</span></span><br><span class="line"></span><br><span class="line">    imageCache.put(path, softBitmap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从缓存中取软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在软引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (softBitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = softBitmap.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里我们把缓存替换策略交给了JVM去执行，这是一种比较简单的处理方法。复杂一点的缓存，我们可以自己单独设计一个类，这里面就涉及到缓存策略的问题了，具体可以参考之前的一篇博文：<a href="http://www.cnblogs.com/dolphin0520/p/3749259.html" target="_blank" rel="noopener">《缓存算法（页面置换算法）-FIFO、LFU、LRU》</a></p><p>参考资料：</p><p>《深入理解JVM虚拟机》</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><p><a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">http://blog.csdn.net/zsuguangh/article/details/6429592</a></p><p><a href="http://mobile.51cto.com/abased-406998.htm" target="_blank" rel="noopener">http://mobile.51cto.com/abased-406998.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-了解-强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;a href=&quot;#一-了解-强引用、软引用、弱引用、虚引用的概念&quot; class=&quot;headerlink&quot; title=&quot;一.了解 强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;/a&gt;一.了解 强引用、软引用、弱引用、
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="强引用、软引用、弱引用、虚引用" scheme="http://blog.shagle.cn/tags/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之深入分析ThreadLocal</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ThreadLocal/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之深入分析ThreadLocal/</id>
    <published>2019-02-26T01:36:46.000Z</published>
    <updated>2019-02-26T06:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLoacal是什么？"><a href="#ThreadLoacal是什么？" class="headerlink" title="ThreadLoacal是什么？"></a>ThreadLoacal是什么？</h1><p>ThreadLocal是啥？以前面试别人时就喜欢问这个，有些伙伴喜欢把它和线程同步机制混为一谈，事实上ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？</p><p>API是这样介绍它的：</p><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code>或<code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。 <code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><ul><li>get()：返回此线程局部变量的当前线程副本中的值。</li><li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li><li>remove()：移除此线程局部变量当前线程的值。</li><li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li></ul><p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p><p>对于ThreadLocal需要注意的有两点：</p><ul><li><ol><li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li></ol></li><li><ol start="2"><li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li></ol></li></ul><p>下图是Thread、ThreadLocal、ThreadLocalMap的关系（<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）</a></p><p><img src="640.jpeg" alt=""></p><h1 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h1><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seqCount.set(seqCount.get() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seqCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SeqCount seqCount = <span class="keyword">new</span> SeqCount();</span><br><span class="line">        SeqThread thread1 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread2 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread3 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread4 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SeqCount seqCount;</span><br><span class="line">        SeqThread(SeqCount seqCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.seqCount = seqCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">" seqCount :"</span> + seqCount.nextSeq());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="641.jpeg" alt=""></p><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。这里我们想一个问题，在上面的代码中ThreadLocal的initialValue()方法返回的是0，加入该方法返回得是一个对象呢，会产生什么后果呢？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;A&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;A&gt;()&#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程请参考：对ThreadLocal实现原理的一点思考</p><h1 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h1><p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line"></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href="Java技术之引用类型.md">Java技术之引用类型</a>）</p><p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal key, Object value)方法。</p><p><strong>set(ThreadLocal key, Object value)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 采用“线性探测法”，寻找合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key 存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots 清楚陈旧的Entry（key == null）</span></span><br><span class="line">    <span class="comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; (sz &gt;= threshold)) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考散列冲突处理系列博客）。掌握了开放地址法该方法就一目了然了。</p><p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p><p><strong>getEntry()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> ((e != <span class="keyword">null</span>) &amp;&amp; (e.get() == key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><blockquote><p>返回当前线程所对应的线程变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocal</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取目标值         </span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p><p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h1><blockquote><p>设置当前线程的线程局部变量的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h1><blockquote><p>返回该线程局部变量的初始值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h1><blockquote><p>将当前线程局部变量的值删除。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p><h1 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h1><p>前面提到每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下（图片来自<a href="http://www.jianshu.com/p/ee8c9dccc953）：" target="_blank" rel="noopener">http://www.jianshu.com/p/ee8c9dccc953）：</a></p><p><img src="642.png" alt=""></p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</p><p>那么要怎么避免这个问题呢？</p><p>在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</p><p>下面再对ThreadLocal进行简单的总结：</p><blockquote><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLoacal是什么？&quot;&gt;&lt;a href=&quot;#ThreadLoacal是什么？&quot; class=&quot;headerlink&quot; title=&quot;ThreadLoacal是什么？&quot;&gt;&lt;/a&gt;ThreadLoacal是什么？&lt;/h1&gt;&lt;p&gt;ThreadLocal是啥？
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ThreadLocal" scheme="http://blog.shagle.cn/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock的实现原理</title>
    <link href="http://blog.shagle.cn/2019/02/25/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.shagle.cn/2019/02/25/Java技术之ReentrantReadWriteLock的实现原理/</id>
    <published>2019-02-25T02:42:29.000Z</published>
    <updated>2019-02-25T10:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><strong>ReentrantReadWriteLock支持以下功能：</strong></p><ul><li><p>1）支持公平和非公平的获取锁的方式；</p></li><li><p>2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p></li><li><p>3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</p></li><li><p>4）读取锁和写入锁都支持锁获取期间的中断；</p></li><li><p>5）Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </p></li></ul><h1 id="2-ReadWriteLock接口简单说明"><a href="#2-ReadWriteLock接口简单说明" class="headerlink" title="2. ReadWriteLock接口简单说明"></a>2. ReadWriteLock接口简单说明</h1><p>ReadWriteLock接口只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是Lock接口的实现，可以如同使用Lock接口一样使用（其实也有一些特性是不支持的）。</p><h1 id="3-ReentrantReadWriteLock使用示例"><a href="#3-ReentrantReadWriteLock使用示例" class="headerlink" title="3. ReentrantReadWriteLock使用示例"></a>3. ReentrantReadWriteLock使用示例</h1><p>读写锁的使用并不复杂，可以参考以下使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通重入锁使用的主要区别在于需要使用不同的锁对象引用读写锁，并且在读写时分别调用对应的锁。</p><h1 id="4-ReentrantReadWriteLock锁实现分析"><a href="#4-ReentrantReadWriteLock锁实现分析" class="headerlink" title="4. ReentrantReadWriteLock锁实现分析"></a>4. ReentrantReadWriteLock锁实现分析</h1><p>本节通过学习源码分析可重入读写锁的实现。</p><h2 id="4-1-图解重要函数及对象关系"><a href="#4-1-图解重要函数及对象关系" class="headerlink" title="4.1 图解重要函数及对象关系"></a>4.1 图解重要函数及对象关系</h2><p>根据示例代码可以发现，读写锁需要关注的重点函数为获取读锁及写锁的函数，对于读锁及写锁对象则主要关注加锁和解锁函数，这几个函数及对象关系如下图：<br><img src="3356096377-5b58800bcda35.png" alt=""></p><p>从图中可见读写锁的加锁解锁操作最终都是调用<code>ReentrantReadWriteLock</code>类的内部类<code>Sync</code>提供的方法。与<a href="Java技术之ReentrantLock的实现原理.md">Java技术之ReentrantLock的实现原理</a>一文中描述相似，<code>Sync</code>对象通过继承<code>AbstractQueuedSynchronizer</code>进行实现，故后续分析主要基于<code>Sync</code>类进行。</p><h2 id="4-2-读写锁Sync结构分析"><a href="#4-2-读写锁Sync结构分析" class="headerlink" title="4.2. 读写锁Sync结构分析"></a>4.2. 读写锁Sync结构分析</h2><p><code>Sync</code>继承于<code>AbstractQueuedSynchronizer</code>，其中主要功能均在<code>AbstractQueuedSynchronizer</code>中完成，其中最重要功能为控制线程获取锁失败后转换为等待状态及在满足一定条件后唤醒等待状态的线程。先对<code>AbstractQueuedSynchronizer</code>进行观察。</p><h3 id="4-2-1-AbstractQueuedSynchronizer图解"><a href="#4-2-1-AbstractQueuedSynchronizer图解" class="headerlink" title="4.2.1. AbstractQueuedSynchronizer图解"></a>4.2.1. AbstractQueuedSynchronizer图解</h3><p>为了更好理解<code>AbstractQueuedSynchronizer</code>的运行机制，可以首先研究其内部数据结构，如下图：</p><p><img src="3868270967-5b58800c21220.png" alt=""></p><p>图中展示AQS类较为重要的数据结构，包括<code>int</code>类型变量<code>state</code>用于记录锁的状态，继承自<code>AbstractOwnableSynchronizer</code>类的<code>Thread</code>类型变量<code>exclusiveOwnerThread</code>用于指向当前排他的获取锁的线程，<code>AbstractQueuedSynchronizer.Node</code>类型的变量<code>head</code>及<code>tail</code>。<br>其中<code>Node</code>对象表示当前等待锁的节点，<code>Node</code>中<code>thread</code>变量指向等待的线程，<code>waitStatus</code>表示当前等待节点状态，<code>mode</code>为节点类型。多个节点之间使用<code>prev</code>及<code>next</code>组成双向链表，参考CLH锁队列的方式进行锁的获取，但其中与CLH队列的重要区别在于CLH队列中后续节点需要自旋轮询前节点状态以确定前置节点是否已经释放锁，期间不释放CPU资源，而<code>AQS</code>中<code>Node</code>节点指向的线程在获取锁失败后调用<code>LockSupport.park</code>函数使其进入阻塞状态，让出CPU资源，故在前置节点释放锁时需要调用<code>unparkSuccessor</code>函数唤醒后继节点。<br><strong>根据以上说明可得知此上图图主要表现当前<code>thread0</code>线程获取了锁，<code>thread1</code>线程正在等待。</strong></p><h3 id="4-2-2-读写锁Sync对于AQS使用"><a href="#4-2-2-读写锁Sync对于AQS使用" class="headerlink" title="4.2.2. 读写锁Sync对于AQS使用"></a>4.2.2. 读写锁Sync对于AQS使用</h3><p>读写锁中<code>Sync</code>类是继承于<code>AQS</code>，并且主要使用上文介绍的数据结构中的<code>state</code>及<code>waitStatus</code>变量进行实现。<br>实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。<br><code>Sync</code>使用<code>state</code>变量同时记录读锁与写锁状态，将<code>int</code>类型的<code>state</code>变量分为高16位与第16位，高16位记录读锁状态，低16位记录写锁状态，如下图所示：</p><p><img src="3877233723-5b58800addacf.png" alt=""></p><p><code>Sync</code>使用不同的<code>mode</code>描述等待队列中的节点以区分读锁等待节点和写锁等待节点。<code>mode</code>取值包括<code>SHARED</code>及<code>EXCLUSIVE</code>两种，分别代表当前等待节点为读锁和写锁。</p><h2 id="4-3-读写锁Sync代码过程分析"><a href="#4-3-读写锁Sync代码过程分析" class="headerlink" title="4.3. 读写锁Sync代码过程分析"></a>4.3. 读写锁Sync代码过程分析</h2><h3 id="4-3-1-写锁加锁"><a href="#4-3-1-写锁加锁" class="headerlink" title="4.3.1. 写锁加锁"></a>4.3.1. 写锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquire</code>函数（继承自<code>AQS</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分情况图解分析</p><h4 id="4-3-1-1-无锁状态"><a href="#4-3-1-1-无锁状态" class="headerlink" title="4.3.1.1. 无锁状态"></a>4.3.1.1. 无锁状态</h4><p>无锁状态<code>AQS</code>内部数据结构如下图所示：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>其中<code>state</code>变量为0，表示高位地位地位均为0，没有任何锁，且等待节点的首尾均指向空（此处特指head节点没有初始化时），锁的所有者线程也为空。<br>在无锁状态进行加锁操作，线程调用<code>acquire</code>函数，首先使用<code>tryAcquire</code>函数判断锁是否可获取成功，由于当前是无锁状态必然成功获取锁（如果多个线程同时进入此函数，则有且只有一个线程可调用<code>compareAndSetState</code>成功，其他线程转入获取锁失败的流程）。获取锁成功后<code>AQS</code>状态为：</p><p><img src="1886151432-5b58800ad557b.png" alt=""></p><h4 id="4-3-1-2-有锁状态"><a href="#4-3-1-2-有锁状态" class="headerlink" title="4.3.1.2. 有锁状态"></a>4.3.1.2. 有锁状态</h4><p>在加写锁时如果当前<code>AQS</code>已经是有锁状态，则需要进一步处理。有锁状态主要分为已有写锁和已有读锁状态，并且根据最终当前线程是否可直接获取锁分为两种情况：</p><ul><li><ol><li>非重入：如果满足一下两个条件之一，当前线程必须加入等待队列（暂不考虑非公平锁抢占情况） <ul><li>a. 已有读锁；</li><li>b. 有写锁且获取写锁的线程不为当前请求锁的线程。</li></ul></li></ol></li><li><ol start="2"><li>重入：有写锁且当前获取写锁的线程与当前请求锁的线程为同一线程，则直接获取锁并将写锁状态值加1。</li></ol></li></ul><p>写锁重入状态如图：</p><p><img src="454804165-5b58800ae5824.png" alt=""></p><p>写锁非重入等待状态如图：</p><p><img src="3879161302-5b58800a41983.png" alt=""></p><p>在非重入状态，当前线程创建等待节点追加到等待队列队尾，如果当前头结点为空，则需要创建一个默认的头结点。<br>之后再当前获取锁的线程释放锁后，会唤醒等待中的节点，即为<code>thread1</code>。如果当前等待队列存在多个等待节点，由于<code>thread1</code>等待节点为<code>EXCLUSIVE</code>模式，则只会唤醒当前一个节点，不会传播唤醒信号。</p><h3 id="4-3-2-读锁加锁"><a href="#4-3-2-读锁加锁" class="headerlink" title="4.3.2. 读锁加锁"></a>4.3.2. 读锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquireShared</code>函数（继承自<code>AQS</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上文，现在分情况图解分析</p><h4 id="4-3-2-1-无锁状态"><a href="#4-3-2-1-无锁状态" class="headerlink" title="4.3.2.1. 无锁状态"></a>4.3.2.1. 无锁状态</h4><p>无所状态<code>AQS</code>内部数据状态图与写加锁是无锁状态一致：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>在无锁状态进行加锁操作，线程调用<code>acquireShared</code>函数，首先使用<code>tryAcquireShared</code>函数判断共享锁是否可获取成功，由于当前为无锁状态则获取锁一定成功（如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取，该函数在后文说明）。当前线程获取读锁成功后，<code>AQS</code>内部结构如图所示：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>其中有两个新的变量：<code>firstReader</code>及<code>firstReaderHoldCount</code>。<code>firstReader</code>指向在无锁状态下第一个获取读锁的线程，<code>firstReaderHoldCount</code>记录第一个获取读锁的线程持有当前锁的计数（主要用于重入）。</p><h4 id="4-3-2-2-有锁状态"><a href="#4-3-2-2-有锁状态" class="headerlink" title="4.3.2.2. 有锁状态"></a>4.3.2.2. 有锁状态</h4><p>无锁状态获取读锁比较简单，在有锁状态则需要分情况讨论。其中需要分当前被持有的锁是读锁还是写锁，并且每种情况需要区分等待队列中是否有等待节点。</p><p><strong>已有读锁且等待队列为空</strong><br>此状态比较简单，图示如：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>此时线程申请读锁，首先调用<code>readerShouldBlock</code>函数进行判断，该函数根据当前锁是否为公平锁判断规则稍有不同。如果为非公平锁，则只需要当前第一个等待节点不是写锁就可以尝试获取锁（考虑第一点为写锁主要为了方式写锁“饿死”）；如果是公平锁则只要有等待节点且当前锁不为重入就需要等待。<br>由于本节的前提是等待队列为空的情况，故<code>readerShouldBlock</code>函数一定返回<code>false</code>，则当前线程使用<code>CAS</code>对读锁计数进行增加（同上文，如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取）。<br>在成功对读锁计数器进行增加后，当前线程需要继续对当前线程持有读锁的计数进行增加。此时分为两种情况：</p><ul><li><ol><li>当前线程是第一个获取读锁的线程，此时由于第一个获取读锁的线程已经通过<code>firstReader</code>及<code>firstReaderHoldCount</code>两个变量进行存储，则仅仅需要将<code>firstReaderHoldCount</code>加1即可;</li></ol></li><li><ol start="2"><li>当前线程不是第一个获取读锁的线程，则需要使用<code>readHolds</code>进行存储，<code>readHolds</code>是<code>ThreadLoca</code>l的子类，通过<code>readHolds</code>可获取当前线程对应的<code>HoldCounter</code>类的对象，该对象保存了当前线程获取读锁的计数。考虑程序的局部性原理，又使用<code>cachedHoldCounter</code>缓存最近使用的<code>HoldCounter</code>类的对象，如在一段时间内只有一个线程请求读锁则可加速对读锁获取的计数。</li></ol></li></ul><p>第一个读锁线程重入如图：</p><p><img src="1282819964-5b5880089f6c9.png" alt=""></p><p>非首节点获取读锁</p><p><img src="2489231474-5b5880083f137.png" alt=""></p><p>根据上图所示，<code>thread0</code>为首节点，<code>thread1</code>线程继续申请读锁，获取成功后使用<code>ThreadLocal</code>链接的方式进行存储计数对象，并且由于其为最近获取读锁的线程，则<code>cachedHoldCounter</code>对象设置指向<code>thread1</code>对应的计数对象。</p><p><strong>已有读锁且等待队列不为空</strong></p><p>在当前锁已经被读锁获取，且等待队列不为空的情况下 ，可知等待队列的头结点一定为<strong>写锁获取等待</strong>，这是由于在读写锁实现过程中，如果某线程获取了读锁，则会唤醒当前等到节点之后的所有等待模式为<code>SHARED</code>的节点，直到队尾或遇到<code>EXCLUSIVE</code>模式的等待节点（具体实现函数为<code>setHeadAndPropagate</code>后续还会遇到）。所以可以确定当前为读锁状态其有等待节点情况下，首节点一定是写锁等待。如图所示：</p><p><img src="790767399-5b58800924c87.png" alt=""></p><p>上图展示当前<code>thread0</code>与<code>thread1</code>线程获取读锁，<code>thread0</code>为首个获取读锁的节点，并且<code>thread2</code>线程在等待获取写锁。<br>在上图显示的状态下，无论公平锁还是非公平锁的实现，新的读锁加锁一定会进行排队，添加等待节点在写锁等待节点之后，这样可以防止写操作的饿死。申请读锁后的状态如图所示：</p><p><img src="3433646749-5b58800a4cd7a.png" alt=""></p><p>如图所示，在当前锁被为读锁且有等待队列情况下，<code>thread3</code>及<code>thread4</code>线程申请读锁，则被封装为等待节点追加到当前等待队列后，节点模式为<code>SHARED</code>，线程使用<code>LockSupport.park</code>函数进入阻塞状态，让出CPU资源，直到前驱的等待节点完成锁的获取和释放后进行唤醒。</p><p><strong>已有写锁被获取</strong></p><p>当前线程申请读锁时发现写锁已经被获取，则无论等待队列是否为空，线程一定会需要加入等待队列（注意在非公平锁实现且前序没有写锁申请的等待，线程有机会抢占获取锁而不进入等待队列）。写锁被获取的情况下，<code>AQS</code>状态为如下状态</p><p><img src="3131560188-5b588009a8253.png" alt=""></p><p>在两种情况下，读锁获取都会进入等待队列等待前序节点唤醒，这里不再赘述。</p><h4 id="4-3-2-3-读锁加锁读等待节点被唤醒"><a href="#4-3-2-3-读锁加锁读等待节点被唤醒" class="headerlink" title="4.3.2.3. 读锁加锁读等待节点被唤醒"></a>4.3.2.3. 读锁加锁读等待节点被唤醒</h4><p>读写锁与单纯的排他锁主要区别在于读锁的共享性，在读写锁实现中保证读锁能够共享的其中一个机制就在于，如果一个读锁等待节点被唤醒后其会继续唤醒拍在当前唤醒节点之后的<code>SHARED</code>模式等待节点。查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">   <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">           <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">               <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">               <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//注意看这里</span></span><br><span class="line">                   setHeadAndPropagate(node, r);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   <span class="keyword">if</span> (interrupted)</span><br><span class="line">                       selfInterrupt();</span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">               parkAndCheckInterrupt())</span><br><span class="line">               interrupted = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (failed)</span><br><span class="line">           cancelAcquire(node);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，线程如果获取读锁成功后，需要调用<code>setHeadAndPropagate</code>方法。查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">   Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">   setHead(node);</span><br><span class="line">   <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">       (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">           doReleaseShared();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在满足传播条件情况下，获取读锁后继续唤醒后续节点，所以如果当前锁是读锁状态则等待节点第一个节点一定是写锁等待节点。</p><h4 id="4-3-2-4-锁降级"><a href="#4-3-2-4-锁降级" class="headerlink" title="4.3.2.4. 锁降级"></a>4.3.2.4. 锁降级</h4><p>锁降级算是获取读锁的特例，如在<code>t0</code>线程已经获取写锁的情况下，再调取读锁加锁函数则可以直接获取读锁，但此时其他线程仍然无法获取读锁或写锁，在<code>t0</code>线程释放写锁后，如果有节点等待则会唤醒后续节点，后续节点可见的状态为目前有t0线程获取了读锁。<br>所降级有什么应用场景呢？引用读写锁中使用示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中针对变量<code>cacheValid</code>的使用主要过程为加读锁、读取、释放读锁、加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁。其中后续几步（加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁）为典型的锁降级。如果不使用锁降级，则过程可能有三种情况：</p><ul><li>第一种：加写锁、修改值、释放写锁、使用数据，即使用写锁修改数据后直接使用刚修改的数据，这样可能有数据的不一致，如当前线程释放写锁的同时其他线程（如<code>t0</code>）获取写锁准备修改（还没有改）<code>cacheValid</code>变量，而当前线程却继续运行，则当前线程读到的<code>cacheValid</code>变量的值为<code>t0</code>修改前的老数据；</li><li>第二种：加写锁、修改值、使用数据、释放写锁，即将修改数据与再次使用数据合二为一，这样不会有数据的不一致，但是由于混用了读写两个过程，以排它锁的方式使用读写锁，减弱了读写锁读共享的优势，增加了写锁（独占锁）的占用时间；</li><li>第三种：加写锁、修改值、释放写锁、加读锁、使用数据、释放读锁，即使用写锁修改数据后再请求读锁来使用数据，这是时数据的一致性是可以得到保证的，但是由于释放写锁和获取读锁之间存在时间差，则当前想成可能会需要进入等待队列进行等待，可能造成线程的阻塞降低吞吐量。</li></ul><p>因此针对以上情况提供了锁的降级功能，可以在完成数据修改后尽快读取最新的值，且能够减少写锁占用时间。</p><p>最后注意，读写锁<strong>不支持锁升级</strong>，即获取读锁、读数据、获取写锁、释放读锁、释放写锁这个过程，因为读锁为共享锁，如同时有多个线程获取了读锁后有一个线程进行锁升级获取了写锁，这会造成同时有读锁（其他线程）和写锁的情况，造成其他线程可能无法感知新修改的数据（此为逻辑性错误），并且在JAVA读写锁实现上由于当前线程获取了读锁，再次请求写锁时必然会阻塞而导致后续释放读锁的方法无法执行，这回造成死锁（此为功能性错误）。</p><h3 id="4-3-3-写锁释放锁过程"><a href="#4-3-3-写锁释放锁过程" class="headerlink" title="4.3.3. 写锁释放锁过程"></a>4.3.3. 写锁释放锁过程</h3><p>了解了加锁过程后解锁过程就非常简单，每次调用解锁方法都会减少重入计数次数，直到减为0则唤醒后续第一个等待节点，如唤醒的后续节点为读等待节点，则后续节点会继续传播唤醒状态。</p><h3 id="4-3-4-读锁释放过程"><a href="#4-3-4-读锁释放过程" class="headerlink" title="4.3.4. 读锁释放过程"></a>4.3.4. 读锁释放过程</h3><p>读锁释放过比写锁稍微复杂，因为是共享锁，所以可能会有多个线程同时获取读锁，故在解锁时需要做两件事：</p><ul><li><ol><li>获取当前线程对应的重入计数，并进行减1，此处天生为线程安全的，不需要特殊处理；</li></ol></li><li><ol start="2"><li>当前读锁获取次数减1，此处由于可能存在多线程竞争，故使用自旋CAS进行设置。<br>完成以上两步后，如读状态为0，则唤醒后续等待节点。</li></ol></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>根据以上分析，本文主要展示了读写锁的场景及方式，并分析读写锁核心功能（加解锁）的代码实现。Java读写锁同时附带了更多其他方法，包括锁状态监控和带超时机制的加锁方法等，本文不在赘述。并且读写锁中写锁可使用Conditon机制也不在详细说明。</p><p><a href="https://segmentfault.com/a/1190000015768003#articleHeader3" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ThreadLocal的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8BThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之ThreadLocal的使用/</id>
    <published>2019-02-21T09:21:01.000Z</published>
    <updated>2019-02-21T09:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类ThreadLocal的使用"><a href="#1-类ThreadLocal的使用" class="headerlink" title="1. 类ThreadLocal的使用"></a>1. 类ThreadLocal的使用</h1><p>变量值的共享可以使用<code>public static</code>变量的形式，所有的线程都使用同一个<code>public static</code>变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的类<code>ThreadLocal</code>正是为了解决这样的问题。<br>类<code>ThreadLocal</code>主要解决的就是每个线程绑定自己的值，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><h1 id="2-解决get（）返回null问题"><a href="#2-解决get（）返回null问题" class="headerlink" title="2. 解决get（）返回null问题"></a>2. 解决get（）返回null问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是默认值 第一次get不再为null"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖initialValue（）方法具有初始值。</p><h1 id="3-类InheritableThreadLocal的使用"><a href="#3-类InheritableThreadLocal的使用" class="headerlink" title="3. 类InheritableThreadLocal的使用"></a>3. 类InheritableThreadLocal的使用</h1><p>使用类<code>InheritableThreadLocal</code>可以在子线程中取得父线程继承下来的值。</p><h2 id="3-1-值继承"><a href="#3-1-值继承" class="headerlink" title="3.1 值继承"></a>3.1 值继承</h2><p>使用InheritableThreadLocal类可以让子线程从父线程中取得值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Tools.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tools;</span><br><span class="line"><span class="keyword">import</span> ext.InheritableThreadLocalExt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocalExt tl = <span class="keyword">new</span> InheritableThreadLocalExt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadA.java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"在ThreadA线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"       在Main线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-64所示。</p><p><img src="20190221172614.png" alt=""></p><h1 id="3-2-值继承再修改"><a href="#3-2-值继承再修改" class="headerlink" title="3.2 值继承再修改"></a>3.2 值继承再修改</h1><p>如果在继承的同时还可以对值进行进一步的处理那就更好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">childValue</span><span class="params">(Object parentValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> parentValue + <span class="string">" 我在子线程加的~!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-65所示。</p><p><img src="20190221173005.png" alt=""></p><p>但在使用InheritableThreadLocal类需要注意一点的是，如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的值还是旧值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-类ThreadLocal的使用&quot;&gt;&lt;a href=&quot;#1-类ThreadLocal的使用&quot; class=&quot;headerlink&quot; title=&quot;1. 类ThreadLocal的使用&quot;&gt;&lt;/a&gt;1. 类ThreadLocal的使用&lt;/h1&gt;&lt;p&gt;变量值的共享可以
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="threadLocal" scheme="http://blog.shagle.cn/tags/threadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之join的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8Bjoin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之join的使用/</id>
    <published>2019-02-21T06:28:50.000Z</published>
    <updated>2019-02-21T08:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销毁。</p><h1 id="1-学习方法join前的铺垫"><a href="#1-学习方法join前的铺垫" class="headerlink" title="1. 学习方法join前的铺垫"></a>1. 学习方法join前的铺垫</h1><p>在介绍join方法之前，先来看一个实验。<br>创建测试用的java项目，名称为joinTest1，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">    threadTest.start();</span><br><span class="line">    <span class="comment">// Thread.sleep(?)</span></span><br><span class="line">    System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行"</span>);</span><br><span class="line">    System.out.println(<span class="string">"但上面代码中的sleep()中的值应该写多少呢？"</span>);</span><br><span class="line">    System.out.println(<span class="string">"答案是：根据不能确定:)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-44所示。</p><p><img src="20190221150830.png" alt=""></p><h1 id="2-20190221150830-png"><a href="#2-20190221150830-png" class="headerlink" title="2. 20190221150830.png"></a>2. 20190221150830.png</h1><p>方法join可以解决这个问题。新建java项目joinTest2，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">      threadTest.start();</span><br><span class="line">      threadTest.join();</span><br><span class="line">      System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行，我做到了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的结果如图3-45所示。</p><p><img src="20190221152636.png" alt=""></p><p>方法join的作用是使所属的线程对象x正常执行run（）方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。</p><p>方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait（）方法进行等待，而sychronized关键字使用的是“对象监视器”原理做为同步</p><h1 id="3-方法join与异常"><a href="#3-方法join与异常" class="headerlink" title="3. 方法join与异常"></a>3. 方法join与异常</h1><p>在join过程中，如果当前线程对象被中断，则当前线程出现异常。<br>创建测试用的项目joinException，类ThreadA.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">      String newString = <span class="keyword">new</span> String();</span><br><span class="line">      Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadB.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">      a.join();</span><br><span class="line">      System.out.println(<span class="string">"线程B在run end处打印了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"线程B在catch处打印了"</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadC.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadB threadB;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(ThreadB threadB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.threadB = threadB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadB.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.run;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadC;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">      b.start();</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      ThreadC c = <span class="keyword">new</span> ThreadC(b);</span><br><span class="line">      c.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-46所示。</p><p><img src="20190221154515.png" alt=""></p><p>说明方法join（）与interrupt（）方法如果彼此遇到，则会出现异常。但进程按钮还呈“红色”，原因是线程ThreadA还在继续运行，线程ThreadA并未出现异常，是正常执行的状态。</p><p>方法join（long）中的参数是设定等待的时间。</p><h1 id="4-方法join（long）与sleep（long）的区别"><a href="#4-方法join（long）与sleep（long）的区别" class="headerlink" title="4. 方法join（long）与sleep（long）的区别"></a>4. 方法join（long）与sleep（long）的区别</h1><p>方法join（long）的功能在内部是使用wait（long）方法来实现的，所以join（long）方法具有释放锁的特点。<br>方法join（long）源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码中可以了解到，当执行wait（long）方法后，当前线程的锁被释放，那么其他线程就可以调用此线程中的同步方法了。<br>Thread.sleep（long）方法不释放锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="join" scheme="http://blog.shagle.cn/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之线程通信</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之线程通信/</id>
    <published>2019-02-21T06:04:00.000Z</published>
    <updated>2019-02-21T06:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通过管道进行线程间通信：字节流"><a href="#1-通过管道进行线程间通信：字节流" class="headerlink" title="1. 通过管道进行线程间通信：字节流"></a>1. 通过管道进行线程间通信：字节流</h1><p>在Java语言中提供了各种各样的输入/输出流Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream）是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西。<br>在Java的JDK中提供了4个类来使线程间可以进行通信：</p><ul><li>1）PipedInputStream和PipedOutputStream</li><li>2）PipedReader和PipedWriter<br>创建测试用的项目pipeInputOutput。<br>类WriteData.java代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData.getBytes());</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-37所示：</p><p><img src="20190221140600.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">      PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码inputStream.connect（outputStream）或outputStream.connect（inputStream）的作用使两个Stream之间产生通信链接，这样才可以将数据进行输出与输入。<br>程序运行结果如图3-38所示：</p><p><img src="20190221140753.png" alt=""></p><h1 id="2-通过管道进行线程间通信：字符流"><a href="#2-通过管道进行线程间通信：字符流" class="headerlink" title="2. 通过管道进行线程间通信：字符流"></a>2. 通过管道进行线程间通信：字符流</h1><p>当然，在管道中还可以传递字符流。<br>创建测试用的项目pipeReaderWriter。</p><p>类WriteData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedWriter out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData);</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedReader input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">char</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-39所示：</p><p><img src="20190221141249.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedReader inputStream = <span class="keyword">new</span> PipedReader();</span><br><span class="line">      PipedWriter outputStream = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-40所示：</p><p><img src="20190221141423.png" alt=""></p><p>打印的结果和前一个示例基本一样，此实验是在两个线程中通过管道流进行字符数据的传输。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-通过管道进行线程间通信：字节流&quot;&gt;&lt;a href=&quot;#1-通过管道进行线程间通信：字节流&quot; class=&quot;headerlink&quot; title=&quot;1. 通过管道进行线程间通信：字节流&quot;&gt;&lt;/a&gt;1. 通过管道进行线程间通信：字节流&lt;/h1&gt;&lt;p&gt;在Java语言中
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="线程通信" scheme="http://blog.shagle.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://blog.shagle.cn/2019/01/31/jvm/"/>
    <id>http://blog.shagle.cn/2019/01/31/jvm/</id>
    <published>2019-01-31T05:45:53.000Z</published>
    <updated>2019-02-01T03:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li>在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的</li><li>提供了更大的灵活性，增加了更多的可能性</li><li>Java虚拟机与程序的生命周期</li><li>在如下几种情况下，java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致java虚拟机进程终止 </li></ul></li></ul><h1 id="类的加载，连接与初始化"><a href="#类的加载，连接与初始化" class="headerlink" title="类的加载，连接与初始化"></a>类的加载，连接与初始化</h1><ul><li>加载：查找并加载类的二进制数据</li><li>连接<ul><li>-验证：确保被加载的类的正确性</li><li>-准备：为类的<code>静态变量</code>分配内存，并将其初始化为<code>默认值</code></li><li>-解析：<code>把类中的符号引用转换为直接引用</code></li></ul></li><li><code>初始化：为类的静态变量赋予正确的初始值</code></li><li>使用</li><li>卸载</li><li>Java程序对类的使用方式可以分为两种<ul><li>-主动使用(七种)<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.tet.Test””))</li><li>初始化一个类的子类</li><li>java虚拟机启动时被标明为类的类(java test)</li><li>JDK 1.7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化</li></ul></li><li>-被动使用</li></ul></li><li>所有的Java虚拟机实现必须在每个类或接口被Java程序<code>首次主动使用</code>时才初始化他们</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的&lt;/
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jvm" scheme="http://blog.shagle.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>理解Callable 和 Spring DeferredResult（翻译）</title>
    <link href="http://blog.shagle.cn/2019/01/28/SpringMVC%E5%BC%82%E6%AD%A5/"/>
    <id>http://blog.shagle.cn/2019/01/28/SpringMVC异步/</id>
    <published>2019-01-28T02:37:00.000Z</published>
    <updated>2019-01-28T07:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1-介绍"></a>1-介绍</h1><p>Servlet 3中的异步支持为在另一个线程中处理HTTP请求提供了可能性。当有一个长时间运行的任务时，这是特别有趣的，因为当另一个线程处理这个请求时，容器线程被释放，并且可以继续为其他请求服务。<br>这个主题已经解释了很多次，Spring框架提供的关于这个功能的类似乎有一点混乱——在一个Controller中返回Callable 和 DeferredResult。<br>在这篇文章中，我将实施这两个例子，以显示其差异。<br>这里所显示的所有示例都包括执行一个控制器，该控制器将执行一个长期运行的任务，然后将结果返回给客户机。长时间运行的任务由taskservice处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(<span class="string">"Slow task executed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Task finished"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个web应用是用Spring Boot创建的，我们将执行下面的类来运行我们的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-阻塞的Controller"><a href="#2-阻塞的Controller" class="headerlink" title="2-阻塞的Controller"></a>2-阻塞的Controller</h1><p>在这个例子中，一个请求到达控制器。servlet线程不会被释放，直到长时间运行的方法被执行，我们退出<code>@requestmapping</code>注释的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/block"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        String result = taskService.execute();</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们运行这个例子<a href="http://localhost:8080/block，在日志里我们会发现servlet" target="_blank" rel="noopener">http://localhost:8080/block，在日志里我们会发现servlet</a> request不会被释放，直到长时间的任务执行完（5秒后）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 12:41:11.849  [nio-8080-exec-6] x.s.web.controller.BlockingController    : Request received</span><br><span class="line">2015-07-12 12:41:16.851  [nio-8080-exec-6] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br><span class="line">2015-07-12 12:41:16.851  [nio-8080-exec-6] x.s.web.controller.BlockingController    : Servlet thread released</span><br></pre></td></tr></table></figure><h1 id="3-返回Callable"><a href="#3-返回Callable" class="headerlink" title="3-返回Callable"></a>3-返回Callable</h1><p>在这个例子中，不是直接返回的结果，我们将返回一个Callable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallableController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncCallableController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/callable"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        Callable&lt;String&gt; callable = taskService::execute;</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> callable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回Callable意味着Spring MVC将调用在不同的线程中执行定义的任务。Spring将使用TaskExecutor来管理线程。在等待完成的长期任务之前，servlet线程将被释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 13:07:07.012  [nio-8080-exec-5] x.s.w.c.AsyncCallableController          : Request received</span><br><span class="line">2015-07-12 13:07:07.013  [nio-8080-exec-5] x.s.w.c.AsyncCallableController          : Servlet thread released</span><br><span class="line">2015-07-12 13:07:12.014  [      MvcAsync2] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br></pre></td></tr></table></figure><p>你可以看到我们在长时间运行的任务执行完毕之前就已经从servlet返回了。这并不意味着客户端收到了一个响应。与客户端的通信仍然是开放的等待结果，但接收到的请求的线程已被释放，并可以服务于另一个客户的请求。</p><h1 id="4-返回DeferredResult"><a href="#4-返回DeferredResult" class="headerlink" title="4-返回DeferredResult"></a>4-返回DeferredResult</h1><p>首先，我们需要创建一个deferredresult对象。此对象将由控制器返回。我们将完成和Callable相同的事，当我们在另一个线程处理长时间运行的任务的时候释放servlet线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDeferredController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskService taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncDeferredController</span><span class="params">(TaskService taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/deferred"</span>, method = RequestMethod.GET, produces = <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Request received"</span>);</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">        CompletableFuture.supplyAsync(taskService::execute)</span><br><span class="line">            .whenCompleteAsync((result, throwable) -&gt; deferredResult.setResult(result));</span><br><span class="line">        logger.info(<span class="string">"Servlet thread released"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，返回DeferredResult和返回Callable有什么区别？不同的是这一次线程是由我们管理。创建一个线程并将结果set到DeferredResult是由我们自己来做的。<br>用completablefuture创建一个异步任务。这将创建一个新的线程，在那里我们的长时间运行的任务将被执行。也就是在这个线程中，我们将set结果到DeferredResult并返回。<br>是在哪个线程池中我们取回这个新的线程？默认情况下，在completablefuture的supplyasync方法将在forkjoin池运行任务。如果你想使用一个不同的线程池，你可以通过传一个executor到supplyasync方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>如果我们运行这个例子，我们将得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-07-12 13:28:08.433  [io-8080-exec-10] x.s.w.c.AsyncDeferredController          : Request received</span><br><span class="line">2015-07-12 13:28:08.475  [io-8080-exec-10] x.s.w.c.AsyncDeferredController          : Servlet thread released</span><br><span class="line">2015-07-12 13:28:13.469  [onPool-worker-1] x.spring.web.service.TaskServiceImpl     : Slow task executed</span><br></pre></td></tr></table></figure><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5-结论"></a>5-结论</h1><p><strong>以下是Servlet异步请求处理的简要概述：</strong></p><ul><li><p>A ServletRequest可以通过调用置于异步模式request.startAsync()。这样做的主要作用是Servlet（以及任何过滤器）可以退出，但响应保持打开状态以便稍后处理完成。</p></li><li><p>对request.startAsync()返回的调用AsyncContext，可用于进一步控制异步处理。例如，它提供的dispatch方法类似于Servlet API的转发，但它允许应用程序在Servlet容器线程上恢复请求处理。</p></li><li><p>在ServletRequest提供对电流DispatcherType，它可以使用处理该初始请求，异步调度，正向，以及其他的调度类型之间进行区分。</p></li></ul><p><strong>DeferredResult 处理工作如下：</strong></p><ul><li><p>控制器返回a DeferredResult并将其保存在可以访问它的某个内存中队列或列表中。</p></li><li><p>Spring MVC调用request.startAsync()。</p></li><li><p>同时，DispatcherServlet所有已配置的过滤器都会退出请求处理线程，但响应仍保持打开状态。</p></li><li><p>应用程序DeferredResult从某个线程设置，Spring MVC将请求调度回Servlet容器。</p></li><li><p>将DispatcherServlet被再次调用，并且处理与异步生产返回值恢复。</p></li></ul><p><strong>Callable 处理工作如下：</strong></p><ul><li><p>控制器返回一个Callable。</p></li><li><p>Spring MVC调用request.startAsync()并将其提交Callable到a TaskExecutor以在单独的线程中进行处理。</p></li><li><p>同时，DispatcherServlet所有过滤器都退出Servlet容器线程，但响应仍保持打开状态。</p></li><li><p>最终Callable产生一个结果，Spring MVC将请求发送回Servlet容器以完成处理。</p></li><li><p>将DispatcherServlet被再次调用，并且处理从所述异步生产返回值恢复Callable。</p></li></ul><p><a href="https://docs.spring.io/spring/docs/5.1.4.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">官方文档</a></p><p>站在一定高度来看这问题，Callable和Deferredresult做的是同样的事情——释放容器线程，在另一个线程上异步运行长时间的任务。不同的是谁管理执行任务的线程。</p><p>文中涉及的代码<a href="https://github.com/aheizi/spring-rest" target="_blank" rel="noopener">spring-rest</a></p><p>翻译自<a href="https://xpadro.com/?blogger=http://xpadro.blogspot.com/2015/07/understanding-callable-and-spring.html" target="_blank" rel="noopener">Xavier Padró’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1-介绍&quot;&gt;&lt;/a&gt;1-介绍&lt;/h1&gt;&lt;p&gt;Servlet 3中的异步支持为在另一个线程中处理HTTP请求提供了可能性。当有一个长时间运行的任务时，这是特别有趣的，因为
      
    
    </summary>
    
      <category term="Spring MVC" scheme="http://blog.shagle.cn/categories/Spring-MVC/"/>
    
    
      <category term="异步controller" scheme="http://blog.shagle.cn/tags/%E5%BC%82%E6%AD%A5controller/"/>
    
  </entry>
  
  <entry>
    <title>springMVC与servlet3整合分析</title>
    <link href="http://blog.shagle.cn/2019/01/27/springMVC-servlet3/"/>
    <id>http://blog.shagle.cn/2019/01/27/springMVC-servlet3/</id>
    <published>2019-01-27T08:13:31.000Z</published>
    <updated>2019-01-28T05:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Tomcat对Servlet规范的支持说明</a><br><a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr315/index.html" target="_blank" rel="noopener">Servlet 3.0标准的官方说明文件</a></p><h1 id="一、Servlet3-0"><a href="#一、Servlet3-0" class="headerlink" title="一、Servlet3.0"></a>一、Servlet3.0</h1><p>我们可以知道，Servlet 3.0提供了两个非常重要的功能：<br>Shared libraries（共享库） / runtimes pluggability（运行时插件能力）</p><p>我们总结为以下两点：</p><p><strong>第一点：</strong><br>Servlet容器启动会扫描当前应用里面每一个jar包的ServletContainerInitializer的实现</p><p><strong>第二点：</strong><br>ServletContainerInitializer的实现类，必须要绑定到META-INF/services/javax.servlet.ServletContainerInitializer文件中。并且该文件中的内容就是ServletContainerInitializer实现类的全类名。</p><p><strong>总结</strong>：容器在启动应用的时候，会扫描当前应用每一个jar包里面META-INF/services/javax.servlet.ServletContainerInitializer，指定的实现类，启动并运行这个实现类的方法；利用@HandlesTypes传入感兴趣的类型；</p><p>Demo示例：</p><ol><li>创建web项目后（要选择3.0），在src目录下创建META-INF/services/并新建文件：javax.servlet.ServletContainerInitializer</li><li>新建HelloService接口，HelloService接口的实现类HelloServiceImpl、实现了HelloService的抽象类AbstractHelloService、实现了HelloService的接口HelloServiceExt。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelloService</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloServiceExt</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>新建ServletContainerInitializer实现类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器启动的时候会将@HandlesTypes指定的这个类型下面的子类（实现类，子接口等）传递过来；</span></span><br><span class="line"><span class="comment">//传入感兴趣的类型；</span></span><br><span class="line"><span class="meta">@HandlesTypes</span>(value=&#123;HelloService.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用启动的时候，会运行onStartup方法；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Set&lt;Class&lt;?&gt;&gt; arg0：感兴趣的类型的所有子类型；</span></span><br><span class="line"><span class="comment"> * ServletContext arg1:代表当前Web应用的ServletContext；一个Web应用一个ServletContext；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1）、使用ServletContext注册Web组件（Servlet、Filter、Listener）（可以导入第三方组件）</span></span><br><span class="line"><span class="comment"> * 2）、使用编码的方式，在项目启动的时候给ServletContext里面添加组件；</span></span><br><span class="line"><span class="comment"> * 必须在项目启动的时候来添加；</span></span><br><span class="line"><span class="comment"> * 1）、ServletContainerInitializer得到的ServletContext；</span></span><br><span class="line"><span class="comment"> * 2）、ServletContextListener得到的ServletContext；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; arg0, ServletContext sc)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"感兴趣的类型："</span>);</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; claz : arg0) &#123;</span><br><span class="line">System.out.println(claz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册组件  ServletRegistration  </span></span><br><span class="line">ServletRegistration.Dynamic servlet = sc.addServlet(<span class="string">"userServlet"</span>, <span class="keyword">new</span> UserServlet());</span><br><span class="line"><span class="comment">//配置servlet的映射信息</span></span><br><span class="line">servlet.addMapping(<span class="string">"/user"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册Listener</span></span><br><span class="line">sc.addListener(UserListener.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册Filter  FilterRegistration</span></span><br><span class="line">FilterRegistration.Dynamic filter = sc.addFilter(<span class="string">"userFilter"</span>, UserFilter.class);</span><br><span class="line"><span class="comment">//配置Filter的映射信息</span></span><br><span class="line">filter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), <span class="keyword">true</span>, <span class="string">"/*"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">感兴趣的类型：</span><br><span class="line">class com.my.spring.annotation.service.AbstractHelloService</span><br><span class="line">interface com.my.spring.annotation.service.HelloServiceExt</span><br><span class="line">class com.my.spring.annotation.service.HelloServiceImpl</span><br><span class="line">UserListener...contextInitialized...</span><br><span class="line">......</span><br><span class="line">UserFilter...doFilter...</span><br><span class="line">UserFilter...doFilter...</span><br></pre></td></tr></table></figure><p>Stop服务器后可以监听到，控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息: Stopping service Catalina</span><br><span class="line">UserListener...contextDestroyed...</span><br></pre></td></tr></table></figure><h1 id="二、Servelet3-0与SpringMVC整合分析"><a href="#二、Servelet3-0与SpringMVC整合分析" class="headerlink" title="二、Servelet3.0与SpringMVC整合分析"></a>二、Servelet3.0与SpringMVC整合分析</h1><p><strong>利用注解进行整合时，主要解决的问题是：原来在web.xml中初始化的组件如何在注解版本加载。</strong></p><p>这是下面讲解的主线，一定要抓住这个问题往下看，否则，看着看着很容易找不着北，甚至不知道在干什么。</p><h2 id="1-创建Maven项目，并导入依赖"><a href="#1-创建Maven项目，并导入依赖" class="headerlink" title="1. 创建Maven项目，并导入依赖"></a>1. 创建Maven项目，并导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my.springmvc.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>02-SpringmvcAnnotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webVersion</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">webVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0-alpha-1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-应用启动说明"><a href="#2-应用启动说明" class="headerlink" title="2. 应用启动说明"></a>2. 应用启动说明</h2><p>可以打开依赖包spring-web-xxx.RELEASE.jar下的META-INF/services/javax.servlet.ServletContainerInitializer看一下</p><ol><li><p>web容器在启动的时候，会扫描每个jar包下的META-INF/services/javax.servlet.ServletContainerInitializer</p></li><li><p>加载这个文件指定的类SpringServletContainerInitializer</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes</span>(WebApplicationInitializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line"><span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span><br><span class="line"><span class="comment">// no matter what @HandlesTypes says...</span></span><br><span class="line"><span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">servletContext.log(<span class="string">"No Spring WebApplicationInitializer types detected on classpath"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">servletContext.log(initializers.size() + <span class="string">" Spring WebApplicationInitializers detected on classpath"</span>);</span><br><span class="line">AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line"><span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>spring的应用一启动会加载感兴趣的WebApplicationInitializer接口的下的所有组件；</p></li><li><p>并且为WebApplicationInitializer组件创建对象（组件不是接口，不是抽象类）<br>WebApplicationInitializer有三层抽象类：<br>(1) AbstractContextLoaderInitializer：创建根容器；createRootApplicationContext()；<br>(2) AbstractDispatcherServletInitializer：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个web的ioc容器；createServletApplicationContext();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建了DispatcherServlet；createDispatcherServlet()；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将创建的DispatcherServlet添加到ServletContext中；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getServletMappings();<br>(3) AbstractAnnotationConfigDispatcherServletInitializer：注解方式配置的DispatcherServlet初始化器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个抽象方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建根容器：createRootApplicationContext()，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getRootConfigClasses();传入一个配置类<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建web的ioc容器： createServletApplicationContext();，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取配置类；getServletConfigClasses();// 留给用户自定义实现</p></li></ol><p><strong>Servlet 3.0与SpringMVC整合原理总结：</strong></p><p>以注解方式来启动SpringMVC；只需要继承AbstractAnnotationConfigDispatcherServletInitializer；，并且要实现抽象方法指定DispatcherServlet的配置信息。（会自动将创建的DispatcherServlet添加到ServletContext中；）</p><h1 id="三、Servelet3-0与SpringMVC整合"><a href="#三、Servelet3-0与SpringMVC整合" class="headerlink" title="三、Servelet3.0与SpringMVC整合"></a>三、Servelet3.0与SpringMVC整合</h1><p><a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">Spring官方推荐，两个父子容器的形式：</a></p><p><img src="20190123164923346.png" alt=""></p><ul><li><p>Servlet WebApplicationContext<br>WEB容器，只来扫描Controller、resolvers等与Web组件相关的组件。</p></li><li><p>Root WebApplicationContext<br>根容器，只来扫描业务逻辑组件。</p></li></ul><p>Coding：</p><ol><li>新建AbstractAnnotationConfigDispatcherServletInitializer 的子类 MyWebAppInitializer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.config.RootConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web容器启动的时候创建对象；调用方法来初始化容器以及前端控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根容器的配置类（就类似于Spring的配置文件，以前是利用监听器方式读取配置文件）创建父容器；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取web容器的配置类（相当于以前的SpringMVC配置文件）创建 子容器；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;AppConfig.class&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取DispatcherServlet的映射信息</span></span><br><span class="line"><span class="comment">//  /：拦截所有请求（包括静态资源（xx.js,xx.png）），但是不包括*.jsp；</span></span><br><span class="line"><span class="comment">//  /*：拦截所有请求；连*.jsp页面都拦截；jsp页面是tomcat的jsp引擎解析的；所以，不要写成/*</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建根容器(父容器)和子容器的配置类：RootConfig和AppConfig</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan.Filter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring的容器不扫描controller;父容器(根容器)</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,excludeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan.Filter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewResolverRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.controller.MyFirstInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringMVC只扫描Controller；子容器</span></span><br><span class="line"><span class="comment">//只扫描就必须加useDefaultFilters=false 禁用默认的过滤规则；(排除扫描是不用加的)</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,includeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//默认所有的页面都从 /WEB-INF/ xxx .jsp</span></span><br><span class="line"><span class="comment">//registry.jsp();</span></span><br><span class="line">registry.jsp(<span class="string">"/WEB-INF/views/"</span>, <span class="string">".jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源访问</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> MyFirstInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试用到的Controller：HelloController</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.my.springmvc.annotation.service.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HelloService helloService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">String hello = helloService.sayHello(<span class="string">"tomcat.."</span>);</span><br><span class="line"><span class="keyword">return</span> hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  /WEB-INF/views/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/suc"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试用的Service：HelloService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.springmvc.annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello "</span>+name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行测试</li></ol><h1 id="四、定制与接管SpringMVC"><a href="#四、定制与接管SpringMVC" class="headerlink" title="四、定制与接管SpringMVC"></a>四、定制与接管SpringMVC</h1><p>原来会将所有的配置定义在web.xml文件中，如果用注解定制与接管SpringMVC则分两步：</p><ol><li>@EnableWebMvc:开启SpringMVC定制配置功能；<br>可以加到配置类上。@EnableWebMvc相当于在web.xml中“&lt; mvc:annotation-driven /&gt;”<br>官网上的原版解释如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.11</span>.1. Enable MVC Config</span><br><span class="line">Same in Spring WebFlux</span><br><span class="line"></span><br><span class="line">In Java config use the <span class="meta">@EnableWebMvc</span> annotation:</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">In XML use the &lt;mvc:annotation-driven&gt; element:</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">The above registers a number of Spring MVC infrastructure beans also adapting to dependencies available on the classpath: e.g. payload converters <span class="keyword">for</span> JSON, XML, etc.</span><br></pre></td></tr></table></figure><p>在官网上每一个注解都会有相应的解释和例子。</p><ol start="2"><li>配置组件（视图解析器、视图映射、静态资源映射、拦截器……）<br>官网上表示<code>In Java config implement WebMvcConfigurer interface:</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Validator <span class="title">getValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageCodesResolver <span class="title">getMessageCodesResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果是实现<code>WebMvcConfigurer</code>接口，则需要实现的方法太多，但是我们一般用不了这些方法，所以，可以继承<code>WebMvcConfigurer</code>的一个抽象类<code>WebMvcConfigurerAdapter</code>，这个抽象类已经实现了这些所有的方法（空的而已），所以，我们就可以有目的的进行定制。<br>比如：定制视图解析器、静态资源访问、拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringMVC只扫描Controller；子容器</span></span><br><span class="line"><span class="comment">//useDefaultFilters=false 禁用默认的过滤规则；</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.my.spring.annotation"</span>,includeFilters=&#123;</span><br><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//默认所有的页面都从 /WEB-INF/ xxx .jsp</span></span><br><span class="line"><span class="comment">//registry.jsp();</span></span><br><span class="line">registry.jsp(<span class="string">"/WEB-INF/views/"</span>, <span class="string">".jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源访问</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> MyFirstInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定制化中用到的拦截器定义如下MyFirstInterceptor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标方法运行之前执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"preHandle..."</span>+request.getRequestURI());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标方法执行正确以后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postHandle..."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面响应以后执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"afterCompletion..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的定制方法可以参考官网：<a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-config</a> 其中1.11 MVC Config章节有对每个组件的详细说明。（调用什么方法，相当于之前的什么写法）</p><h1 id="五、Servelet3-0与SpringMVC整合——异步请求"><a href="#五、Servelet3-0与SpringMVC整合——异步请求" class="headerlink" title="五、Servelet3.0与SpringMVC整合——异步请求"></a>五、Servelet3.0与SpringMVC整合——异步请求</h1><h2 id="1-servlet-3-0另外一个重大的更新功能是异步请求"><a href="#1-servlet-3-0另外一个重大的更新功能是异步请求" class="headerlink" title="1. servlet 3.0另外一个重大的更新功能是异步请求"></a>1. servlet 3.0另外一个重大的更新功能是异步请求</h2><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求。<br>即每一次Http请求都由某一个线程从头到尾负责处理。</p><p>如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。即便是像Spring、Struts这样的高层框架也脱离不了这样的桎梏，因为他们都是建立在Servlet之上的。为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</p><p>配置步骤：</p><ol><li>支持异步处理asyncSupported=true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value=<span class="string">"/async"</span>,asyncSupported=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>开启异步模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext startAsync = req.startAsync();</span><br></pre></td></tr></table></figure><p>startAsync 可以设置异步请求的监听器、异步处理的超时时间等等。</p><ol start="3"><li>业务逻辑进行异步处理;开始异步处理</li><li>在start方法中的run方法中获取相应<br>3和4的代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">startAsync.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"副线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">            sayHello();</span><br><span class="line">            startAsync.complete();</span><br><span class="line">            <span class="comment">//获取到异步上下文</span></span><br><span class="line">            AsyncContext asyncContext = req.getAsyncContext();</span><br><span class="line">            <span class="comment">// 4、获取响应</span></span><br><span class="line">            ServletResponse response = asyncContext.getResponse();</span><br><span class="line">            response.getWriter().write(<span class="string">"hello async..."</span>);</span><br><span class="line">            System.out.println(<span class="string">"副线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整的异步Servlet代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(value=<span class="string">"/async"</span>,asyncSupported=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、支持异步处理asyncSupported=true</span></span><br><span class="line"><span class="comment">//2、开启异步模式</span></span><br><span class="line">System.out.println(<span class="string">"主线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">AsyncContext startAsync = req.startAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、业务逻辑进行异步处理;开始异步处理</span></span><br><span class="line">startAsync.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"副线程开始。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">sayHello();</span><br><span class="line">startAsync.complete();</span><br><span class="line"><span class="comment">//获取到异步上下文</span></span><br><span class="line">AsyncContext asyncContext = req.getAsyncContext();</span><br><span class="line"><span class="comment">//4、获取响应</span></span><br><span class="line">ServletResponse response = asyncContext.getResponse();</span><br><span class="line">response.getWriter().write(<span class="string">"hello async..."</span>);</span><br><span class="line">System.out.println(<span class="string">"副线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"主线程结束。。。"</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread()+<span class="string">" processing..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主线程开始。。。Thread[http-nio-8080-exec-2,5,main]==&gt;1548248108792</span><br><span class="line">主线程结束。。。Thread[http-nio-8080-exec-2,5,main]==&gt;1548248108796</span><br><span class="line">副线程开始。。。Thread[http-nio-8080-exec-3,5,main]==&gt;1548248108796</span><br><span class="line">Thread[http-nio-8080-exec-3,5,main] processing...</span><br><span class="line">UserFilter...doFilter...</span><br><span class="line">主线程开始。。。Thread[http-nio-8080-exec-5,5,main]==&gt;1548248112056</span><br><span class="line">主线程结束。。。Thread[http-nio-8080-exec-5,5,main]==&gt;1548248112056</span><br><span class="line">副线程开始。。。Thread[http-nio-8080-exec-6,5,main]==&gt;1548248112056</span><br><span class="line">Thread[http-nio-8080-exec-6,5,main] processing...</span><br></pre></td></tr></table></figure><h2 id="2-Springmvc整合servlet-3-0异步请求功能"><a href="#2-Springmvc整合servlet-3-0异步请求功能" class="headerlink" title="2. Springmvc整合servlet 3.0异步请求功能"></a>2. Springmvc整合servlet 3.0异步请求功能</h2><p><a href="https://docs.spring.io/spring/docs/5.0.12.RELEASE/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Springmvc官网的Async Request说明</a><br>1.6章节Async Requests，该章节有详细的例子和说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Here is a very concise overview of Servlet asynchronous request processing:</span><br><span class="line"></span><br><span class="line">A ServletRequest can be put in asynchronous mode by calling request.startAsync(). The main effect of doing so is that the Servlet, as well as any Filters, can exit but the response will remain open to allow processing to complete later.</span><br><span class="line"></span><br><span class="line">The call to request.startAsync() returns AsyncContext which can be used for further control over async processing. For example it provides the method dispatch, that is similar to a forward from the Servlet API except it allows an application to resume request processing on a Servlet container thread.</span><br><span class="line"></span><br><span class="line">The ServletRequest provides access to the current DispatcherType that can be used to distinguish between processing the initial request, an async dispatch, a forward, and other dispatcher types.</span><br><span class="line"></span><br><span class="line">DeferredResult processing:</span><br><span class="line"></span><br><span class="line">Controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed.</span><br><span class="line"></span><br><span class="line">Spring MVC calls request.startAsync().</span><br><span class="line"></span><br><span class="line">Meanwhile the DispatcherServlet and all configured Filter’s exit the request processing thread but the response remains open.</span><br><span class="line"></span><br><span class="line">The application sets the DeferredResult from some thread and Spring MVC dispatches the request back to the Servlet container.</span><br><span class="line"></span><br><span class="line">The DispatcherServlet is invoked again and processing resumes with the asynchronously produced return value.</span><br><span class="line"></span><br><span class="line">Callable processing:</span><br><span class="line"></span><br><span class="line">Controller returns a Callable.</span><br><span class="line"></span><br><span class="line">Spring MVC calls request.startAsync() and submits the Callable to a TaskExecutor for processing in a separate thread.</span><br><span class="line"></span><br><span class="line">Meanwhile the DispatcherServlet and all Filter’s exit the Servlet container thread but the response remains open.</span><br><span class="line"></span><br><span class="line">Eventually the Callable produces a result and Spring MVC dispatches the request back to the Servlet container to complete processing.</span><br><span class="line"></span><br><span class="line">The DispatcherServlet is invoked again and processing resumes with the asynchronously produced return value from the Callable.</span><br></pre></td></tr></table></figure><p>上面英文的意思如下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/createOrder"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;Object&gt; <span class="title">createOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">DeferredResult&lt;Object&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;((<span class="keyword">long</span>)<span class="number">3000</span>, <span class="string">"create fail..."</span>);</span><br><span class="line"></span><br><span class="line">DeferredResultQueue.save(deferredResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/create"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建订单</span></span><br><span class="line">String order = UUID.randomUUID().toString();</span><br><span class="line">DeferredResult&lt;Object&gt; deferredResult = DeferredResultQueue.get();</span><br><span class="line">deferredResult.setResult(order);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success===&gt;"</span>+order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、控制器返回Callable</span></span><br><span class="line"><span class="comment"> * 2、Spring异步处理，将Callable 提交到 TaskExecutor 使用一个隔离的线程进行执行</span></span><br><span class="line"><span class="comment"> * 3、DispatcherServlet和所有的Filter退出web容器的线程，但是response 保持打开状态；</span></span><br><span class="line"><span class="comment"> * 4、Callable返回结果，SpringMVC将请求重新派发给容器，恢复之前的处理；</span></span><br><span class="line"><span class="comment"> * 5、根据Callable返回的结果。SpringMVC继续进行视图渲染流程等（从收请求-视图渲染）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * preHandle.../springmvc-annotation/async01</span></span><br><span class="line"><span class="comment">主线程开始...Thread[http-bio-8081-exec-3,5,main]==&gt;1513932494700</span></span><br><span class="line"><span class="comment">主线程结束...Thread[http-bio-8081-exec-3,5,main]==&gt;1513932494700</span></span><br><span class="line"><span class="comment">=========DispatcherServlet及所有的Filter退出线程============================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================等待Callable执行==========</span></span><br><span class="line"><span class="comment">副线程开始...Thread[MvcAsync1,5,main]==&gt;1513932494707</span></span><br><span class="line"><span class="comment">副线程开始...Thread[MvcAsync1,5,main]==&gt;1513932496708</span></span><br><span class="line"><span class="comment">================Callable执行完成==========</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">================再次收到之前重发过来的请求========</span></span><br><span class="line"><span class="comment">preHandle.../springmvc-annotation/async01</span></span><br><span class="line"><span class="comment">postHandle...（Callable的之前的返回值就是目标方法的返回值）</span></span><br><span class="line"><span class="comment">afterCompletion...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">异步的拦截器:</span></span><br><span class="line"><span class="comment">1）、原生API的AsyncListener</span></span><br><span class="line"><span class="comment">2）、SpringMVC：实现AsyncHandlerInterceptor；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/async01"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">async01</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"主线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"副线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">"副线程开始..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Callable&lt;String&gt; async01()"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"主线程结束..."</span>+Thread.currentThread()+<span class="string">"==&gt;"</span>+System.currentTimeMillis());</span><br><span class="line"><span class="keyword">return</span> callable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>Springmvc对异步请求主要分为两种：返回Callable和返回DeferredResult。</p><ol><li>返回Callable：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A controller may also wrap any supported <span class="keyword">return</span> value with java.util.concurrent.Callable:</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">processUpload</span><span class="params">(<span class="keyword">final</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"someView"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">The <span class="keyword">return</span> value will then be obtained by executing the the given task through the configured TaskExecutor.</span><br></pre></td></tr></table></figure><p>在实际的开发中，一般不会像返回Callable这么简单，一般都会用到返回DeferredResult。</p><ol start="2"><li>返回DeferredResult</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Once the asynchronous request processing feature is enabled in the Servlet container, controller methods can wrap any supported controller method <span class="keyword">return</span> value with DeferredResult:</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/quotes"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">quotes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From some other thread...</span></span><br><span class="line">deferredResult.setResult(data);</span><br><span class="line">The controller can produce the <span class="keyword">return</span> value asynchronously, from a different thread, <span class="function"><span class="keyword">for</span> example in response to an external <span class="title">event</span> <span class="params">(JMS message)</span>, a scheduled task, or other.</span></span><br></pre></td></tr></table></figure><p>上面官网的意思是：当请求不能得到及时响应时，先new DeferredResult();并立刻返回，并把这个对象保存到其他的地方。另外一个线程拿到这个对象后，进行真正的处理，处理完成后，通过调用setResult(data)方法，将结果响应出去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/whichversion.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tomcat对Servlet规范的支持说明&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://jcp.org
      
    
    </summary>
    
      <category term="servlet3.0" scheme="http://blog.shagle.cn/categories/servlet3-0/"/>
    
      <category term="spring mvc" scheme="http://blog.shagle.cn/categories/servlet3-0/spring-mvc/"/>
    
    
      <category term="servlet3.0" scheme="http://blog.shagle.cn/tags/servlet3-0/"/>
    
      <category term="spring mvc" scheme="http://blog.shagle.cn/tags/spring-mvc/"/>
    
  </entry>
  
  <entry>
    <title>Servlet 3.0 新特性概述</title>
    <link href="http://blog.shagle.cn/2019/01/25/servlet3/"/>
    <id>http://blog.shagle.cn/2019/01/25/servlet3/</id>
    <published>2019-01-25T14:41:21.000Z</published>
    <updated>2019-01-25T15:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet 3.0 作为 Java EE 6 规范体系中一员，随着 Java EE 6 规范一起发布。该版本在前一版本（Servlet 2.5）的基础上提供了若干新特性用于简化 Web 应用的开发和部署。其中有几项特性的引入让开发者感到非常兴奋，同时也获得了 Java 社区的一片赞誉之声：</p><ol><li>异步处理支持：有了该特性，Servlet 线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该 Servlet 线程。在接收到请求之后，Servlet 线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。</li><li>新增的注解支持：该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。</li><li>可插性支持：熟悉 Struts2 的开发者一定会对其通过插件的方式与包括 Spring 在内的各种常用框架的整合特性记忆犹新。将相应的插件封装成 JAR 包并放在类路径下，Struts2 运行时便能自动加载这些插件。现在 Servlet 3.0 提供了类似的特性，开发者可以通过插件的方式很方便的扩充已有 Web 应用的功能，而不需要修改原有的应用。<br>下面我们将逐一讲解这些新特性，通过下面的学习，读者将能够明晰了解 Servlet 3.0 的变化，并能够顺利使用它进行日常的开发工作。</li></ol><h1 id="异步处理支持"><a href="#异步处理支持" class="headerlink" title="异步处理支持"></a>异步处理支持</h1><p>Servlet 3.0 之前，一个普通 Servlet 的主要工作流程大致如下：首先，Servlet 接收到请求之后，可能需要对请求携带的数据进行一些预处理；接着，调用业务接口的某些方法，以完成业务处理；最后，根据处理的结果提交响应，Servlet 线程结束。其中第二步的业务处理通常是最耗时的，这主要体现在数据库操作，以及其它的跨网络调用等，在此过程中，Servlet 线程一直处于阻塞状态，直到业务方法执行完毕。在处理业务的过程中，Servlet 资源一直被占用而得不到释放，对于并发较大的应用，这有可能造成性能的瓶颈。对此，在以前通常是采用私有解决方案来提前结束 Servlet 线程，并及时释放资源。</p><p>Servlet 3.0 针对这个问题做了开创性的工作，现在通过使用 Servlet 3.0 的异步处理支持，之前的 Servlet 处理流程可以调整为如下的过程：首先，Servlet 接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；接着，Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。如此一来， Servlet 线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回。</p><p>异步处理特性可以应用于 Servlet 和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet 和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下的方式启用：</p><ol><li>对于使用传统的部署描述文件 (web.xml) 配置 Servlet 和过滤器的情况，Servlet 3.0 为 <servlet> 和 <filter> 标签增加了 <async-supported> 子标签，该标签的默认取值为 false，要启用异步处理支持，则将其设为 true 即可。以 Servlet 为例，其配置方式如下所示：</async-supported></filter></servlet></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>footmark.servlet.Demo Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对于使用 Servlet 3.0 提供的 @WebServlet 和 @WebFilter 进行 Servlet 或过滤器配置的情况，这两个注解都提供了 asyncSupported 属性，默认该属性的取值为 false，要启用异步处理支持，只需将该属性设置为 true 即可。以 @WebFilter 为例，其配置方式如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/demo"</span>,asyncSupported = <span class="keyword">true</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>一个简单的模拟异步处理的 Servlet 示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/demo"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDemoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(<span class="string">"进入Servlet的时间："</span> + <span class="keyword">new</span> Date() + <span class="string">"."</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在子线程中执行业务调用，并由其负责输出响应，主线程退出</span></span><br><span class="line">        AsyncContext ctx = req.startAsync();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Executor(ctx)).start();</span><br><span class="line"> </span><br><span class="line">        out.println(<span class="string">"结束Servlet的时间："</span> + <span class="keyword">new</span> Date() + <span class="string">"."</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsyncContext ctx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Executor</span><span class="params">(AsyncContext ctx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待十秒钟，以模拟业务方法的执行</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            PrintWriter out = ctx.getResponse().getWriter();</span><br><span class="line">            out.println(<span class="string">"业务处理完毕的时间："</span> + <span class="keyword">new</span> Date() + <span class="string">"."</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            ctx.complete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Servlet 3.0 还为异步处理提供了一个监听器，使用 AsyncListener 接口表示。它可以监控如下四种事件：</p><ol><li>异步线程开始时，调用 AsyncListener 的 onStartAsync(AsyncEvent event) 方法；</li><li>异步线程出错时，调用 AsyncListener 的 onError(AsyncEvent event) 方法；</li><li>异步线程执行超时，则调用 AsyncListener 的 onTimeout(AsyncEvent event) 方法；</li><li>异步执行完毕时，调用 AsyncListener 的 onComplete(AsyncEvent event) 方法；</li></ol><p>要注册一个 AsyncListener，只需将准备好的 AsyncListener 对象传递给 AsyncContext 对象的 addListener() 方法即可，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext ctx = req.startAsync(); </span><br><span class="line">ctx.addListener(<span class="keyword">new</span> AsyncListener() &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent asyncEvent)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="comment">// 做一些清理工作或者其他</span></span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="新增的注解支持"><a href="#新增的注解支持" class="headerlink" title="新增的注解支持"></a>新增的注解支持</h1><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 <web-app> 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 可插性支持的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</web-app></p><h2 id="WebServlet"><a href="#WebServlet" class="headerlink" title="@WebServlet"></a>@WebServlet</h2><p>@WebServlet 用于将一个类声明为 Servlet，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet。该注解具有下表给出的一些常用属性（以下所有属性均为可选属性，但是 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存，如果同时指定，通常是忽略 value 的取值）：<br>表 1. @WebServlet 主要属性列表</p><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">name</td><td style="text-align:left">String</td><td style="text-align:left">指定 Servlet 的 name 属性，等价于 <servlet-name>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。</servlet-name></td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">String[]</td><td style="text-align:left">该属性等价于 urlPatterns 属性。两个属性不能同时使用。</td></tr><tr><td style="text-align:left">urlPatterns</td><td style="text-align:left">String[]</td><td style="text-align:left">指定一组 Servlet 的 URL 匹配模式。等价于 <url-pattern> 标签。</url-pattern></td></tr><tr><td style="text-align:left">loadOnStartup</td><td style="text-align:left">int</td><td style="text-align:left">指定 Servlet 的加载顺序，等价于 <load-on-startup> 标签。</load-on-startup></td></tr><tr><td style="text-align:left">initParams</td><td style="text-align:left">WebInitParam[]</td><td style="text-align:left">指定一组 Servlet 初始化参数，等价于 <init-param> 标签。</init-param></td></tr><tr><td style="text-align:left">asyncSupported</td><td style="text-align:left">boolean</td><td style="text-align:left">声明 Servlet 是否支持异步操作模式，等价于 <async-supported> 标签。</async-supported></td></tr><tr><td style="text-align:left">description</td><td style="text-align:left">String</td><td style="text-align:left">该 Servlet 的描述信息，等价于 <description> 标签。</description></td></tr><tr><td style="text-align:left">displayName</td><td style="text-align:left">String</td><td style="text-align:left">该 Servlet 的显示名，通常配合工具使用，等价于 <display-name> 标签。</display-name></td></tr></tbody></table><p>下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = &#123;<span class="string">"/simple"</span>&#125;, asyncSupported = <span class="keyword">true</span>, </span><br><span class="line">loadOnStartup = -<span class="number">1</span>, name = <span class="string">"SimpleServlet"</span>, displayName = <span class="string">"ss"</span>, </span><br><span class="line">initParams = &#123;<span class="meta">@WebInitParam</span>(name = <span class="string">"username"</span>, value = <span class="string">"tom"</span>)&#125; </span><br><span class="line">) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123; … &#125;</span><br></pre></td></tr></table></figure><p>如此配置之后，就可以不必在 web.xml 中配置相应的 <servlet> 和 <servlet-mapping> 元素了，容器会在部署时根据指定的属性将该类发布为 Servlet。它的等价的 web.xml 配置形式如下：</servlet-mapping></servlet></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>ss<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>footmark.servlet.SimpleServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/simple<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WebInitParam"><a href="#WebInitParam" class="headerlink" title="@WebInitParam"></a>@WebInitParam</h2><p>该注解通常不单独使用，而是配合 @WebServlet 或者 @WebFilter 使用。它的作用是为 Servlet 或者过滤器指定初始化参数，这等价于 web.xml 中 <servlet> 和 <filter> 的 <init-param> 子标签。@WebInitParam 具有下表给出的一些常用属性：<br>表 2. @WebInitParam 的常用属性</init-param></filter></servlet></p><p>|属性名|    类型|    是否可选|    描述|<br>|name|    String|    否|    指定参数的名字，等价于 <param-name>。|<br>|value|    String|    否|    指定参数的值，等价于 <param-value>。|<br>|description|    String|    是|    关于参数的描述，等价于 <description>。|</description></param-value></param-name></p><h2 id="WebFilter"><a href="#WebFilter" class="headerlink" title="@WebFilter"></a>@WebFilter</h2><p>@WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )：<br>表 3. @WebFilter 的常用属性</p><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">filterName</td><td style="text-align:left">String</td><td style="text-align:left">指定过滤器的 name 属性，等价于 <filter-name></filter-name></td></tr><tr><td style="text-align:left">value    String[]</td><td style="text-align:left">该属性等价于 urlPatterns 属性。但是两者不应该同时使用。</td></tr><tr><td style="text-align:left">urlPatterns</td><td style="text-align:left">String[]</td><td style="text-align:left">指定一组过滤器的 URL 匹配模式。等价于 <url-pattern> 标签。</url-pattern></td></tr><tr><td style="text-align:left">servletNames</td><td style="text-align:left">String[]</td><td style="text-align:left">指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 <servlet-name> 的取值。</servlet-name></td></tr><tr><td style="text-align:left">dispatcherTypes</td><td style="text-align:left">DispatcherType</td><td style="text-align:left">指定过滤器的转发模式。具体取值包括：ASYNC、ERROR、FORWARD、INCLUDE、REQUEST。</td></tr><tr><td style="text-align:left">initParams</td><td style="text-align:left">WebInitParam[]</td><td style="text-align:left">指定一组过滤器初始化参数，等价于 <init-param> 标签。</init-param></td></tr><tr><td style="text-align:left">asyncSupported</td><td style="text-align:left">boolean</td><td style="text-align:left">声明过滤器是否支持异步操作模式，等价于 <async-supported> 标签。</async-supported></td></tr><tr><td style="text-align:left">description</td><td style="text-align:left">String</td><td style="text-align:left">该过滤器的描述信息，等价于 <description> 标签。</description></td></tr><tr><td style="text-align:left">displayName</td><td style="text-align:left">String</td><td style="text-align:left">该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签。</display-name></td></tr></tbody></table><p>下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(servletNames = &#123;<span class="string">"SimpleServlet"</span>&#125;,filterName=<span class="string">"SimpleFilter"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LessThanSixFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>如此配置之后，就可以不必在 web.xml 中配置相应的 <filter> 和 <filter-mapping> 元素了，容器会在部署时根据指定的属性将该类发布为过滤器。它等价的 web.xml 中的配置形式为：</filter-mapping></filter></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SimpleFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SimpleFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WebListener"><a href="#WebListener" class="headerlink" title="@WebListener"></a>@WebListener</h2><p>该注解用于将类声明为监听器，被 @WebListener 标注的类必须实现以下至少一个接口：</p><ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li><li>HttpSessionListener</li><li>HttpSessionAttributeListener<br>该注解使用非常简单，其属性如下：<br>表 4. @WebListener 的常用属性</li></ul><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">类型</th><th style="text-align:left">是否可选</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">value</td><td style="text-align:left">String</td><td style="text-align:left">是</td><td style="text-align:left">该监听器的描述信息。</td></tr></tbody></table><p>一个简单示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span>(<span class="string">"This is only a demo listener"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>如此，则不需要在 web.xml 中配置 <listener> 标签了。它等价的 web.xml 中的配置形式如下：</listener></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>footmark.servlet.SimpleListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MultipartConfig"><a href="#MultipartConfig" class="headerlink" title="@MultipartConfig"></a>@MultipartConfig</h2><p>该注解主要是为了辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持。该注解标注在 Servlet 上面，以表示该 Servlet 希望处理的请求的 MIME 类型是 multipart/form-data。另外，它还提供了若干属性用于简化对上传文件的处理。具体如下：<br>表 5. @MultipartConfig 的常用属性</p><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">类型</th><th style="text-align:left">是否可选</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">fileSizeThreshold</td><td style="text-align:left">int</td><td style="text-align:left">是</td><td style="text-align:left">当数据量大于该值时，内容将被写入文件。</td></tr><tr><td style="text-align:left">location</td><td style="text-align:left">String</td><td style="text-align:left">是</td><td style="text-align:left">存放生成的文件地址。</td></tr><tr><td style="text-align:left">maxFileSize</td><td style="text-align:left">long</td><td style="text-align:left">是</td><td style="text-align:left">允许上传的文件最大值。默认值为 -1，表示没有限制。</td></tr><tr><td style="text-align:left">maxRequestSize</td><td style="text-align:left">long</td><td style="text-align:left">是</td><td style="text-align:left">针对该 multipart/form-data 请求的最大数量，默认值为 -1，表示没有限制。</td></tr></tbody></table><h1 id="可插性支持"><a href="#可插性支持" class="headerlink" title="可插性支持"></a>可插性支持</h1><p>如果说 3.0 版本新增的注解支持是为了简化 Servlet/ 过滤器 / 监听器的声明，从而使得 web.xml 变为可选配置， 那么新增的可插性 (pluggability) 支持则将 Servlet 配置的灵活性提升到了新的高度。熟悉 Struts2 的开发者都知道，Struts2 通过插件的形式提供了对包括 Spring 在内的各种开发框架的支持，开发者甚至可以自己为 Struts2 开发插件，而 Servlet 的可插性支持正是基于这样的理念而产生的。使用该特性，现在我们可以在不修改已有 Web 应用的前提下，只需将按照一定格式打成的 JAR 包放到 WEB-INF/lib 目录下，即可实现新功能的扩充，不需要额外的配置。</p><p>Servlet 3.0 引入了称之为“Web 模块部署描述符片段”的 web-fragment.xml 部署描述文件，该文件必须存放在 JAR 文件的 META-INF 目录下，该部署描述文件可以包含一切可以在 web.xml 中定义的内容。JAR 包通常放在 WEB-INF/lib 目录下，除此之外，所有该模块使用的资源，包括 class 文件、配置文件等，只需要能够被容器的类加载器链加载的路径上，比如 classes 目录等。</p><p>现在，为一个 Web 应用增加一个 Servlet 配置有如下三种方式 ( 过滤器、监听器与 Servlet 三者的配置都是等价的，故在此以 Servlet 配置为例进行讲述，过滤器和监听器具有与之非常类似的特性 )：</p><ul><li>编写一个类继承自 HttpServlet，将该类放在 classes 目录下的对应包结构中，修改 web.xml，在其中增加一个 Servlet 声明。这是最原始的方式；</li><li>编写一个类继承自 HttpServlet，并且在该类上使用 @WebServlet 注解将该类声明为 Servlet，将该类放在 classes 目录下的对应包结构中，无需修改 web.xml 文件。</li><li>编写一个类继承自 HttpServlet，将该类打成 JAR 包，并且在 JAR 包的 META-INF 目录下放置一个 web-fragment.xml 文件，该文件中声明了相应的 Servlet 配置。web-fragment.xml 文件示例如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">version</span>=<span class="string">"3.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>footmark.servlet.FragmentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/fragment<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面的示例可以看出，web-fragment.xml 与 web.xml 除了在头部声明的 XSD 引用不同之外，其主体配置与 web.xml 是完全一致的。</p><p>由于一个 Web 应用中可以出现多个 web-fragment.xml 声明文件，加上一个 web.xml 文件，加载顺序问题便成了不得不面对的问题。Servlet 规范的专家组在设计的时候已经考虑到了这个问题，并定义了加载顺序的规则。</p><p>web-fragment.xml 包含了两个可选的顶层标签，<name> 和 <ordering>，如果希望为当前的文件指定明确的加载顺序，通常需要使用这两个标签，<name> 主要用于标识当前的文件，而 <ordering> 则用于指定先后顺序。一个简单的示例如下：</ordering></name></ordering></name></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-fragment...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>FragmentA<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ordering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">after</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>FragmentB<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>FragmentC<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">others</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ordering</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所示， <name> 标签的取值通常是被其它 web-fragment.xml 文件在定义先后顺序时引用的，在当前文件中一般用不着，它起着标识当前文件的作用。</name></p><p>在 <ordering> 标签内部，我们可以定义当前 web-fragment.xml 文件与其他文件的相对位置关系，这主要通过 <ordering> 的 <after> 和 <before> 子标签来实现的。在这两个子标签内部可以通过 <name> 标签来指定相对应的文件。比如：</name></before></after></ordering></ordering></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">after</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>FragmentB<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>FragmentC<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">after</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上片段则表示当前文件必须在 FragmentB 和 FragmentC 之后解析。<before> 的使用于此相同，它所表示的是当前文件必须早于 <before> 标签里所列出的 web-fragment.xml 文件。</before></before></p><p>除了将所比较的文件通过 <name> 在 <after> 和 <begin> 中列出之外，Servlet 还提供了一个简化的标签 <others>。它表示除了当前文件之外的其他所有的 web-fragment.xml 文件。该标签的优先级要低于使用 <name> 明确指定的相对位置关系。</name></others></begin></after></name></p><p>除了以上的新特性之外，ServletContext 对象的功能在新版本中也得到了增强。现在，该对象支持在运行时动态部署 Servlet、过滤器、监听器，以及为 Servlet 和过滤器增加 URL 映射等。以 Servlet 为例，过滤器与监听器与之类似。ServletContext 为动态配置 Servlet 增加了如下方法：</p><ul><li>ServletRegistration.Dynamic addServlet(String servletName,Class&lt;? extends Servlet&gt; servletClass)</li><li>ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)</li><li>ServletRegistration.Dynamic addServlet(String servletName, String className)</li><li><t extends="" servlet=""> T createServlet(Class<t> clazz)</t></t></li><li>ServletRegistration getServletRegistration(String servletName)</li><li>Map&lt;String,? extends ServletRegistration&gt; getServletRegistrations()</li></ul><p>其中前三个方法的作用是相同的，只是参数类型不同而已；通过 createServlet() 方法创建的 Servlet，通常需要做一些自定义的配置，然后使用 addServlet() 方法来将其动态注册为一个可以用于服务的 Servlet。两个 getServletRegistration() 方法主要用于动态为 Servlet 增加映射信息，这等价于在 web.xml( 抑或 web-fragment.xml) 中使用 <servlet-mapping> 标签为存在的 Servlet 增加映射信息。</servlet-mapping></p><p>以上 ServletContext 新增的方法要么是在 ServletContextListener 的 contexInitialized 方法中调用，要么是在 ServletContainerInitializer 的 onStartup() 方法中调用。</p><p>ServletContainerInitializer 也是 Servlet 3.0 新增的一个接口，容器在启动时使用 JAR 服务 API(JAR Service API) 来发现 ServletContainerInitializer 的实现类，并且容器将 WEB-INF/lib 目录下 JAR 包中的类都交给该类的 onStartup() 方法处理，我们通常需要在该实现类上使用 @HandlesTypes 注解来指定希望被处理的类，过滤掉不希望给 onStartup() 处理的类。</p><h1 id="HttpServletRequest-对文件上传的支持"><a href="#HttpServletRequest-对文件上传的支持" class="headerlink" title="HttpServletRequest 对文件上传的支持"></a>HttpServletRequest 对文件上传的支持</h1><p>此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为 Servlet 本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件：</p><ul><li>Part getPart(String name)</li><li>Collection<part> getParts()</part></li></ul><p>前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Part photo = request.getPart(<span class="string">"photo"</span>); </span><br><span class="line">photo.write(<span class="string">"/tmp/photo.jpg"</span>); </span><br><span class="line"><span class="comment">// 可以将两行代码简化为 request.getPart("photo").write("/tmp/photo.jpg") 一行。</span></span><br></pre></td></tr></table></figure><p>另外，开发者可以配合前面提到的 @MultipartConfig 注解来对上传操作进行一些自定义的配置，比如限制上传文件的大小，以及保存文件的路径等。其用法非常简单，故不在此赘述了。</p><p>需要注意的是，如果请求的 MIME 类型不是 multipart/form-data，则不能使用上面的两个方法，否则将抛异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Servlet 3.0 的众多新特性使得 Servlet 开发变得更加简单，尤其是异步处理特性和可插性支持的出现，必将对现有的 MVC 框架产生深远影响。虽然我们通常不会自己去用 Servlet 编写控制层代码，但是也许在下一个版本的 Struts 中，您就能切实感受到这些新特性带来的实质性改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Servlet 3.0 作为 Java EE 6 规范体系中一员，随着 Java EE 6 规范一起发布。该版本在前一版本（Servlet 2.5）的基础上提供了若干新特性用于简化 Web 应用的开发和部署。其中有几项特性的引入让开发者感到非常兴奋，同时也获得了 Java 
      
    
    </summary>
    
      <category term="servlet" scheme="http://blog.shagle.cn/categories/servlet/"/>
    
    
      <category term="servlet3.0" scheme="http://blog.shagle.cn/tags/servlet3-0/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC介绍</title>
    <link href="http://blog.shagle.cn/2019/01/21/Sharding-JDBC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.shagle.cn/2019/01/21/Sharding-JDBC介绍/</id>
    <published>2019-01-21T09:37:31.000Z</published>
    <updated>2019-01-21T10:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>背景关系型数据库在大于一定数据量的情况下性能会急剧下降。在面对互联网海量数据的情况时,所有数据都存于一张表,显然很容易会达到数据表可承受的数据量阈值。单纯分表虽然可以解决数据量过大导致检索变慢的问题,但无法解决高并发情况下访问同一个库,导致数据库响应变慢的问题。所以通常水平拆分都至少要采用分库的方式,以一并解决大数据量&amp;;高并发的问题。但分表也有不可替代的…<br><a id="more"></a></p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>关系型数据库在大于一定数据量的情况下性能会急剧下降。在面对互联网海量数据的情况时,所有数据都存于一张表,显然很容易会达到数据表可承受的数据量阈值。<br>单纯分表虽然可以解决数据量过大导致检索变慢的问题,但无法解决高并发情况下访问同一个库,导致数据库响应变慢的问题。所以通常水平拆分都至少要采用分库的方式,以一并解决大数据量&amp;;高并发的问题。<br>但分表也有不可替代的场景。最常见的分表需求是事务问题。同一个库则不需要考虑分布式事务问题,善于使用同库不同表可有效的避免分布式事务带来的麻烦。目前,强一致性的分布式事务由于性能问题,导致使用起来性能并不一定会比不分库分表快,因此采用最终一致性的分布式事务居多。 </p><h1 id="2-分库分表"><a href="#2-分库分表" class="headerlink" title="2. 分库分表"></a>2. 分库分表</h1><p>分库分表用于应对当前互联网常见的两个场景:大数据量 &amp;; 高并发。通常分为:垂直拆分 &amp;; 水平拆分。 垂直拆分是根据业务将一个库(表)拆分为多个库(表)。如:将经常和不经常访问的字段拆分至不同的库(表)中,与业务关系密切。 水平拆分是根据分片算法将一个库(表)拆分为多个库(表)。</p><h1 id="3-Sharding-JDBC"><a href="#3-Sharding-JDBC" class="headerlink" title="3. Sharding-JDBC"></a>3. Sharding-JDBC</h1><p>Sharding-JDBC是当当应用框架ddframe中,从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架,是继dubbox、elastic-job之后ddframe开源的第三个项目。</p><p>Sharding-JDBC直接分装jdbc协议,可理解为增强版的JDBC驱动,旧代码迁移成本几乎为零,定位为轻量级java框架,使用客户端直连数据库,以jar包形式提供服务,无proxy层。</p><p>主要包括以下特点:</p><ul><li>可适用于任何基于java的ORM框架,如:JPA、Hibernate、Mybatis、Spring JDBC Template,或直接使用JDBC </li><li>可基于任何第三方的数据库连接池,如:DBCP、C3P0、Durid等 </li><li>理论上可支持任意实现JDBC规范的数据库。目前仅支持mysql </li><li>分片策略灵活,可支持等号、between、in等多维度分片,也可支持多分片键。 </li><li>SQL解析功能完善,支持聚合、分组、排序、limit、or等查询,并支持Binding Table以及笛卡尔积表查询。 </li><li>性能高,单库查询QPS为原生JDBC的99.8%,双库查询QPS比单库增加94%。 </li></ul><p><strong>架构</strong><br><img src="0d31edabc368a0bd0013de4cbc444232.jpg" alt="架构"></p><p><strong>核心概念</strong> </p><ul><li>LogicTable:数据分片的逻辑表,对于水平拆分的数据库(表)来说,是同一类表的总称。如:订单数据根据主键尾数拆分为10张表,分表是t order 0到t order 9,他们的逻辑表名为t_order。 </li><li>ActualTable:分片数据中真实存在的物理表。 </li><li>DataNode:数据分片的最小单元,由数据源名称和数据表组成。如:ds 1.t order_0。 </li><li>DynamicTable:逻辑表和物理表不一定需要在配置规则中静态配置。如,按照日期分片的场景,物理表的名称随着时间的推移会产生变化。 </li><li>BindingTable:指在任何场景下分片规则均一致的主表和子表。例:订单表和订单项表,均按照订单ID分片,则此两张表互为BindingTable关系。BindingTable关系的多表关联查询不会出现笛卡尔积关联,查询效率将大大提升。 </li><li>ShardingColumn:分片字段用于将数据库(表)水平拆分的字段。 </li><li>ShardingAlgorithm:分片算法。 </li><li>SQL Hint:对于分片字段非SQL决定,而由其他外置条件决定的场景,可使用SQL Hint灵活的注入分片字段。 </li></ul><p><strong>数据源分布规则配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, DataSource&gt; <span class="title">createDataSourceMap</span><span class="params">(List&lt;Database&gt; dbs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(dbs)) &#123; </span><br><span class="line">        logger.error(<span class="string">"db configuration is null!"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (Database db : dbs) &#123; </span><br><span class="line">        dataSourceMap.put(db.getDbname(), createDataSource(db)); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dataSourceMap; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">DataSourceRule dataSourceRule = <span class="keyword">new</span> DataSourceRule(createDataSourceMap(dataSourceProperties.getDbs()));</span><br></pre></td></tr></table></figure><p><strong>逻辑表&amp;;物理表映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TableRule orderTableRule =TableRule.builder(<span class="string">"order"</span>).actualTables(Arrays.asList(<span class="string">"t_order_0"</span>, <span class="string">"t_order_1"</span>)).dataSourceRule(dataSourceRule).build();</span><br></pre></td></tr></table></figure><p><strong>分片策略配置 </strong><br>Sharding-jdbc认为对于分片策略有两种维度:</p><ul><li>数据源分片策略(DatabaseShardingStrategy) 数据被分配的目标数据源。 </li><li>表分片策略(TableShardingStrategy) 数据被分配的目标表,该目标表在该数据对应的目标数据源内。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DatabaseShardingStrategy databaseShardingStrategy = <span class="keyword">new</span> DatabaseShardingStrategy(<span class="string">"user_id"</span>, <span class="keyword">new</span> ModuloDatabaseShardingAlgorithm()); </span><br><span class="line">TableShardingStrategy tableShardingStrategy = <span class="keyword">new</span> TableShardingStrategy(<span class="string">"order_id"</span>, <span class="keyword">new</span> ModuloTableShardingAlgorithm()); </span><br><span class="line">ShardingRule shardingRule = ShardingRule.builder() </span><br><span class="line">    .dataSourceRule(dataSourceRule) </span><br><span class="line">    .tableRules(Arrays.asList(orderTableRule, orderItemTableRule)) </span><br><span class="line">    .databaseShardingStrategy(databaseShardingStrategy) </span><br><span class="line">    .tableShardingStrategy(tableShardingStrategy) </span><br><span class="line">    .build(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ShardingDataSource </span></span><br><span class="line"></span><br><span class="line">DataSource shardingDataSource = ShardingDataSourceFactory.createDataSource(shardingRule);</span><br></pre></td></tr></table></figure><p><strong>JDBC规范重写</strong><br>针对DataSource、Connection、Statement、PreparedStatement和ResultSet五个核心接口封装。</p><ul><li>DataSource:ShardingDataSource </li><li>Connetion:ShardingConnection ShardingConnection是一种逻辑上的分布式数据库链接,成员变量ShardingContext,即数据源运行的上下文信息。 </li><li>ShardingContext包括:ShardingRule:分片规则;ExecutorEngine:执行引擎,通过多线程的方式并行执行SQL。 </li><li>Statement:ShardingStatement </li><li>PreparedStatement:ShardingPreparedStatement </li><li>ResultSet:ShardingResultSet </li></ul><p><strong>SQL解析</strong> </p><p><img src="5694af1f649eb968c9b09b28f35786b2.jpg" alt="SQL解析"></p><p>常见的SQL解析主要有:fdb/jsqlparser、Druid;sharding-jdbc 1.5.0.M1将SQL解析引擎从Druid换成了自研的解析引擎。 Sharding-jdbc支持join、aggregation、order by、group by、limit、or;目前不支持union、部分子查询、函数内分片等不太应在分片场景中出现的SQL解析。</p><p>SQL解析引擎在sharding-jdbc-core模块下com.dangdang.ddframe.rdb.sharding.parsing包下,包含两个组件:</p><ul><li>Lexer:词法解析器</li><li>Parser:SQL解析器</li></ul><p><img src="160de2ecdf238bfc2c16747a134503b0.jpg" alt=""></p><p><img src="9f82893a6a07f67ab9e1ffd24be3944a.jpg" alt=""></p><p><strong>Lexer词法解析器</strong><br>关键类:LexerEngine、Lexer、Token、Tokenizer Lexer原理:顺序解析SQL,将字符串拆成N个Token。</p><p>通过Lexer#nextToken方法不断解析出Token Token结构(以select为例):<br><img src="0c74f2fcb2f32741003cb5d3220e2cb4.jpg" alt=""></p><p><img src="573dd74926e10ba8ea9bd37a733ed2cf.jpg" alt=""></p><p><img src="a157549e2138ad5f4916c003dfdf6af7.jpg" alt=""></p><p><strong>SQL解析(以Select为例)</strong><br>关键类:SQLParsingEngine、AbstractSelectParser(MySQLSelectParser)、SelectStatement、ExpressionClauseParser(parse(SQLStatement)) </p><p><img src="bd908653bc7fbfafa0cb3f6e0008549d.jpg" alt=""></p><p><code>SQLParseEngine</code>:SQL解析引擎,parse()方法为SQL解析的入口。 - AbstractSelectParser(MySQLSelectParser):SQL解析器,和词法解析器Lexer类似,不同数据库有不同的实现。 - ExpressionClauseParser:解析SQLStatement。</p><p><strong>SQL路由&amp;;改写</strong></p><p><img src="6a09bb8f8c0f2e7b738422c682bb5317.jpg" alt=""></p><p>入口:ShardingPreparedStatement.route - 关键类:ShardingPreparedStatement、PreparedStatementRoutingEngine、ParsingSQLRouter、SimpleRoutingEngine 、ComplexRoutingEngine 、SQLRewriteEngine、 </p><p><img src="f98ce7ac4a8a04b63fb6be9d0a590bd3.jpg" alt=""></p><p><img src="181b542661a6a5baf11c5427e449e5ac.jpg" alt=""></p><p><strong>SQL执行 &amp;; 归并</strong><br><img src="2390e88c9f9ce28cb01f7cbf0f37da13.jpg" alt=""></p><p>入口:ShardingPreparedStatement.executeQuery 关键类:ShardingPreparedStatement、PreparedStatementExecutor、ExecutorEngine</p><p><img src="95685342d67826bbf1f4ac0f6888a7eb.jpg" alt=""></p><p><img src="4eaf342b602a4546a49b9076a77bfada.jpg" alt=""></p><p>入口:ShardingPreparedStatement.executeQuery 关键类:ShardingPreparedStatement、ShardingResultSet、MergeEngine<br><img src="30185fb378b04895fea07ce10c525db1.jpg" alt=""></p><p>读写分离<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rdb:master-slave-data-source</span> <span class="attr">id</span>=<span class="string">"db_cluster0"</span> <span class="attr">master-data-source-ref</span>=<span class="string">"db0"</span> <span class="attr">slave-data-sources-ref</span>=<span class="string">"db0_slave1, db0_slave0"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rdb:master-slave-data-source</span> <span class="attr">id</span>=<span class="string">"db_cluster1"</span> <span class="attr">master-data-source-ref</span>=<span class="string">"db1"</span> <span class="attr">slave-data-sources-ref</span>=<span class="string">"db1_slave0, db1_slave1"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rdb:strategy</span> <span class="attr">id</span>=<span class="string">"databaseStrategy"</span> <span class="attr">sharding-columns</span>=<span class="string">"user_id"</span> <span class="attr">algorithm-class</span>=<span class="string">"com.bing.shardingjdbc.spring.algorithm.ModuloDatabaseShardingAlgorithm"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rdb:strategy</span> <span class="attr">id</span>=<span class="string">"orderTableStrategy"</span> <span class="attr">sharding-columns</span>=<span class="string">"order_id"</span> <span class="attr">algorithm-expression</span>=<span class="string">"t_order_$&#123;order_id.longValue() % 2&#125;"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rdb:strategy</span> <span class="attr">id</span>=<span class="string">"orderItemTableStrategy"</span> <span class="attr">sharding-columns</span>=<span class="string">"order_id"</span> <span class="attr">algorithm-class</span>=<span class="string">"com.bing.shardingjdbc.spring.algorithm.ModuloTableShardingAlgorithm"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rdb:data-source</span> <span class="attr">id</span>=<span class="string">"shardingDataSource"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">rdb:sharding-rule</span> <span class="attr">data-sources</span>=<span class="string">"db_cluster0, db_cluster1"</span> <span class="attr">key-generator-class</span>=<span class="string">"com.dangdang.ddframe.rdb.sharding.keygen.DefaultKeyGenerator"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">rdb:table-rules</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">rdb:table-rule</span> <span class="attr">logic-table</span>=<span class="string">"order"</span> <span class="attr">actual-tables</span>=<span class="string">"t_order_$&#123;0..1&#125;"</span> <span class="attr">database-strategy</span>=<span class="string">"databaseStrategy"</span> <span class="attr">table-strategy</span>=<span class="string">"orderTableStrategy"</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">rdb:generate-key-column</span> <span class="attr">column-name</span>=<span class="string">"order_id"</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">rdb:table-rule</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">rdb:table-rule</span> <span class="attr">logic-table</span>=<span class="string">"order_item"</span> <span class="attr">actual-tables</span>=<span class="string">"t_order_item_$&#123;0..1&#125;"</span> <span class="attr">database-strategy</span>=<span class="string">"databaseStrategy"</span> <span class="attr">table-strategy</span>=<span class="string">"orderItemTableStrategy"</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">rdb:generate-key-column</span> <span class="attr">column-name</span>=<span class="string">"item_id"</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">rdb:table-rule</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rdb:table-rules</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rdb:sharding-rule</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">rdb:props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"metrics.enable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sql.show"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rdb:props</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">rdb:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>关键类:MasterSlaveDataSourceFactory、MasterSlaveDataSource、 MasterSlaveLoadBalanceStrategy(负载均衡策略,包括Random &amp;; RoundRobin)、<br>默认主从负载均衡策略:轮询RoundRobinMasterSlaveLoadBalanceStrategy </p><p><img src="9392af4d59283516ab026a950d7acd35.jpg" alt=""></p><p><strong>分布式主键</strong></p><ol><li>Twitter snowflake </li></ol><p><img src="5deff90bdc30ce72a6da990e92c93cfc.jpg" alt=""></p><p>1位符号位,始终为0; </p><p>41位时间戳,一般实现上不会存储当前的时间戳,而是时间戳的差值(当前时间-固定的开始时间),这样可以使产生的id从更小值开始;41位时间戳可以使用69年,1L&lt;&lt;41/(1000L 60 60 24 365) = 69年 </p><p>10位节点位,前五位数据中心标识,后五位机器标识,可以部署1024个节点 </p><p>12位序列号,支持同一个节点同一毫秒可以生成4069个ID </p><p>Sharding-JDBC :1bit符号位(为0),41bit时间位,10bit工作进程位,12bit序列位。</p><p>spring 配置:</p><p><img src="58e03fbd59f688b94bcc1acd4006492d.jpg" alt=""></p><ol start="2"><li>Flicker<br>利用MySQL的auto increment、replace into、MyISAM,生成一个64位的ID。 - 先创建一个单独的数据库:如global id - 创建表:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> global_id_64 ( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">    stub <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>, </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>), </span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub) </span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM</span><br></pre></td></tr></table></figure><p>应用端在一个事务里提交:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Tickets64 (stub) <span class="keyword">VALUES</span> (<span class="string">'a'</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>();</span><br></pre></td></tr></table></figure><p>解决单点问题:启用两台数据库服务器,通过区分auto_increment的起始值和步长来生成奇偶数的ID: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Server1: </span><br><span class="line">auto-increment-increment = 2 //自增长字段每次递增的量 </span><br><span class="line">auto-increment-offset = 1//自增长字段开始值 </span><br><span class="line"></span><br><span class="line">Server2: </span><br><span class="line">auto-increment-increment = 2 </span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure><p>应用端轮询取id<br>柔性事务——最大努力送达型<br>Sharding-JDBC最大努力送达型事务认为对该数据库的操作最终一定可以成功,因此通过最大努力反复尝试送达操作。</p><p><img src="c99f1138113dc6c27ffd09dae267aa82.jpg" alt=""></p><p><strong>事务日志存储器</strong></p><ul><li><p>基于内存: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftTransactionConfiguration.setStorageType(TransactionLogDataSourceType.MEMORY);</span><br></pre></td></tr></table></figure></li><li><p>基于RDB: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftTransactionConfiguration.setTransactionLogDataSource(txLogDataSource);</span><br></pre></td></tr></table></figure></li></ul><p>默认的storageType 为 RDB。</p><p>异步作业<br>内嵌异步作业:<br>// 使用内嵌异步作业,仅用于开发环境<br>// 内嵌了一个注册中心,默认zookeeperPort 4181<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NestedBestEffortsDeliveryJobConfiguration nestedJobConfig = <span class="keyword">new</span> NestedBestEffortsDeliveryJobConfiguration(); </span><br><span class="line">txConfig.setBestEffortsDeliveryJobConfiguration(Optional.of(nestedJobConfig));</span><br></pre></td></tr></table></figure></p><p>独立部署作业<br>事务日志库<br>用于异步作业的zk<br>下载sharding-jdbc-transaction-async-job,通过start.sh脚本启动异步作业: </p><p>官网：<a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">https://github.com/apache/incubator-shardingsphere</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背景关系型数据库在大于一定数据量的情况下性能会急剧下降。在面对互联网海量数据的情况时,所有数据都存于一张表,显然很容易会达到数据表可承受的数据量阈值。单纯分表虽然可以解决数据量过大导致检索变慢的问题,但无法解决高并发情况下访问同一个库,导致数据库响应变慢的问题。所以通常水平拆分都至少要采用分库的方式,以一并解决大数据量&amp;amp;;高并发的问题。但分表也有不可替代的…&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://blog.shagle.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Sharding-jdbc" scheme="http://blog.shagle.cn/tags/Sharding-jdbc/"/>
    
      <category term="ShardingSphere" scheme="http://blog.shagle.cn/tags/ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>阿里GTS开源版本fescar分布式事务发布了</title>
    <link href="http://blog.shagle.cn/2019/01/18/%E9%98%BF%E9%87%8CGTS%E5%BC%80%E6%BA%90%E7%89%88%E6%9C%ACfescar%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%91%E5%B8%83%E4%BA%86/"/>
    <id>http://blog.shagle.cn/2019/01/18/阿里GTS开源版本fescar分布式事务发布了/</id>
    <published>2019-01-18T06:51:58.000Z</published>
    <updated>2019-01-18T07:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言碎语"><a href="#前言碎语" class="headerlink" title="前言碎语"></a>前言碎语</h1><p>阿里重磅开源fescar分布式事务框架、其前身是拥有多项专利的云分布式事务产品GTS、很早前阿里在推广GTS分布式事务的时候就隐隐透露过可能会有开源项目的推出，终于在社区千呼万唤之下fescar发布了。目前是0.1的版本，因为脱胎于商业产品，社区版本要上生产环境可能需要在社区迭代孵化一段时间。代码可以先拉下来研究一下，后期持续关注fescar的发展。</p><p>项目地址：<a href="https://github.com/alibaba/fescar" target="_blank" rel="noopener">https://github.com/alibaba/fescar</a></p><h1 id="什么是FESCAR？"><a href="#什么是FESCAR？" class="headerlink" title="什么是FESCAR？"></a>什么是FESCAR？</h1><blockquote><p>一种<code>分布式事务解决方案</code>，具有高性能和易用性的<code>微服务</code>架构。</p></blockquote><p>让我们想象一下传统的单片应用程序。其业务由3个模块构成。他们使用单个本地数据源。</p><p>当然，本地交易可以保证数据的一致性。</p><p><img src="68747470733a2f2f63646e2e7.png" alt=""></p><p>微服务架构发生了变化。提到的3个模块设计为3个不同数据源之上的3个服务（<a href="https://microservices.io/patterns/data/database-per-service.html" target="_blank" rel="noopener">模式：每个服务的数据库</a>）。本地事务自然保证每个服务中的数据一致性。</p><p>但整个业务逻辑范围如何呢？</p><p><img src="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c.png" alt=""></p><hr><h1 id="FESCAR怎么做？"><a href="#FESCAR怎么做？" class="headerlink" title="FESCAR怎么做？"></a>FESCAR怎么做？</h1><p>FESCAR只是上述问题的解决方案。</p><p><img src="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f3025382e706e67.png" alt=""></p><p>首先，如何定义<code>分布式事务</code>？</p><p>我们说，<code>分布式事务</code>是一个<code>全局事务</code>，由一批<code>Branch Transation</code>组成，通常<code>Branch Transation</code>只是<code>本地事务</code>。</p><p><img src="68747470733a2f2f63646e2e6e6c6172e706e67.png" alt=""></p><p>FESACR有3个基本组件：</p><ul><li><code>事务协调器（TC）</code>：维护全局和分支事务的状态，驱动全局提交或回滚。</li><li><code>Transaction Manager（TM）</code>：定义全局事务的范围：开始全局事务，提交或回滚全局事务。</li><li><code>资源管理器（RM</code>）：管理分支事务的资源，与TC通信以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b27.png" alt=""></p><p>FESCAR管理分布式事务的典型生命周期：</p><ol><li>TM要求TC开始新的全球交易。TC生成表示全局事务的XID。</li><li>XID通过微服务的调用链传播。</li><li>RM将本地事务注册为XID到TC的相应全局事务的分支。</li><li>TM要求TC提交或回滚XID的相应全局事务。</li><li>TC在XID的相应全局事务下驱动所有分支事务以完成分支提交或rollbaking。</li></ol><p><img src="68747470733a2f2f63646e2e6e6c61726b2e636f683966342e706e67.png" alt=""></p><p>有关原理和设计的更多详细信息，请访问<a href="https://github.com/alibaba/fescar/wiki" target="_blank" rel="noopener">FESCAR维基页面</a>。</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><ul><li><code>TXC</code>：淘宝交易构造函数。阿里巴巴中间件团队自2014年起启动该项目，以满足应用程序架构从单一服务变为微服务所导致的直接交易问题。</li><li><code>GTS</code>：全球交易服务。TXC作为Aliyun中间件产品，新名称GTS自2016年起发布。</li><li><code>FESCAR</code>：我们从2019年开始基于TXC / GTS开源开源项目FESCAR，以便与社区密切合作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言碎语&quot;&gt;&lt;a href=&quot;#前言碎语&quot; class=&quot;headerlink&quot; title=&quot;前言碎语&quot;&gt;&lt;/a&gt;前言碎语&lt;/h1&gt;&lt;p&gt;阿里重磅开源fescar分布式事务框架、其前身是拥有多项专利的云分布式事务产品GTS、很早前阿里在推广GTS分布式事务的时候
      
    
    </summary>
    
      <category term="分布式" scheme="http://blog.shagle.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
