<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.shagle.cn/"/>
  <updated>2019-03-22T07:21:19.000Z</updated>
  <id>http://blog.shagle.cn/</id>
  
  <author>
    <name>bogle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发包中ThreadLocalRandom类原理剖析</title>
    <link href="http://blog.shagle.cn/2019/03/22/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%ADThreadLocalRandom%E7%B1%BB%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://blog.shagle.cn/2019/03/22/并发包中ThreadLocalRandom类原理剖析/</id>
    <published>2019-03-22T07:13:26.000Z</published>
    <updated>2019-03-22T07:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并发包中ThreadLocalRandom类原理剖析"><a href="#1-并发包中ThreadLocalRandom类原理剖析" class="headerlink" title="1. 并发包中ThreadLocalRandom类原理剖析"></a>1. 并发包中ThreadLocalRandom类原理剖析</h1><p>ThreadLocalRandom类是JDK7在JUC包下新增的随机数生成器，它解决了Random类在多线程下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足。本节首先讲解下Random类的实现原理已经它在多线程下使用的局限性，然后引入ThreadLocalRandom类，通过讲解ThreadLocalRandom的实现原理来说明ThreadLocalRandom是如何解决的Random类的不足。</p><h2 id="1-1-Random类及其局限性"><a href="#1-1-Random类及其局限性" class="headerlink" title="1.1 Random类及其局限性"></a>1.1 Random类及其局限性</h2><p>在JDK7之前包括现在java.util.Random应该是使用比较广泛的随机数生成工具类，另外java.lang.Math中的随机数生成也是使用的java.util.Random的实例。下面先看看java.util.Random的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//(1)创建一个默认种子的随机数生成器</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//(2)输出10个在0-5（包含0，不包含5）之间的随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码（1）创建一个默认随机数生成器，使用默认的种子。</li><li>代码（2）输出输出10个在0-5（包含0，不包含5）之间的随机数。</li></ul><p>这里提下随机数的生成需要一个默认的种子，这个种子其实是一个long类型的数字,这个种子要么在Random的时候通过构造函数指定，那么默认构造函数内部会生成一个默认的值，有了默认的种子后，如何生成随机数那？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(3)参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">//(4)根据老的种子生成新的种子</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="comment">//(5)根据新的种子计算随机数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码可知新的随机数的生成需要两个步骤</p><ul><li>首先需要根据老的种子生成新的种子。</li><li>然后根据新的种子来计算新的随机数。</li></ul><p>其中步骤（4）我们可以抽象为seed=f(seed),其中f是一个固定的函数，比如seed= f(seed)=a<em>seed+b;步骤（5）也可以抽象为g(seed,bound)，其中g是一个固定的函数，比如g(seed,bound)=(int)((bound </em> (long)seed) &gt;&gt; 31);在单线程情况下每次调用nextInt都是根据老的种子计算出来新的种子，这是可以保证随机数产生的随机性的。但是在多线程下多个线程可能都拿同一个老的种子去执行步骤（4）计算新的种子，这会导致多个线程产生的新种子是一样的，由于步骤（5）算法是固定的，所以会导致多个线程产生相同的随机值，这并不是我们想要的。所以步骤（4）要保证原子性，也就是说多个线程在根据同一个老种子计算新种子时候，第一个线程的新种子计算出来后，第二个线程要丢弃自己老的种子，要使用第一个线程的新种子来计算自己的新种子，依次类推，只有保证了这个，才能保证多线程下产生的随机数是随机的。Random函数使用一个原子变量达到了这个效果，在创建Random对象时候初始化的种子就保存到了种子原子变量里面，下面看下next()代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//(6)</span></span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">//(7)</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        <span class="comment">//(8)</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="comment">//(9)</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码（6）获取当前原子变量种子的值</li><li>代码（7）根据当前种子值计算新的种子</li><li>代码（8）使用CAS操作，使用新的种子去更新老的种子，多线程下可能多个线程都同时执行到了代码（6）那么可能多个线程都拿到的当前种子的值是同一个，然后执行步骤（7）计算的新种子也都是一样的，但是步骤（8）的CAS操作会保证只有一个线程可以更新老的种子为新的，失败的线程会通过循环从新获取更新后的种子作为当前种子去计算老的种子，可见这里解决了上面提到的问题，也就保证了随机数的随机性。</li><li>代码（9）则使用固定算法根据新的种子计算随机数。</li></ul><p>总结下：每个Random实例里面有一个原子性的种子变量用来记录当前的种子的值，当要生成新的随机数时候要根据当前种子计算新的种子并更新回原子变量。多线程下使用单个Random实例生成随机数时候，多个线程同时计算随机数计算新的种子时候多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这是会降低并发性能的，所以ThreadLocalRandom应运而生。</p><h1 id="1-2-ThreadLocalRandom"><a href="#1-2-ThreadLocalRandom" class="headerlink" title="1.2. ThreadLocalRandom"></a>1.2. ThreadLocalRandom</h1><p>为了解决多线程高并发下Random的缺陷，JUC包下新增了ThreadLocalRandom类，下面首先看下它如何使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//(10)获取一个随机数生成器</span></span><br><span class="line">        ThreadLocalRandom random =  ThreadLocalRandom.current();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(11)输出10个在0-5（包含0，不包含5）之间的随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码（10）调用ThreadLocalRandom.current()来获取当前线程的随机数生成器。下面来分析下ThreadLocalRandom的实现原理。从名字看会让我们联想到基础篇讲解的ThreadLocal，ThreadLocal的出现就是为了解决多线程访问一个变量时候需要进行同步的问题，让每一个线程拷贝一份变量，每个线程对变量进行操作时候实际是操作自己本地内存里面的拷贝，从而避免了对共享变量进行同步。实际上ThreadLocalRandom的实现也是这个原理，Random的缺点是多个线程会使用原子性种子变量，会导致对原子变量更新的竞争，如下图：</p><p><img src="5879294-f28b763a7bc5cebe.png" alt=""></p><p>那么如果每个线程维护自己的一个种子变量，每个线程生成随机数时候根据自己老的种子计算新的种子，并使用新种子更新老的种子，然后根据新种子计算随机数，就不会存在竞争问题，这会大大提高并发性能，如下图ThreadLocalRandom原理：</p><p><img src="5879294-4c58aad729e49293.png" alt=""></p><h2 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h2><p>首先看下ThreadLocalRandom的类图结构：</p><p><img src="5879294-de63d1e5f21bd72c.png" alt=""></p><p>可知ThreadLocalRandom继承了Random并重写了nextInt方法，ThreadLocalRandom中并没有使用继承自Random的原子性种子变量。ThreadLocalRandom中并没有具体存放种子，具体的种子是存放到具体的调用线程的threadLocalRandomSeed变量里面的，ThreadLocalRandom类似于ThreadLocal类就是个工具类。当线程调用ThreadLocalRandom的current方法时候ThreadLocalRandom负责初始化调用线程的<br>threadLocalRandomSeed变量，也就是初始化种子。当调用ThreadLocalRandom的nextInt方法时候，实际上是获取当前线程的threadLocalRandomSeed变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的threadLocalRandomSeed变量，然后在根据新种子和具体算法计算随机数。这里需要注意的是threadLocalRandomSeed变量就是Thread类里面的一个普通long变量，并不是原子性变量，其实道理很简单，因为这个变量是线程级别的，根本不需要使用原子性变量，如果还是不理解可以思考下ThreadLocal的原理。</p><p>其中变量seeder和probeGenerator是两个原子性变量，在初始化调用线程的种子和探针变量时候用到，每个线程只会使用一次。</p><p>另外变量instance是个ThreadLocalRandom的一个实例，该变量是static的，当多线程通过ThreadLocalRandom的current方法获取ThreadLocalRandom的实例时候其实获取的是同一个，但是由于具体的种子是存放到线程里面的，所以ThreadLocalRandom的实例里面只是与线程无关的通用算法，所以是线程安全的。</p><p>下面看看ThreadLocalRandom的主要代码实现逻辑</p><ul><li>Unsafe 机制的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取unsafe实例</span></span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            <span class="comment">//获取Thread类里面threadLocalRandomSeed变量在Thread实例里面偏移量</span></span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">            <span class="comment">//获取Thread类里面threadLocalRandomProbe变量在Thread实例里面偏移量</span></span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">            <span class="comment">//获取Thread类里面threadLocalRandomProbe变量在Thread实例里面偏移量</span></span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocalRandom current()方法：该方法获取ThreadLocalRandom实例，并初始化调用线程中threadLocalRandomSeed和threadLocalRandomProbe变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//(12)</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//(13)</span></span><br><span class="line">            localInit();</span><br><span class="line">        <span class="comment">//(14)</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码（12）如果当前线程中threadLocalRandomProbe变量值为0（默认情况下线程的这个变量为0），说明当前线程第一次调用ThreadLocalRandom的current方法，那么就需要调用localInit方法计算当前线程的初始化种子变量。这里设计为了延迟初始化，不需要使用随机数功能时候Thread类中的种子变量就不需要被初始化，这是一种优化。</p><p>代码（13）首先计算根据probeGenerator计算当前线程中threadLocalRandomProbe的初始化值，然后根据seeder计算当前线程的初始化种子，然后把这两个变量设置到当前线程。<br>代码（14）返回ThreadLocalRandom的实例，需要注意的是这个方法是静态方法，多个线程返回的是同一个ThreadLocalRandom实例。</p><ul><li>int nextInt(int bound)方法：计算当前线程的下一个随机数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(15)参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">//(16) 根据当前线程中种子计算新种子</span></span><br><span class="line">    <span class="keyword">int</span> r = mix32(nextSeed());</span><br><span class="line">    <span class="comment">//(17)根据新种子和bound计算随机数</span></span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>) <span class="comment">// power of two</span></span><br><span class="line">        r &amp;= m;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// reject over-represented candidates</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">             u + m - (r = u % bound) &lt; <span class="number">0</span>;</span><br><span class="line">             u = mix32(nextSeed()) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码逻辑步骤与Random相似，我们重点看下nextSeed()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; <span class="keyword">long</span> r; <span class="comment">// </span></span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码首先使用 r = UNSAFE.getLong(t, SEED)获取当前线程中threadLocalRandomSeed变量的值，然后在种子的基础上累加GAMMA值作为新种子，然后使用UNSAFE的putLong方法把新种子放入当前线程的threadLocalRandomSeed变量。</p><h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><p>本节首先讲解了Random的实现原理以及介绍了Random在多线程下存在竞争种子原子变量更新操作失败后自旋等待的缺点，从而引出ThreadLocalRandom类，ThreadLocalRandom使用ThreadLocal的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-并发包中ThreadLocalRandom类原理剖析&quot;&gt;&lt;a href=&quot;#1-并发包中ThreadLocalRandom类原理剖析&quot; class=&quot;headerlink&quot; title=&quot;1. 并发包中ThreadLocalRandom类原理剖析&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="ThreadLocalRandom" scheme="http://blog.shagle.cn/categories/ThreadLocalRandom/"/>
    
    
  </entry>
  
  <entry>
    <title>String和StringBuffer和StringBuilder</title>
    <link href="http://blog.shagle.cn/2019/03/22/String%E5%92%8CStringBuffer%E5%92%8CStringBuilder/"/>
    <id>http://blog.shagle.cn/2019/03/22/String和StringBuffer和StringBuilder/</id>
    <published>2019-03-22T06:13:28.000Z</published>
    <updated>2019-03-22T06:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-从是否可变的角度"><a href="#1-从是否可变的角度" class="headerlink" title="1. 从是否可变的角度"></a>1. 从是否可变的角度</h1><p>String类中使用字符数组保存字符串，因为有“final”修饰符，所以String对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，但没有“final”修饰符，所以两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder (java.lang)</span><br><span class="line">    StringBuffer (java.lang)</span><br><span class="line">    StringBuilder (java.lang)</span><br></pre></td></tr></table></figure><p>使用该字符数组保存内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></p><h1 id="2-是否多线程安全"><a href="#2-是否多线程安全" class="headerlink" title="2. 是否多线程安全"></a>2. 是否多线程安全</h1><p>tring中的对象是不可变的，也就可以理解为常量，所以是线程安全的。<br>AbstractStringBuilder是StringBuffer和StringBuilder的公共父类，定义了一些字符串的基本操作，如append、、indexOf等公共方法。<br>StringBuffer对方法加了同步锁(synchronized) ，所以是线程安全的。看如下源码：</p><p><strong>StringBuffer</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。如下源码：</p><p><strong>StringBuilder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-StringBuffer和StringBuilder的共同点"><a href="#3-StringBuffer和StringBuilder的共同点" class="headerlink" title="3. StringBuffer和StringBuilder的共同点"></a>3. StringBuffer和StringBuilder的共同点</h2><p>StringBuffer和StringBuilder有公共父类AbstractStringBuilder(抽象类)。<br>StringBuffer、StringBuilder的方法都会调用AbstractStringBuilder中的公共方法，如上面的两段源码中都调用了super.append(str); 只是StringBuffer会在方法上加synchronized关键字，进行同步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-从是否可变的角度&quot;&gt;&lt;a href=&quot;#1-从是否可变的角度&quot; class=&quot;headerlink&quot; title=&quot;1. 从是否可变的角度&quot;&gt;&lt;/a&gt;1. 从是否可变的角度&lt;/h1&gt;&lt;p&gt;String类中使用字符数组保存字符串，因为有“final”修饰符，所以
      
    
    </summary>
    
      <category term="Java中String、StringBuffer、StringBuilder的区别" scheme="http://blog.shagle.cn/categories/Java%E4%B8%ADString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Protocol buffers翻译</title>
    <link href="http://blog.shagle.cn/2019/03/12/Protocol-buffers%E7%BF%BB%E8%AF%91/"/>
    <id>http://blog.shagle.cn/2019/03/12/Protocol-buffers翻译/</id>
    <published>2019-03-12T13:11:05.000Z</published>
    <updated>2019-03-13T08:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPC:Remote Procedure Call,远程过程调用，很多RPC框架是夸语言的</p><ol><li>定义一个接口说明文件：描述了对象(结构图体)，对象成员，接口方法等一系列信息</li><li>通过RPC框架所提供的编码器，将接口说明文件编译成集体的语言文件</li><li>在客户端和服务端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法</li></ol><a id="more"></a><h1 id="1-Protocol-buffers"><a href="#1-Protocol-buffers" class="headerlink" title="1. Protocol buffers"></a>1. Protocol buffers</h1><p>Protocol buffers 是语言中立的，平台无关的，可扩展的用于序列化结构化数据</p><p><strong>1.1. What are protocol buffers?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = <span class="number">1</span>;</span><br><span class="line">  required int32 id = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Protocol buffers是google提供的语言中立，平台中立，用于数据结构化，可扩展化的结构化数据–就像xml，但是它的提交更小，速度更快，更加简单。你只需要定义一次你的数据结构，然后使用特殊生成的源代码轻松地将结构化数据写入和读取各种数据流，并使用各种语言。</p><p><strong>1.2. Pick your favorite language</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person john = Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">"John Doe"</span>)</span><br><span class="line">    .setEmail(<span class="string">"jdoe@example.com"</span>)</span><br><span class="line">    .build();</span><br><span class="line">output = <span class="keyword">new</span> FileOutputStream(args[<span class="number">0</span>]);</span><br><span class="line">john.writeTo(output);</span><br></pre></td></tr></table></figure></p><p>Protocol buffers当前支持生成的代码Java，Python，Objective-C和C++语言。使用我们新的proto3语言版本，您还可以使用Dart，Go，Ruby和C＃，以及更多语言。</p><p><strong>1.3 How do I start?</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person john;</span><br><span class="line"><span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">    ios::in | ios::binary)</span></span>;</span><br><span class="line">john.ParseFromIstream(&amp;input);</span><br><span class="line">id = john.id();</span><br><span class="line">name = john.name();</span><br><span class="line">email = john.email();</span><br></pre></td></tr></table></figure></p><ol><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">下载</a>并安装protocol buffer 编译器</li><li>阅读<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">指南</a>。</li><li>尝试使用您选择的语言的<a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">教程</a>。</li></ol><h1 id="2-Protocol-Buffer-Basics-Java"><a href="#2-Protocol-Buffer-Basics-Java" class="headerlink" title="2. Protocol Buffer Basics: Java"></a>2. Protocol Buffer Basics: Java</h1><p>本教程提供了一个基本的Java程序员介绍如何使用Protocol buffers。它向您展示如何通过创建一个简单的示例应用程序，</p><ul><li>在.proto文件中定义消息格式。</li><li>使用protocol buffer编译器</li><li>使用Java protocol buffer API来编写和读取消息。</li></ul><p>这不是在Java中使用protocol buffer的综合指南。有关更详细的参考信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">Protocol Buffer Language Guide</a>,<a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html" target="_blank" rel="noopener">Java API Reference</a>, <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Encoding Reference</a>.</p><h2 id="2-1-Why-Use-Protocol-Buffers"><a href="#2-1-Why-Use-Protocol-Buffers" class="headerlink" title="2.1 Why Use Protocol Buffers?"></a>2.1 Why Use Protocol Buffers?</h2><p>我们将要使用的示例是一个非常简单的“address book”应用程序，可以在文件中读取和写入人员的联系人详细信息。address book中的每个人都有姓名，ID，电子邮件地址和联系电话号码。</p><p>你如何序列化和检索这样的结构化数据？有几种方法可以解决这个问题：</p><ul><li>使用java的序列化:这是默认方法，因为它内置于语言中，但它有许多众所周知的问题(参见Effective Java，作者：Josh Bloch，第213页),并且如果您需要与使用C ++或Python编写的应用程序共享数据，也无法正常工作。</li><li>您可以发明一种特殊的方法将数据项编码为单个字符串 - 例如将4个整数编码为“12:3:-23:67”，这是一种简单而灵活的方法，虽然它确实需要编写一次性编码和解析代码，并且解析会产生很小的运行时成本。这最适合编码非常简单的数据。</li><li>将数据序列化为XML。这种方法非常有吸引力，因为XML是人类可读的，并且有许多语言的绑定库。如果您想与其他应用程序/项目共享数据，这可能是一个不错的选择。然而，XML是众所周知的空间密集型，并且编码/解码它会对应用程序造成巨大的性能损失。此外，导航XML DOM树比通常在类中导航简单字段要复杂得多。</li></ul><p>Protocol Buffers是灵活，高效，自动化的解决方案，可以解决这个问题。使用Protocol Buffers，您可以编写要存储的数据结构的.proto描述。根据这个.proto文件，Protocol Buffers编译器创建一个class，该类使用有效的二进制格式实现Protocol Buffers数据的自动编码和解析。生成的类为构成Protocol Buffers针对字段提供getter和setter，并负责Protocol Buffers作为一个单元读取和写入的细节。重要的是，Protocol Buffers格式支持随着时间的推移扩展格式的想法，使得代码仍然可以读取用旧格式编码的数据。</p><h2 id="2-2-Where-to-Find-the-Example-Code"><a href="#2-2-Where-to-Find-the-Example-Code" class="headerlink" title="2.2 Where to Find the Example Code"></a>2.2 Where to Find the Example Code</h2><p>示例代码包含在源代码包中的“examples”目录下。<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">Download it here.</a></p><h2 id="2-3-Defining-Your-Protocol-Format"><a href="#2-3-Defining-Your-Protocol-Format" class="headerlink" title="2.3 Defining Your Protocol Format"></a>2.3 Defining Your Protocol Format</h2><p>要创建address book应用程序，您需要从.proto文件开始。.proto文件中的定义很简单：为要序列化的每个数据结构添加消息，然后为消息中的每个字段指定名称和类型。这是定义结构消息的.proto文件<code>addressbook.proto</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">"com.example.tutorial"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"AddressBookProtos"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  required string name = <span class="number">1</span>;</span><br><span class="line">  required int32 id = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number = <span class="number">1</span>;</span><br><span class="line">    optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，语法类似于C ++或Java。接下来让我们浏览文件的每个部分，看看它的作用。</p><p>.proto文件以package声明开头，这有助于防止不同项目之间的命名冲突。在Java中，包名称用作Java包，除非您已经明确指定了java_package，就像我们在这里一样。即使你确实提供了java_package，你仍然应该定义一个普通的package，以避免在Protocol Buffers名称空间和非Java语言中发生名称冲突。</p><p>在声明package之后，您可以看到两个特定于Java的选项：<code>java_package</code>和<code>java_outer_classname</code>.java_package指定生成的classes应该位于什么Java包中存在。如果没有明确指定它，它只是匹配package声明给出的包名中，但这些名称通常不是合适的Java包名（因为它们通常不以域名开头）。java_outer_classname选项定义应包含此文件中所有类的类名。如果未明确提供java_outer_classname，则将通过将文件名转换为驼峰形式来生成它。例如，默认情况下，“my_proto.proto”将使用“MyProto”作为外部类名。</p><p>接下来，您有消息定义。 消息只是包含一组类型字段的聚合。许多标准的简单数据类型都可用作字段类型，包括bool，int32，float，double和string。您还可以使用其他消息类型作为字段类型向消息中添加更多结构 - 在上面的示例中，Person消息包含PhoneNumber消息，而AddressBook消息包含Person消息。您甚至可以定义嵌套在其他消息中的消息类型 -​​ 如您所见，PhoneNumber类型在Person中定义。如果您希望其中一个字段具有预定义的值列表之一，您还可以定义枚举类型 - 此处您要指定电话号码可以是MOBILE，HOME或WORK之一。</p><p>每个元素上的“= 1”，“= 2”标记标识该字段在二进制编码中使用的唯一“标记”。标签号1-15需要少于一个字节来编码而不是更高的数字，因此作为优化，您可以决定将这些标签用于常用或重复的元素，将标签16和更高版本留给不太常用的可选元素。重复字段中的每个元素都需要重新编码标记号，因此重复字段特别适合此优化。</p><p>必须使用以下修饰符之一注释每个字段：</p><ul><li><p><code>required</code>：必须提供该字段的值，否则该消息将被视为“未初始化”。尝试构建未初始化的消息将抛出RuntimeException。解析未初始化的消息将抛出IOException。除此之外，必填字段的行为与可选字段完全相同。</p></li><li><p><code>optional</code>：可以设置也可以不设置字段。如果未设置可选字段值，则使用默认值。对于简单类型，您可以指定自己的默认值，就像我们在示例中为电话号码类型所做的那样。否则，使用系统默认值：数字类型为0，字符串为空字符串，bools为false。对于嵌入式消息，默认值始终是消息的“默认实例”或“原型”，其中没有设置其字段。调用访问器以获取尚未显式设置的可选（或必需）字段的值始终返回该字段的默认值。</p></li><li><p><code>repeated</code>：该字段可以重复任意次数（包括0次）。重复值的顺序将保留在protocol buffer中。将重复字段视为动态大小的数组。</p></li></ul><blockquote><p>必需永远您应该非常小心地将字段标记为<code>required</code>。如果您希望在某个时刻停止写入或不发送必填字段，则将字段更改为optional字段会有问题 - 旧readers会认为没有此字段，可能会无意中拒绝或丢弃它们。您应该考虑为protocol buffer编写特定于应用程序的自定义验证例程。谷歌的一些工程师得出的结论是，使用<code>repeated</code>的弊大于利;他们更喜欢只使用<code>optional</code>和<code>repeated</code>。但是，这种观点并不普遍。</p></blockquote><p>您将在<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">Protocol Buffer Language Guide</a>中找到编写.proto文件的完整指南 - 包括所有可能的字段类型。不要去寻找类继承类似方式，但protocol buffer不支持继承。</p><h2 id="2-4-Compiling-Your-Protocol-Buffers"><a href="#2-4-Compiling-Your-Protocol-Buffers" class="headerlink" title="2. 4. Compiling Your Protocol Buffers"></a>2. 4. Compiling Your Protocol Buffers</h2><p>现在你已经有一个.proto，你接下来需要做的下一件事是生成你需要读取和写入AddressBook（以及Person和PhoneNumber）消息所需的类。为此，您需要在.proto上运行Protocol Buffers编译器protoc：</p><ol><li>如果尚未安装Protocol Buffers编译器，请<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">下载</a>该软件包并按照自述文件中的说明进行操作。</li><li>现在运行编译器，指定source代码目录（应用程序的源代码所在的位置 - 如果不提​​供值，则使用当前目录），目标目录（您希望生成的代码在哪里;通常与$SRC_DIR），以及.proto的路径。在这种情况下，你…：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto</span><br></pre></td></tr></table></figure><p>因为您需要Java class，所以使用–java_out选项 - 为其他受支持的语言提供了类似的选项。</p><p>这将在指定的目标目录中生成com/example/tutorial/AddressBookProtos.java。</p><h2 id="2-5-The-Protocol-Buffer-API"><a href="#2-5-The-Protocol-Buffer-API" class="headerlink" title="2.5 The Protocol Buffer API"></a>2.5 The Protocol Buffer API</h2><p>让我们看看一些生成的代码，看看编译器为您创建了哪些类和方法。如果你查看AddressBookProtos.java，你会发现它定义了一个名为AddressBookProtos的类，在addressbook.proto中指定的每个消息都嵌套在AddressBookProtos类中。每个类都有自己的Builder类，可用于创建该类的实例。您可以在下面的“<a href="https://developers.google.com/protocol-buffers/docs/javatutorial#builders" target="_blank" rel="noopener">Builders vs. Messages</a>”部分中找到有关构建器的更多信息。</p><p>消息和构建器都为消息的每个字段都有自动生成的访问器方法;消息只有getter，而构建器有getter和setter。以下是Person类的一些访问器（为简洁起见省略了实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title">getPhonesList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhonesCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">getPhones</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>同时，Person.Builder拥有相同的getter加setter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setEmail</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearEmail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title">getPhonesList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhonesCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">getPhones</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setPhones</span><span class="params">(<span class="keyword">int</span> index, PhoneNumber value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addPhones</span><span class="params">(PhoneNumber value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addAllPhones</span><span class="params">(Iterable&lt;PhoneNumber&gt; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">clearPhones</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如您所见，每个字段都有简单的JavaBeans样式的getter和setter。针对每个字段都有getter，如果已设置该字段，则返回true。最后，每个字段都有一个<code>clear</code>方法，将字段取消设置回其空状态。</p><p>重复字段有一些额外的方法 - 一个Count方法（它只是列表大小的简写），getter和setter通过索引获取或设置列表的特定元素，add方法将一个新元素附加到列表，以及一个addAll方法，它将整个容器中的元素添加到列表中。</p><p>有关protocol编译器为任何特定字段定义生成的确切成员的更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="noopener">Java generated code reference</a>。</p><h2 id="2-6-Enums-and-Nested-Classes"><a href="#2-6-Enums-and-Nested-Classes" class="headerlink" title="2.6 Enums and Nested Classes"></a>2.6 Enums and Nested Classes</h2><p>生成的代码包含一个嵌套在Person中的PhoneType枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">  MOBILE(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  HOME(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">  WORK(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">  ;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所期望的那样，生成嵌套类型Person.PhoneNumber，作为Person中的嵌套类。</p><h2 id="2-7-Builders-vs-Messages"><a href="#2-7-Builders-vs-Messages" class="headerlink" title="2.7 Builders vs. Messages"></a>2.7 Builders vs. Messages</h2><p>Protocol Buffer编译器生成的消息类都是不可变的。一旦构造了消息对象，就像Java String那样不能修改它。要构造消息，必须首先构造构建器，将要设置的任何字段设置为所选值，然后调用构建器的<code>build()</code>方法。</p><p>您可能已经注意到构建器的每个修改消息的方法都会返回另一个构建器。返回的对象实际上是您调用该方法的同一个构建器。为方便起见，它会返回，以便您可以在一行代码中将多个setter串在一起。</p><p>这是一个如何创建Person实例的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person john =</span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">"John Doe"</span>)</span><br><span class="line">    .setEmail(<span class="string">"jdoe@example.com"</span>)</span><br><span class="line">    .addPhones(</span><br><span class="line">      Person.PhoneNumber.newBuilder()</span><br><span class="line">        .setNumber(<span class="string">"555-4321"</span>)</span><br><span class="line">        .setType(Person.PhoneType.HOME))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="2-8-Standard-Message-Methods"><a href="#2-8-Standard-Message-Methods" class="headerlink" title="2.8. Standard Message Methods"></a>2.8. Standard Message Methods</h2><p>每个消息和构建器类还包含许多其他方法，可用于检查或操作整个消息，包括：</p><ul><li><code>isInitialized()</code>: 检查是否已设置所有必填字段。</li><li><code>toString()</code>:返回人类可读消息，对调试特别有用</li><li><code>mergeFrom(Message other)</code>:(仅限构建器)将其他内容合并到此消息中，覆盖单个标量字段，合并复合字段以及连接重复字段。</li><li><code>clear()</code>:（仅限构建器）将所有字段清除回空状态。</li></ul><p>这些方法实现了所有Java消息和构建器共享的Message和Message.Builder接口。有关更多信息，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener">complete API documentation for <code>Message</code></a>。</p><h2 id="2-9-Parsing-and-Serialization"><a href="#2-9-Parsing-and-Serialization" class="headerlink" title="2.9 Parsing and Serialization"></a>2.9 Parsing and Serialization</h2><p>最后，每个protocol buffer类都有相应的方法使用protocol buffer二进制格式去编写和读取所选类型的消息的方法。这些包括：</p><ul><li><code>byte[] toByteArray();</code>: 序列化消息并返回包含其原始字节的字节数组。</li><li><code>static Person parseFrom(byte[] data);</code>: 根据字节数组来解析消息。</li><li><code>void writeTo(OutputStream output);</code>: 序列化消息并将其写入<code>OutputStream</code>。</li><li><code>static Person parseFrom(InputStream input);</code>: 从InputStream读取和解析消息。</li></ul><p>这些只是解析和序列化提供的几个选项。再次，请参阅<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener"><code>Message</code> API reference</a>以获取完整列表。</p><blockquote><p>Protocol Buffers 和O-O(面向对象)设计Protocol Buffers 类基本上是哑数据持有者（如C中的struct）;他们没有在对象模型中成为优秀的一等公民。如果要为生成的类添加更丰富的行为，最好的方法是将生成的Protocol Buffers 类包装在特定于应用程序的类中。如果您没有对.proto文件进行更好的设计（例如，如果您正在重用另一个项目中的一个消息），那么包装Protocol Buffers 也是一个好主意。在这种情况下，您可以使用包装器类来创建更适合应用程序的独特环境的接口：隐藏一些数据和方法，公开便利功能等。您永远不应该通过继承它们来向生成的类添加行为。这将打破内部机制，无论如何都不是良好的面向对象的实践。</p></blockquote><p><code>简单理解就是Protocol Buffers 不支持继承</code></p><h2 id="2-10-Writing-A-Message"><a href="#2-10-Writing-A-Message" class="headerlink" title="2.10 Writing A Message"></a>2.10 Writing A Message</h2><blockquote><p>这个demo是将一个对象通过Protocol Buffer写入到一个文件中</p></blockquote><p>现在让我们尝试使用您的Protocol Buffer类。首先第一件事使用address book应用程序将个人详细信息写入您的address book文件。为此，您需要创建并填充Protocol Buffer类的实例属性，然后将它们写入输出流。</p><p>这是一个从键盘输入中读取到AddressBook的程序，根据用户输入向其添加一个新Person，并将新的AddressBook再次写回文件。直接调用或引用Protocol protocol编译器生成的代码的部分将突出显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddPerson</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This function fills in a Person message based on user input.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Person <span class="title">PromptForAddress</span><span class="params">(BufferedReader stdin,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 PrintStream stdout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Person.Builder person = Person.newBuilder();</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">"Enter person ID: "</span>);</span><br><span class="line">    person.setId(Integer.valueOf(stdin.readLine()));</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">"Enter name: "</span>);</span><br><span class="line">    person.setName(stdin.readLine());</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">"Enter email address (blank for none): "</span>);</span><br><span class="line">    String email = stdin.readLine();</span><br><span class="line">    <span class="keyword">if</span> (email.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      person.setEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      stdout.print(<span class="string">"Enter a phone number (or leave blank to finish): "</span>);</span><br><span class="line">      String number = stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (number.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Person.PhoneNumber.Builder phoneNumber =</span><br><span class="line">        Person.PhoneNumber.newBuilder().setNumber(number);</span><br><span class="line"></span><br><span class="line">      stdout.print(<span class="string">"Is this a mobile, home, or work phone? "</span>);</span><br><span class="line">      String type = stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (type.equals(<span class="string">"mobile"</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.MOBILE);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"home"</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.HOME);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"work"</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.WORK);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stdout.println(<span class="string">"Unknown phone type.  Using default."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      person.addPhones(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file,</span></span><br><span class="line">  <span class="comment">//   adds one person based on user input, then writes it back out to the same</span></span><br><span class="line">  <span class="comment">//   file.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage:  AddPerson ADDRESS_BOOK_FILE"</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddressBook.Builder addressBook = AddressBook.newBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addressBook.mergeFrom(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(args[<span class="number">0</span>] + <span class="string">": File not found.  Creating a new file."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add an address.</span></span><br><span class="line">    addressBook.addPeople(</span><br><span class="line">      PromptForAddress(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)),</span><br><span class="line">                       System.out));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">    FileOutputStream output = <span class="keyword">new</span> FileOutputStream(args[<span class="number">0</span>]);</span><br><span class="line">    addressBook.build().writeTo(output);</span><br><span class="line">    output.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-11-Reading-A-Message"><a href="#2-11-Reading-A-Message" class="headerlink" title="2.11 Reading A Message"></a>2.11 Reading A Message</h2><blockquote><p>将2.10 生成的文件反序列化到程序中</p></blockquote><p>当然，如果您无法从中获取任何信息，那么address book就不会有多大用处！此示例读取上面示例创建的文件并打印其中的所有信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListPeople</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Iterates though all people in the AddressBook and prints info about them.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(AddressBook addressBook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person person: addressBook.getPeopleList()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Person ID: "</span> + person.getId());</span><br><span class="line">      System.out.println(<span class="string">"  Name: "</span> + person.getName());</span><br><span class="line">      <span class="keyword">if</span> (person.hasEmail()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"  E-mail address: "</span> + person.getEmail());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (phoneNumber.getType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> MOBILE:</span><br><span class="line">            System.out.print(<span class="string">"  Mobile phone #: "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> HOME:</span><br><span class="line">            System.out.print(<span class="string">"  Home phone #: "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> WORK:</span><br><span class="line">            System.out.print(<span class="string">"  Work phone #: "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(phoneNumber.getNumber());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file and prints all</span></span><br><span class="line">  <span class="comment">//   the information inside.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage:  ListPeople ADDRESS_BOOK_FILE"</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    AddressBook addressBook =</span><br><span class="line">      AddressBook.parseFrom(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    Print(addressBook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-12-Extending-a-Protocol-Buffer"><a href="#2-12-Extending-a-Protocol-Buffer" class="headerlink" title="2.12 Extending a Protocol Buffer"></a>2.12 Extending a Protocol Buffer</h2><p>在使用protocol buffer的代码之后，您无疑会想要“改进”protocol buffer的定义。<br>如果你希望你的新buffers向后兼容，并且你的旧buffers是向前兼容的 - 而且你几乎肯定想要这个 - 那么你需要遵循一些规则。<br>在新版本的protocol buffer中：</p><ul><li>您不得更改任何现有字段的标记号。</li><li>您不得添加或删除任何required字段。</li><li>您可以删除optional或repeated的字段。</li><li>您可以添加新的optional或repeated字段，但必须使用新的标记号（即从未在此protocol buffer中使用的标记号，甚至不包括已删除的字段）。<br>(这些规则有一些Exceptions，但它们很少使用)</li></ul><p>如果您遵循这些规则，旧代码将很乐意阅读新消息并简单地忽略任何新字段。对于旧代码，已删除的可选字段将只具有其默认值，删除的重复字段将为空。新代码也将透明地读取旧消息。但是，请记住旧的消息中不会出现新的可选字段，因此您需要明确检查它们是否设置为has_，或者使用[default = value]在.proto文件中提供合理的默认值。标签号后面。如果未为可选元素指定默认值，则使用特定于类型的默认值：对于字符串，默认值为空字符串。对于布尔值，默认值为false。对于数字类型，默认值为零。另请注意，如果添加了新的重复字段，则新代码将无法判断它是否为空（通过新代码）或从未设置（通过旧代码），因为它没有has_标志。</p><h2 id="2-13-Advanced-Usage"><a href="#2-13-Advanced-Usage" class="headerlink" title="2.13. Advanced Usage"></a>2.13. Advanced Usage</h2><p>protocol buffer的用途不仅仅是简单的访问器和序列化。请务必浏览<a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html" target="_blank" rel="noopener">Java API reference</a>，以了解您可以使用它们做些什么。</p><p>protocol消息类提供的一个关键特性是反射。您可以迭代消息的字段并在你写的代码中操纵它们的值，而无需针对任何特定的消息类型编写代码。使用反射的一种非常有用的方法是将protocol消息转换为与其他编码（例如XML或JSON）之间的转换。更高级的反射使用可能是找到两个相同类型的消息之间的差异，或者开发一种“protocol消息的正则表达式”，您可以在其中编写与某些消息内容匹配的表达式。如果您运用自己的想象力，可以将protocol buffer应用于比您最初预期更广泛的问题！</p><p><a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="noopener">Message</a>和<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message.Builder" target="_blank" rel="noopener">Message.Builder</a>接口提供一部分反射信息</p><h1 id="3-Developer-Guide"><a href="#3-Developer-Guide" class="headerlink" title="3. Developer Guide"></a>3. Developer Guide</h1><p>欢迎开发者来到Protocol buffers文档 – 一种与语言无关，平台无关，可扩展的序列化结构化数据的方法，用于通信协议，数据存储等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RPC:Remote Procedure Call,远程过程调用，很多RPC框架是夸语言的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个接口说明文件：描述了对象(结构图体)，对象成员，接口方法等一系列信息&lt;/li&gt;
&lt;li&gt;通过RPC框架所提供的编码器，将接口说明文件编译成集体的语言文件&lt;/li&gt;
&lt;li&gt;在客户端和服务端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://blog.shagle.cn/categories/RPC/"/>
    
    
      <category term="Protocol buffers" scheme="http://blog.shagle.cn/tags/Protocol-buffers/"/>
    
  </entry>
  
  <entry>
    <title>socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较</title>
    <link href="http://blog.shagle.cn/2019/03/12/IO%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/03/12/IO复用/</id>
    <published>2019-03-12T06:48:27.000Z</published>
    <updated>2019-03-12T06:49:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较</p><p><a href="http://www.cnblogs.com/wujing-hubei/p/6111347.html" target="_blank" rel="noopener">http://www.cnblogs.com/wujing-hubei/p/6111347.html</a><br><a href="https://www.cnblogs.com/bw13/p/6410877.html" target="_blank" rel="noopener">https://www.cnblogs.com/bw13/p/6410877.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;socket阻塞与非阻塞，同步与异步、I/O模型，select与poll、epoll比较&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wujing-hubei/p/6111347.html&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="rpc" scheme="http://blog.shagle.cn/categories/rpc/"/>
    
    
      <category term="I/O多路复用" scheme="http://blog.shagle.cn/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>grpc翻译</title>
    <link href="http://blog.shagle.cn/2019/03/10/grpc%E7%BF%BB%E8%AF%91/"/>
    <id>http://blog.shagle.cn/2019/03/10/grpc翻译/</id>
    <published>2019-03-10T07:48:49.000Z</published>
    <updated>2019-03-13T14:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>grpc 官网<a href="https://grpc.io" target="_blank" rel="noopener">https://grpc.io</a></p><p>grpc 是一个高效的，开源的，统一的rpc框架</p><h1 id="grpc-的基本特点是："><a href="#grpc-的基本特点是：" class="headerlink" title="grpc 的基本特点是："></a>grpc 的基本特点是：</h1><ul><li>简单的服务定义：可以使用protocol buffers来定义你的服务，protocol buffers本身是一个强大的，二进制序列化工具集和语言</li><li>可以跨越语言和平台：可以为你的服务自动的生成习惯使用的客户端和服务端的stubs语言和平台</li><li>快速启动或扩展：通过一个简单的命令安装到开发环境或运行是环境并扩展为百万级别的rpc框架</li><li>双向的流并集成授权：基于http 2传输的二进制双向流并完全集成可插拔的身份验证</li></ul><h1 id="1-what-is-grpc"><a href="#1-what-is-grpc" class="headerlink" title="1. what is grpc"></a>1. what is grpc</h1><p>这个文档介绍了grpc和protocol buffers，grpc可以使用protocol buffers即作为它的IDL(接口描述语言，接口定义语言)，可以使用它作为它底层的消息交换格式，如果你是一个不了解grpc或protocol buffers的就继续往下读</p><h2 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1. Overview"></a>1.1. Overview</h2><p><code>在Grpc客户端应用中可以调用各机器上各服务上的各方法，就好像是一个本地对象一样，这使的你可以创建分布式应用与服务</code>。就像很多RPC系统一样，gRPC是基于这样一个想法，定义一个服务，指定好可以远程调用的方法，同时带上参数和返回值，在服务器端，实现接口，然后运行一个gRPC服务器来处理客户端的调用。另外在客户端有一个stub(在某些语言中也叫client)，它提供了可服务器相同的方法</p><p><img src="20190310162030.png" alt=""></p><p>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的桌面，并且可以用任何 gRPC 支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。此外，Google 最新 API 将有 gRPC 版本的接口，使你很容易地将 Google 的功能集成到你的应用里。</p><h2 id="1-2-Working-with-Protocol-Buffers"><a href="#1-2-Working-with-Protocol-Buffers" class="headerlink" title="1.2. Working with Protocol Buffers"></a>1.2. Working with Protocol Buffers</h2><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 Protocol Buffers 文档找到更多关于 <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> 的资料。</p><h3 id="1-2-1-Protocol-buffer-versions"><a href="#1-2-1-Protocol-buffer-versions" class="headerlink" title="1.2.1 Protocol buffer versions"></a>1.2.1 Protocol buffer versions</h3><p>虽然Protocol buffer对用户已经开源了一段时间了，但是他们的实例使用的Proto3，它提供了稍微简介的语法，新的特效，并支持更多的语言，目前可以使用到Java, C++, Python, Objective-C, C#, a lite-runtime (Android Java), Ruby, and JavaScript，Go 或更多的语言开发。您可以在proto3语言指南和每种语言的参考文档中找到更多信息。参考文档还包括.proto文件格式的正式规范。</p><p>一般来说你可以使用proto2(当前Protocol buffer默认版本号)，在使用gRPC中我们建议你使用Proto3，以便于支持更多的功能和特效，以便于出现如下错误，一端使用的Proto2，一边使用的Proto3，版本不一样出现一下兼容性问题，</p><h1 id="2-gRPC-Concepts"><a href="#2-gRPC-Concepts" class="headerlink" title="2. gRPC Concepts"></a>2. gRPC Concepts</h1><p>本文档通过对于 gRPC 的架构和 RPC 生命周期的概览来介绍 gRPC 的主要概念。本文是在假设你已经读过文档部分的前提下展开的。针对具体语言细节请查看对应语言的快速开始、教程和参考文档（很快就会有完整的文档）。</p><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h2><h3 id="2-1-2-Service-definition"><a href="#2-1-2-Service-definition" class="headerlink" title="2.1.2 Service definition"></a>2.1.2 Service definition</h3><p>与许多RPC系统一样，gRPC基于定义服务的思想，指定可以使用的参数和返回类型远程调用的方法，默认情况下，gRPC使用Protocol buffer作为接口定义语言（IDL）来描述服务接口和有效负载消息的结构。如果需要，可以使用其他替代方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service HelloService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">  string reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gRPC可以让我们定义四种方法</strong></p><ul><li>客户端向服务器发送单个请求并返回单个响应，就像正常的函数调用一样。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">SayHello</span><span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">LotsOfReplies</span><span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(stream HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">LotsOfGreetings</span><span class="params">(stream HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rpc <span class="title">BidiHello</span><span class="params">(stream HelloRequest)</span> <span class="title">returns</span> <span class="params">(stream HelloResponse)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在下面的RPC生命周期部分中更详细地介绍不同类型的RPC。</p><h3 id="2-1-3-Using-the-API-surface"><a href="#2-1-3-Using-the-API-surface" class="headerlink" title="2.1.3 Using the API surface"></a>2.1.3 Using the API surface</h3><p>gRPC 提供 protocol buffer 编译插件，能够从一个服务定义的 .proto 文件生成客户端和服务端代码。通常 gRPC 用户可以在服务端实现这些API，并从客户端调用它们。</p><ul><li>在服务侧，服务端实现服务接口，运行一个 gRPC 服务器来处理客户端调用。gRPC 底层架构会解码传入的请求，执行服务方法，编码服务应答。</li><li>在客户侧，客户端有一个stub实现了服务端同样的方法。客户端可以在本地stub调用这些方法，用合适的 protocol buffer 消息类型封装这些参数— gRPC 来负责发送请求给服务端并返回服务端 protocol buffer 响应。</li></ul><h3 id="2-1-4-Synchronous-vs-asynchronous"><a href="#2-1-4-Synchronous-vs-asynchronous" class="headerlink" title="2.1.4 Synchronous vs. asynchronous"></a>2.1.4 Synchronous vs. asynchronous</h3><p>同步 RPC 调用一直会阻塞直到从服务端获得一个应答，这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的。</p><p>在多数语言里，gRPC 编程接口同时支持同步和异步的特点。你可以从每个语言教程和参考文档里找到更多内容(很快就会有完整文档)。</p><h2 id="2-2-RPC-life-cycle"><a href="#2-2-RPC-life-cycle" class="headerlink" title="2.2. RPC life cycle"></a>2.2. RPC life cycle</h2><p>现在让我们来仔细了解一下当 gRPC 客户端调用 gRPC 服务端的方法时到底发生了什么。我们不究其实现细节，关于实现细节的部分，你可以在我们的特定语言页面里找到更为详尽的内容。</p><h3 id="2-2-1-单项-RPC"><a href="#2-2-1-单项-RPC" class="headerlink" title="2.2.1 单项 RPC"></a>2.2.1 单项 RPC</h3><p>首先我们来了解一下最简单的 RPC 形式：客户端发出单个请求，获得单个响应。</p><ul><li>一旦客户端通过stub/client调用一个方法，服务端会得到相关通知 ，通知包括客户端的元数据，方法名，允许的响应期限（如果可以的话）</li><li>服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用。</li><li>一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端 。</li><li>假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用。</li></ul><h3 id="2-2-2-Server-streaming-RPC"><a href="#2-2-2-Server-streaming-RPC" class="headerlink" title="2.2.2 Server streaming RPC"></a>2.2.2 Server streaming RPC</h3><p>服务端流式 RPC 除了在得到客户端请求信息后发送回一个应答流之外，与我们的简单例子一样。在发送完所有应答后，服务端的状态详情(状态码和可选的状态信息)和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作。</p><h3 id="2-2-3-Client-streaming-RPC"><a href="#2-2-3-Client-streaming-RPC" class="headerlink" title="2.2.3 Client streaming RPC"></a>2.2.3 Client streaming RPC</h3><p>客户端流式 RPC 也基本与我们的简单例子一样，区别在于客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（但并不必须）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据。</p><h3 id="2-2-4-Bidirectional-streaming-RPC"><a href="#2-2-4-Bidirectional-streaming-RPC" class="headerlink" title="2.2.4 Bidirectional streaming RPC"></a>2.2.4 Bidirectional streaming RPC</h3><p>双向流式 RPC ，调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间。服务端可以选择发送回它的初始元数据或等待客户端发送请求。</p><p>下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写 - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p><h3 id="2-2-5-Deadlines-Timeouts"><a href="#2-2-5-Deadlines-Timeouts" class="headerlink" title="2.2.5 Deadlines/Timeouts"></a>2.2.5 Deadlines/Timeouts</h3><p>gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回<code>DEADLINE_EXCEEDED</code>错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法。</p><p>各语言来指定一个截止时间的方式是不同的 - 比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间。</p><h3 id="2-2-6-RPC-termination"><a href="#2-2-6-RPC-termination" class="headerlink" title="2.2.6. RPC termination"></a>2.2.6. RPC termination</h3><p>在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束(“我已经返回了所有应答!”)，到那时在客户端可能是失败的(“应答在最后期限后才来到!”)。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了。</p><h3 id="2-2-7-Cancelling-RPCs"><a href="#2-2-7-Cancelling-RPCs" class="headerlink" title="2.2.7. Cancelling RPCs"></a>2.2.7. Cancelling RPCs</h3><p>无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它不是一个”撤销”， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用。</p><h3 id="2-2-8-Metadata"><a href="#2-2-8-Metadata" class="headerlink" title="2.2.8. Metadata"></a>2.2.8. Metadata</h3><p>元数据是一个特殊 RPC 调用对应的信息(<a href="https://grpc.io/docs/guides/auth.html" target="_blank" rel="noopener">授权详情</a>) ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串(当然也可以是二进制数据)。元数据对 gRPC 本事来说是不透明的 - 它让客户端提供调用相关的信息给服务端，反之亦然。<br>对于元数据的访问是语言相关的。</p><h3 id="2-2-9-Channels"><a href="#2-2-9-Channels" class="headerlink" title="2.2.9 Channels"></a>2.2.9 Channels</h3><p>在创建客户端stub时，一个 gRPC Channel提供一个特定主机和端口服务端的连接。客户端可以通过指定Channel参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个Channel具有状态，包含<code>已连接</code>和<code>空闲</code> 。<br>gRPC 如何处理关闭Channel是语言相关的。有些语言可允许询问Channel状态。</p><h1 id="3-Authentication"><a href="#3-Authentication" class="headerlink" title="3. Authentication"></a>3. Authentication</h1><p>本文档概述了gRPC身份验证，包括我们内置的支持身份验证机制，如何插入您自己的身份验证系统，以及如何在我们支持的语言中使用gRPC身份验证的示例。</p><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1. Overview"></a>3.1. Overview</h2><p>gRPC旨在与各种身份验证机制配合使用，可以轻松安全地使用gRPC与其他系统进行通信。您可以使用我们支持的机制 - 带或不带基于Google令牌的身份验证的SSL / TLS - 或者您可以通过扩展我们提供的代码来插入您自己的身份验证系统。</p><p>gRPC还提供了一个简单的身份验证API，允许您在创建channel或方法调用时提供所有必要的身份验证信息作为凭据。</p><h2 id="3-2-Supported-auth-mechanisms"><a href="#3-2-Supported-auth-mechanisms" class="headerlink" title="3.2. Supported auth mechanisms"></a>3.2. Supported auth mechanisms</h2><p>gRPC内置了以下身份验证机制：</p><ul><li>SSL/TLS: gRP 集成 SSL/TLS 并对服务端授权所使用的 SSL/TLS 进行了改良，对客户端和服务端交换的所有数据进行了加密。对客户端来讲提供了可选的机制提供凭证来获得共同的授权。</li><li>Token-based authentication with Google: </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;grpc 官网&lt;a href=&quot;https://grpc.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://grpc.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;grpc 是一个高效的，开源的，统一的rpc框架&lt;/p&gt;
&lt;h1 id=&quot;grpc-的基本特
      
    
    </summary>
    
      <category term="rpc" scheme="http://blog.shagle.cn/categories/rpc/"/>
    
    
      <category term="grpc" scheme="http://blog.shagle.cn/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>Redis之字符串</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之字符串/</id>
    <published>2019-03-08T05:21:20.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h1><p>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。<br>举个例子，如果客户端执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS。</li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS。<br>又比如，如果客户端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串”fruits”的SDS。</p></li><li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串”apple”，第二个SDS保存着字符串”banana”，第三个SDS保存着字符串”cherry”。</li></ul><h2 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1 SDS的定义"></a>1.1 SDS的定义</h2><p>每个sds.h/sdshdr结构表示一个SDS值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图2-1展示了一个SDS示例：</p><p><img src="20190308132256.png" alt=""></p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存</li></ul><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</p><h1 id="2。2-对c和sds之间区别进行总结"><a href="#2。2-对c和sds之间区别进行总结" class="headerlink" title="2。2 对c和sds之间区别进行总结"></a>2。2 对c和sds之间区别进行总结</h1><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(N)</td><td style="text-align:left">获取字符串长度复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API思安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重新分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存分配</td></tr><tr><td style="text-align:left">只能保持文本数据</td><td style="text-align:left">可以保存文本或二进制数据</td></tr><tr><td style="text-align:left">可以使用所有&lt;string.h&gt;库中的函数</td><td style="text-align:left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p>SDS 主要API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table><p>sdsnew|    创建一个包含给定 C 字符串的 SDS 。    |O(N) ， N 为给定 C 字符串的长度。<br>sdsempty|    创建一个不包含任何内容的空 SDS 。    |O(1)<br>sdsfree|    释放给定的 SDS 。    |O(1)<br>sdslen|    返回 SDS 的已使用空间字节数。    |这个值可以通过读取 SDS 的 len 属性来直接获得， 复杂度为 O(1) 。<br>sdsavail|    返回 SDS 的未使用空间字节数。    |这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1) 。<br>sdsdup|    创建一个给定 SDS 的副本（copy）。    |O(N) ， N 为给定 SDS 的长度。<br>sdsclear|    清空 SDS 保存的字符串内容。|    因为惰性空间释放策略，复杂度为 O(1) 。<br>sdscat|    将给定 C 字符串拼接到 SDS 字符串的末尾。    |O(N) ， N 为被拼接 C 字符串的长度。<br>sdscatsds|    将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。    |O(N) ， N 为被拼接 SDS 字符串的长度。<br>sdscpy|    将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。    |O(N) ， N 为被复制 C 字符串的长度。<br>sdsgrowzero|    用空字符将 SDS 扩展至给定长度。|    O(N) ， N 为扩展新增的字节数。<br>sdsrange|    保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。    |O(N) ， N 为被保留数据的字节数。<br>sdstrim|    接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。    |O(M*N) ， M 为 SDS 的长度， N 为给定 C 字符串的长度。<br>sdscmp|    对比两个 SDS 字符串是否相同。    |O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单动态字符串&quot;&gt;&lt;a href=&quot;#1-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;1. 简单动态字符串&quot;&gt;&lt;/a&gt;1. 简单动态字符串&lt;/h1&gt;&lt;p&gt;当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Re
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之链表</title>
    <link href="http://blog.shagle.cn/2019/03/08/Redis%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/08/Redis之链表/</id>
    <published>2019-03-08T05:17:42.000Z</published>
    <updated>2019-03-08T05:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h1><h2 id="1-1-链表和链表节点的实现"><a href="#1-1-链表和链表节点的实现" class="headerlink" title="1.1 链表和链表节点的实现"></a>1.1 链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    struct listNode * prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    struct listNode * next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line"></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表，如图3-1所示。</p><p><img src="20190304174146.png" alt=""></p><p>虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    unsigned <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>图3-2是由一个list结构和三个listNode结构组成的链表。</li></ul><p><img src="20190304180006.png" alt=""></p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free […]</li></ul><h2 id="1-2-链表和链表节点的API"><a href="#1-2-链表和链表节点的API" class="headerlink" title="1.2 链表和链表节点的API"></a>1.2 链表和链表节点的API</h2><p>表3-1列出了所有用于操作链表和链表节点的API。</p><p>表 3-1 链表和链表节点 API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数。</td><td style="text-align:left">复制函数可以通过链表的 dup 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数。</td><td style="text-align:left">释放函数可以通过链表的 free 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数。</td><td style="text-align:left">对比函数可以通过链表的 match 属性直接获得， O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）。</td><td style="text-align:left">链表长度可以通过链表的 len 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点。</td><td style="text-align:left">表头节点可以通过链表的 head 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表尾节点。</td><td style="text-align:left">表尾节点可以通过链表的 tail 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点。</td><td style="text-align:left">前置节点可以通过节点的 prev 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点。</td><td style="text-align:left">后置节点可以通过节点的 next 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值。</td><td style="text-align:left">节点值可以通过节点的 value 属性直接获得， O(1) 。</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点。</td><td style="text-align:left">O(1) 。</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点。</td><td style="text-align:left">O(N) ， N 为链表长度。</td></tr></tbody></table><h2 id="1-3-重点回顾"><a href="#1-3-重点回顾" class="headerlink" title="1.3 重点回顾"></a>1.3 重点回顾</h2><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-链表&quot;&gt;&lt;a href=&quot;#1-链表&quot; class=&quot;headerlink&quot; title=&quot;1. 链表&quot;&gt;&lt;/a&gt;1. 链表&lt;/h1&gt;&lt;h2 id=&quot;1-1-链表和链表节点的实现&quot;&gt;&lt;a href=&quot;#1-1-链表和链表节点的实现&quot; class=&quot;header
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis之对象</title>
    <link href="http://blog.shagle.cn/2019/03/07/Redis%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.shagle.cn/2019/03/07/Redis之对象/</id>
    <published>2019-03-07T09:32:18.000Z</published>
    <updated>2019-03-07T09:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="redis设计与实现.md">在前面的数个章节里</a>，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p><p>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><p>本章接下来将逐一介绍以上提到的Redis对象系统的各个特性。</p><h1 id="1-对象的类型与编码"><a href="#1-对象的类型与编码" class="headerlink" title="1. 对象的类型与编码"></a>1. 对象的类型与编码</h1><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。<br>举个例子，以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值”msg”的对象，而键值对的值则是一个包含了字符串值”hello world”的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    unsigned type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1 类型"></a>1.1 类型</h2><p>对象的type属性记录了对象的类型，这个属性的值可以是表8-1列出的常量的其中一个。</p><p><img src="20190307173736.png" alt=""></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为哈希对象</span><br><span class="line"></span><br><span class="line">redis&gt; HMSET profile name Tom age 25 career Programmer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE profile</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE fruits</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为有序集合对象</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE price</span><br><span class="line">zset</span><br></pre></td></tr></table></figure><p><img src="20190307174110.png" alt=""></p><h2 id="1-2-编码和底层实现"><a href="#1-2-编码和底层实现" class="headerlink" title="1.2 编码和底层实现"></a>1.2 编码和底层实现</h2><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表8-3列出的常量的其中一个。</p><p><img src="20190307174221.png" alt=""></p><p>每种类型的对象都至少使用了两种不同的编码，表8-4列出了每种类型的对象可以使用的编码。</p><p><img src="20190307174256.png" alt=""></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SET story &quot;long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers &quot;seven&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>表8-5列出了不同编码的对象所对应的OBJECT ENCODING命令输出。</p><p><img src="20190307174357.png" alt=""></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><p>在接下来的内容中，我们将分别介绍Redis中的五种不同类型的对象，说明这些对象底层所使用的编码方式，列出对象从一种编码转换成另一种编码所需的条件，以及同一个命令在多种不同编码上的实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;redis设计与实现.md&quot;&gt;在前面的数个章节里&lt;/a&gt;，我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。&lt;/p&gt;
&lt;p&gt;Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>压缩列表zipList</title>
    <link href="http://blog.shagle.cn/2019/03/07/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8zipList/"/>
    <id>http://blog.shagle.cn/2019/03/07/压缩列表zipList/</id>
    <published>2019-03-07T02:11:07.000Z</published>
    <updated>2019-03-07T05:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表(<code>ziplist</code>)是列表键和哈希键的底层实现之一。</p><h1 id="1-压缩列表的构成"><a href="#1-压缩列表的构成" class="headerlink" title="1. 压缩列表的构成"></a>1. 压缩列表的构成</h1><p>压缩列表是<code>Redis</code>为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点,每个节点可以保存一个字节数组或者一个整数值。</p><p>当一个哈希键只包含少量key-value对，且每个key-value对的key和value要么是小整数，要么是较短字符串，那么redis就会使用<code>ziplist</code>作为哈希键的底层实现。</p><h1 id="2-ziplist的实现："><a href="#2-ziplist的实现：" class="headerlink" title="2. ziplist的实现："></a>2. ziplist的实现：</h1><p>ziplist的内存布局如下所示：</p><p><img src="20160505101226534.png.png" alt="ziplist的内存布局"></p><ul><li><code>zlbytes</code>：4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</li><li><code>zltail</code>：4字节，记录压缩列表尾部节点距离起始地址的偏移量：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址</li><li><code>zllen</code>：2字节，记录压缩列表包含的节点数量</li><li><code>entry</code>：不定，列表中的每个节点,节点的长度由节点保存的内存决定</li><li><code>zlend</code>：1字节，特殊值0xFF，标记压缩列表的结束</li></ul><p>因此通过下面的宏定义可以非常方便的求出各个字段的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span><br><span class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span><br><span class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span><br><span class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span><br><span class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span><br><span class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span><br><span class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span><br></pre></td></tr></table></figure><p><strong>一个简单的ziplist示意图如下：</strong></p><p><img src="20160505100030534.png" alt=""></p><ul><li>列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。</li><li>列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li><li>列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。</li></ul><h1 id="3-压缩列表节点的构成"><a href="#3-压缩列表节点的构成" class="headerlink" title="3. 压缩列表节点的构成"></a>3. 压缩列表节点的构成</h1><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p><img src="20190307102401.png" alt=""></p><h2 id="3-1-previous-entry-length"><a href="#3-1-previous-entry-length" class="headerlink" title="3.1 previous_entry_length"></a>3.1 previous_entry_length</h2><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>图7-5展示了一个包含一字节长previous_entry_length属性的压缩列表节点，属性的值为0x05，表示前一节点的长度为5字节。</p><p><img src="20190307111032.png" alt="图7-5"></p><p>图7-6展示了一个包含五字节长previous_entry_length属性的压缩节点，属性的值为0xFE00002766，其中值的最高位字节0xFE表示这是一个五字节长的previous_entry_length属性，而之后的四字节0x00002766（十进制值10086）才是前一节点的实际长度。</p><p><img src="20190307111127.png" alt="图7-6"></p><p>因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。<br>举个例子，如果我们有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p，如图7-7所示。</p><p><img src="20190307111221.png" alt="图7-7"></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。</p><p>图7-8展示了一个从表尾节点向表头节点进行遍历的完整过程：</p><p><img src="20190307111316.png" alt="图7-8"></p><ul><li>首先，我们拥有指向压缩列表表尾节点entry4起始地址的指针p1（指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail属性的值得出）；</li><li>通过用p1减去entry4节点previous_entry_length属性的值，我们得到一个指向entry4前一节点entry3起始地址的指针p2；</li><li>通过用p2减去entry3节点previous_entry_length属性的值，我们得到一个指向entry3前一节点entry2起始地址的指针p3；</li><li>通过用p3减去entry2节点previous_entry_length属性的值，我们得到一个指向entry2前一节点entry1起始地址的指针p4，entry1为压缩列表的表头节点；</li><li>最终，我们从表尾节点向表头节点遍历了整个列表。</li></ul><h2 id="3-2-encoding"><a href="#3-2-encoding" class="headerlink" title="3.2 encoding"></a>3.2 encoding</h2><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；<br>表7-2记录了所有可用的字节数组编码，而表7-3则记录了所有可用的整数编码。表格中的下划线“_”表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。</li></ul><p><img src="20190307111918.png" alt=""></p><p><img src="20190307130819.png" alt=""></p><h2 id="3-3-content"><a href="#3-3-content" class="headerlink" title="3.3 content"></a>3.3 content</h2><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p>图7-9展示了一个保存字节数组的节点<code>示例</code>：</p><p><img src="20190307131023.png" alt="图7-9"></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值”hello world”。</li></ul><p>图7-10展示了一个保存整数值的节点<code>示例</code>：</p><p><img src="20190307131251.png" alt=""></p><ul><li>编码11000000表示节点保存的是一个int16_t类型的整数值；</li><li>content属性保存着节点的值10086。</li></ul><h2 id="3-4-连锁更新"><a href="#3-4-连锁更新" class="headerlink" title="3.4. 连锁更新"></a>3.4. 连锁更新</h2><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如图7-11所示。</p><p><img src="20190307132432.png" alt="图7-11"></p><p>因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性，换句话说，e1至eN的所有节点的previous_entry_length属性都是1字节长的。<br>这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点，如图7-12所示。</p><p><img src="20190307132535.png" alt="图7-12"></p><p>因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。</p><p>因此，为了让e2的previous_entry_length属性可以记录下e1的长度，程序需要再次对压缩列表执行空间重分配操作，并将e2节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展……为了让每个节点的previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断地对压缩列表执行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update），图7-13展示了这一过程。</p><p><img src="20190307132704.png" alt="图7-13"></p><p>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</p><p>考虑图7-14所示的压缩列表，如果e1至eN都是大小介于250字节至253字节的节点，big节点的长度大于等于254字节（需要5字节的previous_entry_length来保存），而small节点的长度小于254字节（只需要1字节的previous_entry_length来保存），那么当我们将small节点从压缩列表中删除之后，为了让e1的previous_entry_length属性可以记录big节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。</p><p><img src="20190307132846.png" alt="图7-14"></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N2)。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;压缩列表(&lt;code&gt;ziplist&lt;/code&gt;)是列表键和哈希键的底层实现之一。&lt;/p&gt;
&lt;h1 id=&quot;1-压缩列表的构成&quot;&gt;&lt;a href=&quot;#1-压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;1. 压缩列表的构成&quot;&gt;&lt;/a&gt;1. 压缩列表的
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>算法之SkipList跳表</title>
    <link href="http://blog.shagle.cn/2019/03/06/%E7%AE%97%E6%B3%95%E4%B9%8BSkipList%E8%B7%B3%E8%A1%A8/"/>
    <id>http://blog.shagle.cn/2019/03/06/算法之SkipList跳表/</id>
    <published>2019-03-06T07:10:11.000Z</published>
    <updated>2019-03-06T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么选择跳表"><a href="#1-为什么选择跳表" class="headerlink" title="1. 为什么选择跳表"></a>1. 为什么选择跳表</h1><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。</p><p>想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树</p><p>出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，</p><p>还要参考网上的代码，相当麻烦。</p><p>用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，</p><p>它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，</p><p>就能轻松实现一个 SkipList。</p><h1 id="2-有序表的搜索"><a href="#2-有序表的搜索" class="headerlink" title="2. 有序表的搜索"></a>2. 有序表的搜索</h1><p>考虑一个有序表：</p><p><img src="d5d03b36-abff-34ea-9c40-a1fbfb709a81.jpg" alt=""></p><p>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="7c904c3f-1f39-31af-b8cd-b6de27a94061.jpg" alt=""></p><p>这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：</p><p><img src="96983cb0-d60a-31da-953d-2dde4036ea6b.jpg" alt=""></p><p>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p><h1 id="3-跳表"><a href="#3-跳表" class="headerlink" title="3. 跳表"></a>3. 跳表</h1><p>下面的结构是就是跳表：</p><p>其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。</p><p><img src="f4c149bd-d8ea-39ff-813f-93d809c90966.jpg" alt=""></p><p>跳表具有如下性质：</p><ul><li>(1) 由很多层结构组成</li><li>(2) 每一层都是一个有序的链表</li><li>(3) 最底层(Level 1)的链表包含所有元素</li><li>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li><li>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ul><h1 id="4-跳表的搜索"><a href="#4-跳表的搜索" class="headerlink" title="4. 跳表的搜索"></a>4. 跳表的搜索</h1><p><img src="ec9fd643-f85c-3072-8634-60cfc88ab334.jpg" alt=""></p><p>例子：查找元素 117</p><ul><li>(1) 比较 21， 比 21 大，往后面找</li><li>(2) 比较 37,   比 37大，比链表最大值小，从 37 的下面一层开始找</li><li>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</li><li>(4) 比较 85， 比 85 大，从后面找</li><li>(5) 比较 117， 等于 117， 找到了节点。</li></ul><p>具体的搜索算法如下： </p><p><strong>C代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果存在 x, 返回 x 所在的节点， </span></span><br><span class="line"><span class="comment"> * 否则返回 x 的后继节点 */</span>  </span><br><span class="line">find(x)   </span><br><span class="line">&#123;  </span><br><span class="line">    p = top;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next-&gt;key &lt; x)  </span><br><span class="line">            p = p-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;down == NULL)   </span><br><span class="line">            <span class="keyword">return</span> p-&gt;next;  </span><br><span class="line">        p = p-&gt;down;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-跳表的插入"><a href="#5-跳表的插入" class="headerlink" title="5. 跳表的插入"></a>5. 跳表的插入</h1><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K = 2</p><p><img src="bb72be16-6162-3fee-b680-311f25dd7c3a.jpg" alt=""></p><p>如果 K 大于链表的层数，则要添加新的层。</p><p>例子：插入 119， K = 4</p><p><img src="6eac083f-45d9-37f9-867f-0d709d9659d3.jpg" alt=""></p><h1 id="6-丢硬币决定-K"><a href="#6-丢硬币决定-K" class="headerlink" title="6. 丢硬币决定 K"></a>6. 丢硬币决定 K</h1><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    K = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (random(<span class="number">0</span>,<span class="number">1</span>))  </span><br><span class="line">        K++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> K;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，<br>用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，<br>K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p><h1 id="7-跳表的高度。"><a href="#7-跳表的高度。" class="headerlink" title="7. 跳表的高度。"></a>7. 跳表的高度。</h1><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，跳表的高度等于这 n 次实验中产生的最大 K，待续。。。</p><h1 id="8-跳表的空间复杂度分析"><a href="#8-跳表的空间复杂度分析" class="headerlink" title="8. 跳表的空间复杂度分析"></a>8. 跳表的空间复杂度分析</h1><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的期望值是 2n。</p><h1 id="9-跳表的删除"><a href="#9-跳表的删除" class="headerlink" title="9. 跳表的删除"></a>9. 跳表的删除</h1><p>在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。</p><p>例子：删除 71</p><p><img src="7bab9ad1-9f5a-37d0-bc38-89ee50d1bc0d.jpg" alt=""></p><p><a href="https://kenby.iteye.com/blog/1187303" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么选择跳表&quot;&gt;&lt;a href=&quot;#1-为什么选择跳表&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么选择跳表&quot;&gt;&lt;/a&gt;1. 为什么选择跳表&lt;/h1&gt;&lt;p&gt;目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, T
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.shagle.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="SkipList跳表" scheme="http://blog.shagle.cn/tags/SkipList%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现</title>
    <link href="http://blog.shagle.cn/2019/03/04/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.shagle.cn/2019/03/04/redis设计与实现/</id>
    <published>2019-03-04T06:45:49.000Z</published>
    <updated>2019-03-08T05:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库键总是一个字符串对象（string object）；</li><li>而数据库键的值则可以是字符串对象、列表对象（list object）、哈希对象（hash object）、集合对象（set object）、有序集合对象（sorted set object）这五种对象中的其中一种。</li></ul><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. <a href="Redis之字符串.md">字符串</a></h1><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. <a href="Redis之链表.md">链表</a></h1><h1 id="4-字典"><a href="#4-字典" class="headerlink" title="4. 字典"></a>4. 字典</h1><h1 id="5-跳跃表"><a href="#5-跳跃表" class="headerlink" title="5. 跳跃表"></a>5. <a href="算法之SkipList跳表.md">跳跃表</a></h1><h1 id="6-整数集合"><a href="#6-整数集合" class="headerlink" title="6. 整数集合"></a>6. 整数集合</h1><h1 id="7-压缩列表"><a href="#7-压缩列表" class="headerlink" title="7. 压缩列表"></a>7. <a href="压缩列表zipList.md">压缩列表</a></h1><p>压缩列表参考：<a href="https://blog.csdn.net/u012658346/article/details/51321337" target="_blank" rel="noopener">https://blog.csdn.net/u012658346/article/details/51321337</a></p><h1 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. <a href="Redis之对象.md">对象</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="NoSql" scheme="http://blog.shagle.cn/categories/NoSql/"/>
    
    
      <category term="redis" scheme="http://blog.shagle.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock源码解析</title>
    <link href="http://blog.shagle.cn/2019/02/28/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.shagle.cn/2019/02/28/Java技术之ReentrantReadWriteLock源码解析/</id>
    <published>2019-02-28T07:14:17.000Z</published>
    <updated>2019-02-28T07:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-阅读须知"><a href="#1-阅读须知" class="headerlink" title="1. 阅读须知"></a>1. 阅读须知</h1><ul><li><p>JDK版本：1.8</p></li><li><p>文章中使用/**/注释的方法会做深入分析</p></li></ul><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><p><code>ReentrantReadWriteLock</code>，从字面上理解为可重入读写锁，基于<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>，不了解AQS的读者可以去看笔者关于AQS源码解析的文章进行学习）实现，根据读写锁的特性，我们可以猜测，读锁应该是基于AQS的共享锁实现，而写锁应该是基于AQS的独占锁实现，我们来验证这个猜想，首先看一下<code>ReentrantReadWriteLock</code>的构造方法：</p><p><strong>ReentrantReadWriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的boolean变量fair来确定使用公平锁或非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>默认的无参构造方法使用的是非公平锁。我们来介绍一下<code>ReentrantReadWriteLock</code>中的同步器<code>Sync</code>中的一些变量：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁占用高16位表示持有读锁的线程的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//根据SHARED_SHIFT变量的含义，每增加一个持有读锁的线程，state变量就需要累加这个值，也就是1左移16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">//持有读锁的线程的最大数量（65535）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//用于计算写锁的重入计数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//当前线程持有的读锁的重入数量。只在构造函数和readObject方法中初始化。线程的锁重入计数降至0时删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"><span class="comment">//最后一个成功获取readLock的线程的持有锁计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="comment">//firstReader是获取读锁的第一个线程。</span></span><br><span class="line"><span class="comment">//更确切地说，firstReader是最后一次将共享计数从0更改为1的唯一线程，</span></span><br><span class="line"><span class="comment">//并且自那以后未释放读锁; 如果没有这样的线程，则返回null。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//firstReaderHoldCount是firstReader的锁重入计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>使用<code>AQS</code>的<code>state</code>的高16位表示持有读锁的线程的数量，低16位表示写锁被同一个线程申请的次数，也就是锁重入的次数。接下来我们来看加锁实现，我们首先来看读锁部分：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireShared</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（共享锁部分）这篇文章中进行过详细分析，方法的开始会调用有子类实现的<code>tryAcquireShared</code>方法尝试以共享模式获得锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquireShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果独占锁的重入计数不为0（说明有线程持有独占锁）并且持有独占锁的线程不是当前线程返回-1代表获取共享锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">//共享锁的持有线程数量</span></span><br><span class="line">    <span class="comment">/*判断当前获取读锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//共享锁的持有线程的数量是否超过了最大值</span></span><br><span class="line">    <span class="comment">//CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//满足条件说明当前没有任何任何线程持有共享锁，则将当前线程设置为获取共享锁的第一个线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">//锁重入数量初始化为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果当前获取共享锁的线程是获取共享锁的第一个线程，则递增锁重入数量</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">//如果最后一个成功获取readLock的线程的锁重入计数对象还未初始化或者对象内部维护的线程id不是当前线程id</span></span><br><span class="line">                <span class="comment">//则将cachedHoldCounter赋值为当前线程的锁重入计数对象</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++; <span class="comment">//递增当前线程的锁重入计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*tryAcquireShared方法的完整版*/</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下方法的执行过程：</p><ul><li><ol><li>如果另一个线程持有写锁，则获取共享锁失败。</li></ol></li><li><ol start="2"><li>否则，此线程符合锁定状态，判断是否应该因为队列策略而阻塞。如果没有，尝试通过CAS增加共享锁的持有线程的数量。请注意，这步不会检查重入获取，它会被推迟到<code>fullTryAcquireShared</code>方法执行，以避免在更典型的非重入情况下检查锁重入计数。</li></ol></li><li><ol start="3"><li>如果步骤2因线程需要阻塞或CAS失败或计数饱和而失败，则调用<code>fullTryAcquireShared</code>方法。 关于<code>readerShouldBlock</code>（判断当前获取读锁的线程是否需要阻塞）方法，有公平和非公平两种实现，我们首先来看非公平的实现：</li></ol></li></ul><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apparentlyFirstQueuedIsExclusive</code>方法来自AQS，主要用于判断等待队列的头结点的下一个节点也就是第一个排队的线程是否以独占模式等待。这里我们要结合调用<code>readerShouldBlock</code>方法之前的if判断进行分析，如果这个if判断不满足，说明有两种情况可能发生：</p><ul><li><ol><li>当前没有线程占用写锁，这种情况readerShouldBlock方法会返回false。</li></ol></li><li><ol start="2"><li>当前有线程占用写锁，并且占用写锁的线程就是当前线程（当前线程是<code>head</code>节点），这时就发生了锁降级的情况，也就是当前线程持有写锁，并在申请读锁，这时就要判断<code>head</code>节点的下一个节点是否要申请写锁，如果是则<code>readerShouldBlock</code>方法返回<code>true</code>，说明本次申请读锁的操作需要阻塞。</li></ol></li></ul><p>接下来我们来看<code>readerShouldBlock</code>方法公平锁的实现：</p><p><strong>ReentrantReadWriteLock.FairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasQueuedPredecessors</code>方法我们在<code>ReentrantLock</code>源码解析这篇文章中分析过，它的主要作用是确认当前线程是否是下一个能够优先获得锁的线程，公平性也就是通过这个判断来保证的。公平锁我们很好理解，就是根据等待队列中节点的顺序来保证获取锁的顺序。</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//同样的判断是否有非当前线程持有独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//同样的判断当前获取读锁操作是否需要阻塞</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//确保没有重复获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">//这里如果当前线程持有的共享锁重入计数为0，则移除锁重入计数对象</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//锁重入计数为0时，返回-1代表获取共享锁失败，要进行排队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="comment">//超过最大持有读锁线程数量抛出Error</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//再次尝试获取共享锁，判断CAS增加共享锁的持有线程的数量是否成功</span></span><br><span class="line">        <span class="comment">//整体共享锁获取成功的处理逻辑与tryAcquireShared方法基本一致</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看读锁释放的实现：</p><p><strong>ReentrantReadWriteLock.ReadLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>releaseShared</code>释放共享锁方法同样来自于<code>AQS</code>，方法中首先会调用由子类覆盖的<code>tryReleaseShared</code>方法，通过尝试设置<code>state</code>变量来释放共享锁，我们来看<code>ReentrantReadWriteLock</code>对于<code>tryReleaseShared</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//判断当前线程是否是获取读锁的第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果锁重入计数为1，直接将获取读锁的第一个线程置为null，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果锁重入计数不为1（大于1），则在释放时递减锁重入计数</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">//这里的判断上文分析过</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count; <span class="comment">//当前线程的锁重入计数</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//小于等于1时说明这是最后一个重入锁，则移除锁重入计数对象</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//锁重入计数小于等于0说明本次解锁操作没有对应的加锁操作，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count; <span class="comment">//递减锁重入计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的自旋操作为递减共享锁持有的线程数量，与加锁时的递增操作正好相反</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，读锁的加锁和解锁操作就分析完了，下面我们来分析写锁的加锁和解锁操作，首先来看加锁：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，写锁是基于<code>AQS</code>的独占锁实现，这里的<code>acquire</code>方法我们在<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）源码解析（独占锁部分）这篇文章中已经详细分析过，方法的第一步就是调用由子类实现的<code>tryAcquire</code>方法通过操作<code>state</code>变量尝试以独占模式获取锁，我们来看<code>ReentrantReadWriteLock</code>对<code>tryAcquire</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.Sync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">//如果AQS的state变量不为0，说明当前读锁或写锁有被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的判断如果成立说明读锁被占用写锁未被占用</span></span><br><span class="line">        <span class="comment">//或者写锁被占用但占用的线程不是当前线程，这是返回false代表获取写锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//写锁最大重入数量的判断</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//走到这里说明是写锁重入，则递增写锁重入计数</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里说明当前读锁和写锁都未被任何线程占用</span></span><br><span class="line">    <span class="comment">/*判断获取写锁的线程是否需要阻塞*/</span></span><br><span class="line">    <span class="comment">//判断CAS递增写锁重入计数是否失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//设置写锁的拥有者线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>writerShouldBlock</code>方法同样区分公平和非公平两个版本的实现，我们先来看非公平版本的实现：</p><p><strong>ReentrantReadWriteLock.NonfairSync：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现方法直接返回<code>false</code>，也就是说每个想要获取非公平写锁的线程都可以直接参与竞争。而<code>writerShouldBlock</code>方法公平锁的版本与读锁的<code>readerShouldBlock</code>方法的公平版本是一样的，都是需要确认当前线程是否是下一个能够优先获得锁的线程，以此来保证公平性。最后我们来看写锁的解锁操作：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>release</code>方法我们在<code>AQS</code>独占锁源码解析的文章中同样进行过详细的分析，<code>AQS</code>的<code>release</code>方法首先会尝试调用由子类实现的<code>tryRelease</code>方法来尝试设置<code>state</code>变量来释放独占锁，锁完全释放后，会对后继节点进行唤醒操作，这个流程我们已经分析过，不再赘述。我们来看<code>ReentrantReadWriteLock</code>的对<code>tryRelease</code>方法的实现：</p><p><strong>ReentrantReadWriteLock.WriteLock：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁和解锁的线程必须是同一个，不然抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//递减写锁的重入计数</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果递减后的锁重入计数为0，说明锁已经被完全释放，这时将锁的拥有者线程置为null</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc); <span class="comment">//设置最新的锁重入计数</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解锁的流程就分析完成了。</p><p><code>ReentrantReadWriteLock</code>的写锁还支持<code>Condition</code>，与<code>ReentrantLock</code>一样完全基于<code>AQS</code>的<code>ConditionObject</code>实现，我们已经分析过<code>ConditionObject</code>源码，不明白的同学可以前往进行查阅学习。到这里，<code>ReentrantReadWriteLock</code>的源码分析就完成了。</p><p><a href="http://www.linkedkeeper.com/1118.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-阅读须知&quot;&gt;&lt;a href=&quot;#1-阅读须知&quot; class=&quot;headerlink&quot; title=&quot;1. 阅读须知&quot;&gt;&lt;/a&gt;1. 阅读须知&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK版本：1.8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文章中使用/**/注释的方法会做
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之CPU使用率为什么飚升？</title>
    <link href="http://blog.shagle.cn/2019/02/27/Java%E6%8A%80%E6%9C%AF%E4%B9%8BCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A3%9A%E5%8D%87%EF%BC%9F/"/>
    <id>http://blog.shagle.cn/2019/02/27/Java技术之CPU使用率为什么飚升？/</id>
    <published>2019-02-27T09:07:00.000Z</published>
    <updated>2019-02-27T09:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>频繁 Young GC 会不会引起 CPU 使用率飚升？</p><p>线程数很高的应用，CPU 使用率一定高么？</p><p>CPU 使用率高的应用，线程数一定高么？</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>分时操作系统 CPU 是耗费 us ？ 还是耗费 sy ？</p><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><p><strong>CPU 使用率怎么算？</strong></p><p>CPU% = 1 - idleTime / sysTime * 100</p><ul><li><p>idleTime：CPU处于空闲状态的时间</p></li><li><p>sysTime：CPU处于用户态和内核台的时间总和</p></li></ul><p><strong>CPU 使用率跟啥有关系？</strong></p><p>我们常听说计算密集型的程序是比较耗 CPU 使用率的。</p><p>那 JAVA 应用中哪些操作是比较耗 CPU 使用的？</p><p>列举下日常程序中常见的耗CPU的操作：</p><ul><li><p>频繁GC，访问量高时，有可能造成频繁的GC、甚至FGC。当调用量大时，内存分配过快，就会造成GC线程不停的执行，导致CPU飙高。</p></li><li><p>序列化与反序列化，后文中举了一个真实的案例，程序执行xml解析的时，调用量增大的情况下，导致了CPU被打满。</p></li><li><p>加密、解密。</p></li><li><p>正则表达式校验，曾经线上发生一次血案，正则校验将CPU打满。大概原因是：Java 正则表达式使用的引擎实现是 NFA 自动机，这种引擎在进行字符匹配会发生回溯（backtracking）。</p></li><li><p>线程上下文切换、当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待、IO等待等）和执行状态的变化过程中。当锁竞争激烈时，很容易出现这种情况。</p></li><li><p>某些线程在做无阻塞的运算，简单的例子while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的计算，可以适当将程序sleep下。</p></li></ul><p><strong>CPU 与进程、线程有关系么？</strong></p><p>现在分时操作系统是通过循轮方式分配时间片进行进程调度的，如果进程在等待或阻塞，不会造成 CPU 资源使用。线程称为轻进程，共享进程资源，关于线程的调度，CPU 对于线程也是分时调度。而在 Java 中，线程的调用由 JVM 负责，线程的调度一般有两种模式，分时调度和抢占式调度。</p><h1 id="我的解惑"><a href="#我的解惑" class="headerlink" title="我的解惑"></a>我的解惑</h1><p>一个 while 死循环，会不会引起 CPU 使用率飚升？</p><p>会的。先不说别的，死循环会调用 CPU 寄存器进行计数，这个操作就会占用 CPU。其次，如果线程一直处于死循环状态，CPU 调用会进行线程切换么？</p><p>死循环不会让出 CPU，除非操作系统时间片到期，但死循环会不断向系统申请时间片，直到系统没有空闲时间做别的事情。</p><p>这个问题在 stackoverflow 也有人提问：why does an infinite loop of the unintended kind increase the CPU use?</p><p>地址：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use</a></p><p><strong>频繁 Young GC 会不会引起 CPU 使用率飚升？</strong></p><p>会的。Young GC 本身是 JVM 进行垃圾回收的操作，会计算内存和调用寄存器，频繁 Young GC 一定是会占用 CPU。</p><p>之前有个一个案例，for 循环从数据库查询数据集合，二次封装新的数据集合，这时如果量比较大时，内存没有足够的空间存储，那么 JVM 就会 GC 回收那些不再使用的数据，因此量大的时候，就会收到 CPU 使用率报警。</p><p><strong>线程数很高的应用，CPU 使用率一定高么？</strong></p><p>不会。通过 jstack 查看系统线程状态，查看整个线程数很多，但 Runable 和 Running 状态的线程不多，这时 CPU 使用率不一定会高。</p><p>之前有过一个案例，查看系统线程数 1000+，jstack 分析 900多个线程是 BLOCKED 和 WAITING 状态的，这种线程是不会占用 CPU 的。</p><p>如果线程数很高，其实大多数原因是死锁，大量线程处于 BLOCKED 和 WAITING 状态。</p><p><strong>CPU 使用率高的应用，线程数一定高么？</strong></p><p>不会。同上，CPU 使用率高的关键因素还是计算密集型操作，一个线程如果有大量计算，也会造成 CPU 使用率高，也是现在为什么一个大数据脚本任务，要大规模集群共同运算才能运行的原因。</p><p>BLOCKED 状态的线程会不会引起 CPU 使用率飚升？</p><p>不一定，CPU使用率的飙升，更多是因为上下文的切换或者runnable状态线程过多导致。Blocked状态，未必会引起CPU上升。</p><p><strong>分时操作系统 CPU us高或者sy高是什么意思？</strong></p><p>通过top命令，我们可以观察到cpu的us，sy值，示例如下：</p><p><img src="linkedkeeper0_2fe93bbe-a4b1-4083-9288-56657fdb5ee5.jpg" alt=""></p><ul><li><p>Us 用户空间占用CPU百分比，简单来说，us高是因为我们的程序导致的，通过分析线程堆栈，可以很容易的定位到问题线程。</p></li><li><p>Sy 内核空间占用CPU百分比，sy高的时候，如果是程序问题导致，基本是因为线程上下文切换造成的。</p></li></ul><h1 id="我的经验"><a href="#我的经验" class="headerlink" title="我的经验"></a>我的经验</h1><p>平时怎么定位 CPU 使用率高的原因的？</p><p>其实网上有个教程和方法，我简述我的分析过程。</p><p>首先发现某台应用 CPU 使用率高，一要看先线程数、JVM、系统 load 等参数，共同作证。二要打印 jstack，通过工具分析线程情况，推荐 fastThread 这个在线的 Thread 分析工具。</p><p>以下是线上发生的真实案例，简要介绍下：</p><p>某日晚，突然收到短信报警，CPU利用率100%。立刻dump该机器jstack，通过 <a href="http://fastthread.io/" target="_blank" rel="noopener">http://fastthread.io/</a> 查看日志如下：</p><p><img src="linkedkeeper0_2d349092-9402-48ac-b7dc-763afa7bf4a4.jpg" alt=""></p><p>进一步查看具体日志：</p><p><img src="linkedkeeper0_dca206cc-cecc-4f3a-95fd-a937450712a2.jpg" alt=""></p><p>通过这段日志，已经定位到了具体CPU被打满的方法，接收MQ之后，MQ消息体为xml，反序列化的时候，造成了CPU飙高。</p><p><strong>希望本文对大家有所帮助。</strong> </p><p><a href="http://www.linkedkeeper.com/1310.html" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我的疑惑&quot;&gt;&lt;a href=&quot;#我的疑惑&quot; class=&quot;headerlink&quot; title=&quot;我的疑惑&quot;&gt;&lt;/a&gt;我的疑惑&lt;/h1&gt;&lt;p&gt;一个 while 死循环，会不会引起 CPU 使用率飚升？&lt;/p&gt;
&lt;p&gt;频繁 Young GC 会不会引起 CPU 使用率
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cpu" scheme="http://blog.shagle.cn/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之引用类型</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之引用类型/</id>
    <published>2019-02-26T05:40:42.000Z</published>
    <updated>2019-02-26T05:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-了解-强引用、软引用、弱引用、虚引用的概念"><a href="#一-了解-强引用、软引用、弱引用、虚引用的概念" class="headerlink" title="一.了解 强引用、软引用、弱引用、虚引用的概念"></a>一.了解 强引用、软引用、弱引用、虚引用的概念</h1><p>在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了。</p><p>从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。下面来阐述一下这四种类型引用的概念：</p><h1 id="1-1-强引用（StrongReference）"><a href="#1-1-强引用（StrongReference）" class="headerlink" title="1.1.强引用（StrongReference）"></a>1.1.强引用（StrongReference）</h1><p>强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的object和str都是强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。比如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Object[] objArr = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。</p><p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><p>比如Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> element that was removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    Object oldValue = elementData[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                 numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (E)oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-软引用（SoftReference）"><a href="#1-2-软引用（SoftReference）" class="headerlink" title="1.2.软引用（SoftReference）"></a>1.2.软引用（SoftReference）</h2><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        SoftReference&lt;String&gt; sr = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-弱引用（WeakReference）"><a href="#1-3-弱引用（WeakReference）" class="headerlink" title="1.3.弱引用（WeakReference）"></a>1.3.弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                <span class="comment">//通知JVM的gc进行垃圾回收</span></span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。</p><h2 id="1-4-虚引用（PhantomReference）"><a href="#1-4-虚引用（PhantomReference）" class="headerlink" title="1.4.虚引用（PhantomReference）"></a>1.4.虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p><p>要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>虚引用主要用于检测对象是否已经从内存中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br><span class="line">        System.out.println(pr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-进一步理解软引用和弱引用"><a href="#二-进一步理解软引用和弱引用" class="headerlink" title="二.进一步理解软引用和弱引用"></a>二.进一步理解软引用和弱引用</h1><p>对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><p>在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：</p><p>两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, q);</span><br><span class="line">    <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。</p><p>在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</p><h1 id="三-如何利用软引用和弱引用解决OOM问题"><a href="#三-如何利用软引用和弱引用解决OOM问题" class="headerlink" title="三.如何利用软引用和弱引用解决OOM问题"></a>三.如何利用软引用和弱引用解决OOM问题</h1><p>前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？</p><p>下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p><p>设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。</p><p>下面这段代码是摘自博客：</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 强引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加该对象到Map中使其缓存</span></span><br><span class="line"></span><br><span class="line">    imageCache.put(path, softBitmap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从缓存中取软引用的Bitmap对象</span></span><br><span class="line"></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在软引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (softBitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span></span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = softBitmap.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里我们把缓存替换策略交给了JVM去执行，这是一种比较简单的处理方法。复杂一点的缓存，我们可以自己单独设计一个类，这里面就涉及到缓存策略的问题了，具体可以参考之前的一篇博文：<a href="http://www.cnblogs.com/dolphin0520/p/3749259.html" target="_blank" rel="noopener">《缓存算法（页面置换算法）-FIFO、LFU、LRU》</a></p><p>参考资料：</p><p>《深入理解JVM虚拟机》</p><p><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="noopener">http://blog.csdn.net/arui319/article/details/8489451</a></p><p><a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">http://blog.csdn.net/zsuguangh/article/details/6429592</a></p><p><a href="http://mobile.51cto.com/abased-406998.htm" target="_blank" rel="noopener">http://mobile.51cto.com/abased-406998.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-了解-强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;a href=&quot;#一-了解-强引用、软引用、弱引用、虚引用的概念&quot; class=&quot;headerlink&quot; title=&quot;一.了解 强引用、软引用、弱引用、虚引用的概念&quot;&gt;&lt;/a&gt;一.了解 强引用、软引用、弱引用、
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="强引用、软引用、弱引用、虚引用" scheme="http://blog.shagle.cn/tags/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之深入分析ThreadLocal</title>
    <link href="http://blog.shagle.cn/2019/02/26/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ThreadLocal/"/>
    <id>http://blog.shagle.cn/2019/02/26/Java技术之深入分析ThreadLocal/</id>
    <published>2019-02-26T01:36:46.000Z</published>
    <updated>2019-02-26T06:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLoacal是什么？"><a href="#ThreadLoacal是什么？" class="headerlink" title="ThreadLoacal是什么？"></a>ThreadLoacal是什么？</h1><p>ThreadLocal是啥？以前面试别人时就喜欢问这个，有些伙伴喜欢把它和线程同步机制混为一谈，事实上ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？</p><p>API是这样介绍它的：</p><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code>或<code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。 <code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法：</p><ul><li>get()：返回此线程局部变量的当前线程副本中的值。</li><li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li><li>remove()：移除此线程局部变量当前线程的值。</li><li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li></ul><p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p><p>对于ThreadLocal需要注意的有两点：</p><ul><li><ol><li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li></ol></li><li><ol start="2"><li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li></ol></li></ul><p>下图是Thread、ThreadLocal、ThreadLocalMap的关系（<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/）</a></p><p><img src="640.jpeg" alt=""></p><h1 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h1><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seqCount.set(seqCount.get() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seqCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SeqCount seqCount = <span class="keyword">new</span> SeqCount();</span><br><span class="line">        SeqThread thread1 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread2 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread3 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread4 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SeqCount seqCount;</span><br><span class="line">        SeqThread(SeqCount seqCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.seqCount = seqCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">" seqCount :"</span> + seqCount.nextSeq());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="641.jpeg" alt=""></p><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。这里我们想一个问题，在上面的代码中ThreadLocal的initialValue()方法返回的是0，加入该方法返回得是一个对象呢，会产生什么后果呢？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;A&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;A&gt;()&#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程请参考：对ThreadLocal实现原理的一点思考</p><h1 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h1><p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line"></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href="Java技术之引用类型.md">Java技术之引用类型</a>）</p><p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal key, Object value)方法。</p><p><strong>set(ThreadLocal key, Object value)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 采用“线性探测法”，寻找合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key 存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots 清楚陈旧的Entry（key == null）</span></span><br><span class="line">    <span class="comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; (sz &gt;= threshold)) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考散列冲突处理系列博客）。掌握了开放地址法该方法就一目了然了。</p><p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p><p><strong>getEntry()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> ((e != <span class="keyword">null</span>) &amp;&amp; (e.get() == key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><blockquote><p>返回当前线程所对应的线程变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocal</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取目标值         </span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p><p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h1><blockquote><p>设置当前线程的线程局部变量的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h1><blockquote><p>返回该线程局部变量的初始值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h1><blockquote><p>将当前线程局部变量的值删除。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p><h1 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h1><p>前面提到每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下（图片来自<a href="http://www.jianshu.com/p/ee8c9dccc953）：" target="_blank" rel="noopener">http://www.jianshu.com/p/ee8c9dccc953）：</a></p><p><img src="642.png" alt=""></p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。</p><p>那么要怎么避免这个问题呢？</p><p>在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。</p><p>下面再对ThreadLocal进行简单的总结：</p><blockquote><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLoacal是什么？&quot;&gt;&lt;a href=&quot;#ThreadLoacal是什么？&quot; class=&quot;headerlink&quot; title=&quot;ThreadLoacal是什么？&quot;&gt;&lt;/a&gt;ThreadLoacal是什么？&lt;/h1&gt;&lt;p&gt;ThreadLocal是啥？
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ThreadLocal" scheme="http://blog.shagle.cn/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ReentrantReadWriteLock的实现原理</title>
    <link href="http://blog.shagle.cn/2019/02/25/Java%E6%8A%80%E6%9C%AF%E4%B9%8BReentrantReadWriteLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.shagle.cn/2019/02/25/Java技术之ReentrantReadWriteLock的实现原理/</id>
    <published>2019-02-25T02:42:29.000Z</published>
    <updated>2019-02-25T10:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><strong>ReentrantReadWriteLock支持以下功能：</strong></p><ul><li><p>1）支持公平和非公平的获取锁的方式；</p></li><li><p>2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p></li><li><p>3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</p></li><li><p>4）读取锁和写入锁都支持锁获取期间的中断；</p></li><li><p>5）Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </p></li></ul><h1 id="2-ReadWriteLock接口简单说明"><a href="#2-ReadWriteLock接口简单说明" class="headerlink" title="2. ReadWriteLock接口简单说明"></a>2. ReadWriteLock接口简单说明</h1><p>ReadWriteLock接口只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是Lock接口的实现，可以如同使用Lock接口一样使用（其实也有一些特性是不支持的）。</p><h1 id="3-ReentrantReadWriteLock使用示例"><a href="#3-ReentrantReadWriteLock使用示例" class="headerlink" title="3. ReentrantReadWriteLock使用示例"></a>3. ReentrantReadWriteLock使用示例</h1><p>读写锁的使用并不复杂，可以参考以下使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">      r.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通重入锁使用的主要区别在于需要使用不同的锁对象引用读写锁，并且在读写时分别调用对应的锁。</p><h1 id="4-ReentrantReadWriteLock锁实现分析"><a href="#4-ReentrantReadWriteLock锁实现分析" class="headerlink" title="4. ReentrantReadWriteLock锁实现分析"></a>4. ReentrantReadWriteLock锁实现分析</h1><p>本节通过学习源码分析可重入读写锁的实现。</p><h2 id="4-1-图解重要函数及对象关系"><a href="#4-1-图解重要函数及对象关系" class="headerlink" title="4.1 图解重要函数及对象关系"></a>4.1 图解重要函数及对象关系</h2><p>根据示例代码可以发现，读写锁需要关注的重点函数为获取读锁及写锁的函数，对于读锁及写锁对象则主要关注加锁和解锁函数，这几个函数及对象关系如下图：<br><img src="3356096377-5b58800bcda35.png" alt=""></p><p>从图中可见读写锁的加锁解锁操作最终都是调用<code>ReentrantReadWriteLock</code>类的内部类<code>Sync</code>提供的方法。与<a href="Java技术之ReentrantLock的实现原理.md">Java技术之ReentrantLock的实现原理</a>一文中描述相似，<code>Sync</code>对象通过继承<code>AbstractQueuedSynchronizer</code>进行实现，故后续分析主要基于<code>Sync</code>类进行。</p><h2 id="4-2-读写锁Sync结构分析"><a href="#4-2-读写锁Sync结构分析" class="headerlink" title="4.2. 读写锁Sync结构分析"></a>4.2. 读写锁Sync结构分析</h2><p><code>Sync</code>继承于<code>AbstractQueuedSynchronizer</code>，其中主要功能均在<code>AbstractQueuedSynchronizer</code>中完成，其中最重要功能为控制线程获取锁失败后转换为等待状态及在满足一定条件后唤醒等待状态的线程。先对<code>AbstractQueuedSynchronizer</code>进行观察。</p><h3 id="4-2-1-AbstractQueuedSynchronizer图解"><a href="#4-2-1-AbstractQueuedSynchronizer图解" class="headerlink" title="4.2.1. AbstractQueuedSynchronizer图解"></a>4.2.1. AbstractQueuedSynchronizer图解</h3><p>为了更好理解<code>AbstractQueuedSynchronizer</code>的运行机制，可以首先研究其内部数据结构，如下图：</p><p><img src="3868270967-5b58800c21220.png" alt=""></p><p>图中展示AQS类较为重要的数据结构，包括<code>int</code>类型变量<code>state</code>用于记录锁的状态，继承自<code>AbstractOwnableSynchronizer</code>类的<code>Thread</code>类型变量<code>exclusiveOwnerThread</code>用于指向当前排他的获取锁的线程，<code>AbstractQueuedSynchronizer.Node</code>类型的变量<code>head</code>及<code>tail</code>。<br>其中<code>Node</code>对象表示当前等待锁的节点，<code>Node</code>中<code>thread</code>变量指向等待的线程，<code>waitStatus</code>表示当前等待节点状态，<code>mode</code>为节点类型。多个节点之间使用<code>prev</code>及<code>next</code>组成双向链表，参考CLH锁队列的方式进行锁的获取，但其中与CLH队列的重要区别在于CLH队列中后续节点需要自旋轮询前节点状态以确定前置节点是否已经释放锁，期间不释放CPU资源，而<code>AQS</code>中<code>Node</code>节点指向的线程在获取锁失败后调用<code>LockSupport.park</code>函数使其进入阻塞状态，让出CPU资源，故在前置节点释放锁时需要调用<code>unparkSuccessor</code>函数唤醒后继节点。<br><strong>根据以上说明可得知此上图图主要表现当前<code>thread0</code>线程获取了锁，<code>thread1</code>线程正在等待。</strong></p><h3 id="4-2-2-读写锁Sync对于AQS使用"><a href="#4-2-2-读写锁Sync对于AQS使用" class="headerlink" title="4.2.2. 读写锁Sync对于AQS使用"></a>4.2.2. 读写锁Sync对于AQS使用</h3><p>读写锁中<code>Sync</code>类是继承于<code>AQS</code>，并且主要使用上文介绍的数据结构中的<code>state</code>及<code>waitStatus</code>变量进行实现。<br>实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。<br><code>Sync</code>使用<code>state</code>变量同时记录读锁与写锁状态，将<code>int</code>类型的<code>state</code>变量分为高16位与第16位，高16位记录读锁状态，低16位记录写锁状态，如下图所示：</p><p><img src="3877233723-5b58800addacf.png" alt=""></p><p><code>Sync</code>使用不同的<code>mode</code>描述等待队列中的节点以区分读锁等待节点和写锁等待节点。<code>mode</code>取值包括<code>SHARED</code>及<code>EXCLUSIVE</code>两种，分别代表当前等待节点为读锁和写锁。</p><h2 id="4-3-读写锁Sync代码过程分析"><a href="#4-3-读写锁Sync代码过程分析" class="headerlink" title="4.3. 读写锁Sync代码过程分析"></a>4.3. 读写锁Sync代码过程分析</h2><h3 id="4-3-1-写锁加锁"><a href="#4-3-1-写锁加锁" class="headerlink" title="4.3.1. 写锁加锁"></a>4.3.1. 写锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquire</code>函数（继承自<code>AQS</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分情况图解分析</p><h4 id="4-3-1-1-无锁状态"><a href="#4-3-1-1-无锁状态" class="headerlink" title="4.3.1.1. 无锁状态"></a>4.3.1.1. 无锁状态</h4><p>无锁状态<code>AQS</code>内部数据结构如下图所示：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>其中<code>state</code>变量为0，表示高位地位地位均为0，没有任何锁，且等待节点的首尾均指向空（此处特指head节点没有初始化时），锁的所有者线程也为空。<br>在无锁状态进行加锁操作，线程调用<code>acquire</code>函数，首先使用<code>tryAcquire</code>函数判断锁是否可获取成功，由于当前是无锁状态必然成功获取锁（如果多个线程同时进入此函数，则有且只有一个线程可调用<code>compareAndSetState</code>成功，其他线程转入获取锁失败的流程）。获取锁成功后<code>AQS</code>状态为：</p><p><img src="1886151432-5b58800ad557b.png" alt=""></p><h4 id="4-3-1-2-有锁状态"><a href="#4-3-1-2-有锁状态" class="headerlink" title="4.3.1.2. 有锁状态"></a>4.3.1.2. 有锁状态</h4><p>在加写锁时如果当前<code>AQS</code>已经是有锁状态，则需要进一步处理。有锁状态主要分为已有写锁和已有读锁状态，并且根据最终当前线程是否可直接获取锁分为两种情况：</p><ul><li><ol><li>非重入：如果满足一下两个条件之一，当前线程必须加入等待队列（暂不考虑非公平锁抢占情况） <ul><li>a. 已有读锁；</li><li>b. 有写锁且获取写锁的线程不为当前请求锁的线程。</li></ul></li></ol></li><li><ol start="2"><li>重入：有写锁且当前获取写锁的线程与当前请求锁的线程为同一线程，则直接获取锁并将写锁状态值加1。</li></ol></li></ul><p>写锁重入状态如图：</p><p><img src="454804165-5b58800ae5824.png" alt=""></p><p>写锁非重入等待状态如图：</p><p><img src="3879161302-5b58800a41983.png" alt=""></p><p>在非重入状态，当前线程创建等待节点追加到等待队列队尾，如果当前头结点为空，则需要创建一个默认的头结点。<br>之后再当前获取锁的线程释放锁后，会唤醒等待中的节点，即为<code>thread1</code>。如果当前等待队列存在多个等待节点，由于<code>thread1</code>等待节点为<code>EXCLUSIVE</code>模式，则只会唤醒当前一个节点，不会传播唤醒信号。</p><h3 id="4-3-2-读锁加锁"><a href="#4-3-2-读锁加锁" class="headerlink" title="4.3.2. 读锁加锁"></a>4.3.2. 读锁加锁</h3><p>通过对于重要函数关系的分析，写锁加锁最终调用<code>Sync</code>类的<code>acquireShared</code>函数（继承自<code>AQS</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上文，现在分情况图解分析</p><h4 id="4-3-2-1-无锁状态"><a href="#4-3-2-1-无锁状态" class="headerlink" title="4.3.2.1. 无锁状态"></a>4.3.2.1. 无锁状态</h4><p>无所状态<code>AQS</code>内部数据状态图与写加锁是无锁状态一致：</p><p><img src="2513088112-5b58800b78a6c.png" alt=""></p><p>在无锁状态进行加锁操作，线程调用<code>acquireShared</code>函数，首先使用<code>tryAcquireShared</code>函数判断共享锁是否可获取成功，由于当前为无锁状态则获取锁一定成功（如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取，该函数在后文说明）。当前线程获取读锁成功后，<code>AQS</code>内部结构如图所示：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>其中有两个新的变量：<code>firstReader</code>及<code>firstReaderHoldCount</code>。<code>firstReader</code>指向在无锁状态下第一个获取读锁的线程，<code>firstReaderHoldCount</code>记录第一个获取读锁的线程持有当前锁的计数（主要用于重入）。</p><h4 id="4-3-2-2-有锁状态"><a href="#4-3-2-2-有锁状态" class="headerlink" title="4.3.2.2. 有锁状态"></a>4.3.2.2. 有锁状态</h4><p>无锁状态获取读锁比较简单，在有锁状态则需要分情况讨论。其中需要分当前被持有的锁是读锁还是写锁，并且每种情况需要区分等待队列中是否有等待节点。</p><p><strong>已有读锁且等待队列为空</strong><br>此状态比较简单，图示如：</p><p><img src="594587484-5b58800a422be.png" alt=""></p><p>此时线程申请读锁，首先调用<code>readerShouldBlock</code>函数进行判断，该函数根据当前锁是否为公平锁判断规则稍有不同。如果为非公平锁，则只需要当前第一个等待节点不是写锁就可以尝试获取锁（考虑第一点为写锁主要为了方式写锁“饿死”）；如果是公平锁则只要有等待节点且当前锁不为重入就需要等待。<br>由于本节的前提是等待队列为空的情况，故<code>readerShouldBlock</code>函数一定返回<code>false</code>，则当前线程使用<code>CAS</code>对读锁计数进行增加（同上文，如果同时多个线程在读锁进行竞争，则只有一个线程能够直接获取读锁，其他线程需要进入<code>fullTryAcquireShared</code>函数继续进行锁的获取）。<br>在成功对读锁计数器进行增加后，当前线程需要继续对当前线程持有读锁的计数进行增加。此时分为两种情况：</p><ul><li><ol><li>当前线程是第一个获取读锁的线程，此时由于第一个获取读锁的线程已经通过<code>firstReader</code>及<code>firstReaderHoldCount</code>两个变量进行存储，则仅仅需要将<code>firstReaderHoldCount</code>加1即可;</li></ol></li><li><ol start="2"><li>当前线程不是第一个获取读锁的线程，则需要使用<code>readHolds</code>进行存储，<code>readHolds</code>是<code>ThreadLoca</code>l的子类，通过<code>readHolds</code>可获取当前线程对应的<code>HoldCounter</code>类的对象，该对象保存了当前线程获取读锁的计数。考虑程序的局部性原理，又使用<code>cachedHoldCounter</code>缓存最近使用的<code>HoldCounter</code>类的对象，如在一段时间内只有一个线程请求读锁则可加速对读锁获取的计数。</li></ol></li></ul><p>第一个读锁线程重入如图：</p><p><img src="1282819964-5b5880089f6c9.png" alt=""></p><p>非首节点获取读锁</p><p><img src="2489231474-5b5880083f137.png" alt=""></p><p>根据上图所示，<code>thread0</code>为首节点，<code>thread1</code>线程继续申请读锁，获取成功后使用<code>ThreadLocal</code>链接的方式进行存储计数对象，并且由于其为最近获取读锁的线程，则<code>cachedHoldCounter</code>对象设置指向<code>thread1</code>对应的计数对象。</p><p><strong>已有读锁且等待队列不为空</strong></p><p>在当前锁已经被读锁获取，且等待队列不为空的情况下 ，可知等待队列的头结点一定为<strong>写锁获取等待</strong>，这是由于在读写锁实现过程中，如果某线程获取了读锁，则会唤醒当前等到节点之后的所有等待模式为<code>SHARED</code>的节点，直到队尾或遇到<code>EXCLUSIVE</code>模式的等待节点（具体实现函数为<code>setHeadAndPropagate</code>后续还会遇到）。所以可以确定当前为读锁状态其有等待节点情况下，首节点一定是写锁等待。如图所示：</p><p><img src="790767399-5b58800924c87.png" alt=""></p><p>上图展示当前<code>thread0</code>与<code>thread1</code>线程获取读锁，<code>thread0</code>为首个获取读锁的节点，并且<code>thread2</code>线程在等待获取写锁。<br>在上图显示的状态下，无论公平锁还是非公平锁的实现，新的读锁加锁一定会进行排队，添加等待节点在写锁等待节点之后，这样可以防止写操作的饿死。申请读锁后的状态如图所示：</p><p><img src="3433646749-5b58800a4cd7a.png" alt=""></p><p>如图所示，在当前锁被为读锁且有等待队列情况下，<code>thread3</code>及<code>thread4</code>线程申请读锁，则被封装为等待节点追加到当前等待队列后，节点模式为<code>SHARED</code>，线程使用<code>LockSupport.park</code>函数进入阻塞状态，让出CPU资源，直到前驱的等待节点完成锁的获取和释放后进行唤醒。</p><p><strong>已有写锁被获取</strong></p><p>当前线程申请读锁时发现写锁已经被获取，则无论等待队列是否为空，线程一定会需要加入等待队列（注意在非公平锁实现且前序没有写锁申请的等待，线程有机会抢占获取锁而不进入等待队列）。写锁被获取的情况下，<code>AQS</code>状态为如下状态</p><p><img src="3131560188-5b588009a8253.png" alt=""></p><p>在两种情况下，读锁获取都会进入等待队列等待前序节点唤醒，这里不再赘述。</p><h4 id="4-3-2-3-读锁加锁读等待节点被唤醒"><a href="#4-3-2-3-读锁加锁读等待节点被唤醒" class="headerlink" title="4.3.2.3. 读锁加锁读等待节点被唤醒"></a>4.3.2.3. 读锁加锁读等待节点被唤醒</h4><p>读写锁与单纯的排他锁主要区别在于读锁的共享性，在读写锁实现中保证读锁能够共享的其中一个机制就在于，如果一个读锁等待节点被唤醒后其会继续唤醒拍在当前唤醒节点之后的<code>SHARED</code>模式等待节点。查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">   <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">           <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">               <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">               <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//注意看这里</span></span><br><span class="line">                   setHeadAndPropagate(node, r);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   <span class="keyword">if</span> (interrupted)</span><br><span class="line">                       selfInterrupt();</span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">               parkAndCheckInterrupt())</span><br><span class="line">               interrupted = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (failed)</span><br><span class="line">           cancelAcquire(node);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，线程如果获取读锁成功后，需要调用<code>setHeadAndPropagate</code>方法。查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">   Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">   setHead(node);</span><br><span class="line">   <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">       (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">           doReleaseShared();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在满足传播条件情况下，获取读锁后继续唤醒后续节点，所以如果当前锁是读锁状态则等待节点第一个节点一定是写锁等待节点。</p><h4 id="4-3-2-4-锁降级"><a href="#4-3-2-4-锁降级" class="headerlink" title="4.3.2.4. 锁降级"></a>4.3.2.4. 锁降级</h4><p>锁降级算是获取读锁的特例，如在<code>t0</code>线程已经获取写锁的情况下，再调取读锁加锁函数则可以直接获取读锁，但此时其他线程仍然无法获取读锁或写锁，在<code>t0</code>线程释放写锁后，如果有节点等待则会唤醒后续节点，后续节点可见的状态为目前有t0线程获取了读锁。<br>所降级有什么应用场景呢？引用读写锁中使用示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中针对变量<code>cacheValid</code>的使用主要过程为加读锁、读取、释放读锁、加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁。其中后续几步（加写锁、修改值、加读锁、释放写锁、使用数据、释放读锁）为典型的锁降级。如果不使用锁降级，则过程可能有三种情况：</p><ul><li>第一种：加写锁、修改值、释放写锁、使用数据，即使用写锁修改数据后直接使用刚修改的数据，这样可能有数据的不一致，如当前线程释放写锁的同时其他线程（如<code>t0</code>）获取写锁准备修改（还没有改）<code>cacheValid</code>变量，而当前线程却继续运行，则当前线程读到的<code>cacheValid</code>变量的值为<code>t0</code>修改前的老数据；</li><li>第二种：加写锁、修改值、使用数据、释放写锁，即将修改数据与再次使用数据合二为一，这样不会有数据的不一致，但是由于混用了读写两个过程，以排它锁的方式使用读写锁，减弱了读写锁读共享的优势，增加了写锁（独占锁）的占用时间；</li><li>第三种：加写锁、修改值、释放写锁、加读锁、使用数据、释放读锁，即使用写锁修改数据后再请求读锁来使用数据，这是时数据的一致性是可以得到保证的，但是由于释放写锁和获取读锁之间存在时间差，则当前想成可能会需要进入等待队列进行等待，可能造成线程的阻塞降低吞吐量。</li></ul><p>因此针对以上情况提供了锁的降级功能，可以在完成数据修改后尽快读取最新的值，且能够减少写锁占用时间。</p><p>最后注意，读写锁<strong>不支持锁升级</strong>，即获取读锁、读数据、获取写锁、释放读锁、释放写锁这个过程，因为读锁为共享锁，如同时有多个线程获取了读锁后有一个线程进行锁升级获取了写锁，这会造成同时有读锁（其他线程）和写锁的情况，造成其他线程可能无法感知新修改的数据（此为逻辑性错误），并且在JAVA读写锁实现上由于当前线程获取了读锁，再次请求写锁时必然会阻塞而导致后续释放读锁的方法无法执行，这回造成死锁（此为功能性错误）。</p><h3 id="4-3-3-写锁释放锁过程"><a href="#4-3-3-写锁释放锁过程" class="headerlink" title="4.3.3. 写锁释放锁过程"></a>4.3.3. 写锁释放锁过程</h3><p>了解了加锁过程后解锁过程就非常简单，每次调用解锁方法都会减少重入计数次数，直到减为0则唤醒后续第一个等待节点，如唤醒的后续节点为读等待节点，则后续节点会继续传播唤醒状态。</p><h3 id="4-3-4-读锁释放过程"><a href="#4-3-4-读锁释放过程" class="headerlink" title="4.3.4. 读锁释放过程"></a>4.3.4. 读锁释放过程</h3><p>读锁释放过比写锁稍微复杂，因为是共享锁，所以可能会有多个线程同时获取读锁，故在解锁时需要做两件事：</p><ul><li><ol><li>获取当前线程对应的重入计数，并进行减1，此处天生为线程安全的，不需要特殊处理；</li></ol></li><li><ol start="2"><li>当前读锁获取次数减1，此处由于可能存在多线程竞争，故使用自旋CAS进行设置。<br>完成以上两步后，如读状态为0，则唤醒后续等待节点。</li></ol></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>根据以上分析，本文主要展示了读写锁的场景及方式，并分析读写锁核心功能（加解锁）的代码实现。Java读写锁同时附带了更多其他方法，包括锁状态监控和带超时机制的加锁方法等，本文不在赘述。并且读写锁中写锁可使用Conditon机制也不在详细说明。</p><p><a href="https://segmentfault.com/a/1190000015768003#articleHeader3" target="_blank" rel="noopener">本文出自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ReentrantReadWriteLock" scheme="http://blog.shagle.cn/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之ThreadLocal的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8BThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之ThreadLocal的使用/</id>
    <published>2019-02-21T09:21:01.000Z</published>
    <updated>2019-02-21T09:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类ThreadLocal的使用"><a href="#1-类ThreadLocal的使用" class="headerlink" title="1. 类ThreadLocal的使用"></a>1. 类ThreadLocal的使用</h1><p>变量值的共享可以使用<code>public static</code>变量的形式，所有的线程都使用同一个<code>public static</code>变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的类<code>ThreadLocal</code>正是为了解决这样的问题。<br>类<code>ThreadLocal</code>主要解决的就是每个线程绑定自己的值，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><h1 id="2-解决get（）返回null问题"><a href="#2-解决get（）返回null问题" class="headerlink" title="2. 解决get（）返回null问题"></a>2. 解决get（）返回null问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是默认值 第一次get不再为null"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖initialValue（）方法具有初始值。</p><h1 id="3-类InheritableThreadLocal的使用"><a href="#3-类InheritableThreadLocal的使用" class="headerlink" title="3. 类InheritableThreadLocal的使用"></a>3. 类InheritableThreadLocal的使用</h1><p>使用类<code>InheritableThreadLocal</code>可以在子线程中取得父线程继承下来的值。</p><h2 id="3-1-值继承"><a href="#3-1-值继承" class="headerlink" title="3.1 值继承"></a>3.1 值继承</h2><p>使用InheritableThreadLocal类可以让子线程从父线程中取得值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Tools.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tools;</span><br><span class="line"><span class="keyword">import</span> ext.InheritableThreadLocalExt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocalExt tl = <span class="keyword">new</span> InheritableThreadLocalExt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadA.java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"在ThreadA线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> tools.Tools;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadA;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"       在Main线程中取值="</span> + Tools.tl.get());</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-64所示。</p><p><img src="20190221172614.png" alt=""></p><h1 id="3-2-值继承再修改"><a href="#3-2-值继承再修改" class="headerlink" title="3.2 值继承再修改"></a>3.2 值继承再修改</h1><p>如果在继承的同时还可以对值进行进一步的处理那就更好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">childValue</span><span class="params">(Object parentValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> parentValue + <span class="string">" 我在子线程加的~!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-65所示。</p><p><img src="20190221173005.png" alt=""></p><p>但在使用InheritableThreadLocal类需要注意一点的是，如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的值还是旧值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-类ThreadLocal的使用&quot;&gt;&lt;a href=&quot;#1-类ThreadLocal的使用&quot; class=&quot;headerlink&quot; title=&quot;1. 类ThreadLocal的使用&quot;&gt;&lt;/a&gt;1. 类ThreadLocal的使用&lt;/h1&gt;&lt;p&gt;变量值的共享可以
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="threadLocal" scheme="http://blog.shagle.cn/tags/threadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之join的使用</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8Bjoin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之join的使用/</id>
    <published>2019-02-21T06:28:50.000Z</published>
    <updated>2019-02-21T08:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销毁。</p><h1 id="1-学习方法join前的铺垫"><a href="#1-学习方法join前的铺垫" class="headerlink" title="1. 学习方法join前的铺垫"></a>1. 学习方法join前的铺垫</h1><p>在介绍join方法之前，先来看一个实验。<br>创建测试用的java项目，名称为joinTest1，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">    threadTest.start();</span><br><span class="line">    <span class="comment">// Thread.sleep(?)</span></span><br><span class="line">    System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行"</span>);</span><br><span class="line">    System.out.println(<span class="string">"但上面代码中的sleep()中的值应该写多少呢？"</span>);</span><br><span class="line">    System.out.println(<span class="string">"答案是：根据不能确定:)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-44所示。</p><p><img src="20190221150830.png" alt=""></p><h1 id="2-20190221150830-png"><a href="#2-20190221150830-png" class="headerlink" title="2. 20190221150830.png"></a>2. 20190221150830.png</h1><p>方法join可以解决这个问题。新建java项目joinTest2，类MyThread.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">      System.out.println(secondValue);</span><br><span class="line">      Thread.sleep(secondValue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Test.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> extthread.MyThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MyThread threadTest = <span class="keyword">new</span> MyThread();</span><br><span class="line">      threadTest.start();</span><br><span class="line">      threadTest.join();</span><br><span class="line">      System.out.println(<span class="string">"我想当threadTest对象执行完毕后我再执行，我做到了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的结果如图3-45所示。</p><p><img src="20190221152636.png" alt=""></p><p>方法join的作用是使所属的线程对象x正常执行run（）方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。</p><p>方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait（）方法进行等待，而sychronized关键字使用的是“对象监视器”原理做为同步</p><h1 id="3-方法join与异常"><a href="#3-方法join与异常" class="headerlink" title="3. 方法join与异常"></a>3. 方法join与异常</h1><p>在join过程中，如果当前线程对象被中断，则当前线程出现异常。<br>创建测试用的项目joinException，类ThreadA.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">      String newString = <span class="keyword">new</span> String();</span><br><span class="line">      Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadB.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line">      a.start();</span><br><span class="line">      a.join();</span><br><span class="line">      System.out.println(<span class="string">"线程B在run end处打印了"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"线程B在catch处打印了"</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ThreadC.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadB threadB;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(ThreadB threadB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.threadB = threadB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadB.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.run;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadB;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadC;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">      b.start();</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      ThreadC c = <span class="keyword">new</span> ThreadC(b);</span><br><span class="line">      c.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后的效果如图3-46所示。</p><p><img src="20190221154515.png" alt=""></p><p>说明方法join（）与interrupt（）方法如果彼此遇到，则会出现异常。但进程按钮还呈“红色”，原因是线程ThreadA还在继续运行，线程ThreadA并未出现异常，是正常执行的状态。</p><p>方法join（long）中的参数是设定等待的时间。</p><h1 id="4-方法join（long）与sleep（long）的区别"><a href="#4-方法join（long）与sleep（long）的区别" class="headerlink" title="4. 方法join（long）与sleep（long）的区别"></a>4. 方法join（long）与sleep（long）的区别</h1><p>方法join（long）的功能在内部是使用wait（long）方法来实现的，所以join（long）方法具有释放锁的特点。<br>方法join（long）源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码中可以了解到，当执行wait（long）方法后，当前线程的锁被释放，那么其他线程就可以调用此线程中的同步方法了。<br>Thread.sleep（long）方法不释放锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。方法join（）的作用是等待线程对象销
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="join" scheme="http://blog.shagle.cn/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>Java技术之线程通信</title>
    <link href="http://blog.shagle.cn/2019/02/21/Java%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.shagle.cn/2019/02/21/Java技术之线程通信/</id>
    <published>2019-02-21T06:04:00.000Z</published>
    <updated>2019-02-21T06:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通过管道进行线程间通信：字节流"><a href="#1-通过管道进行线程间通信：字节流" class="headerlink" title="1. 通过管道进行线程间通信：字节流"></a>1. 通过管道进行线程间通信：字节流</h1><p>在Java语言中提供了各种各样的输入/输出流Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream）是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西。<br>在Java的JDK中提供了4个类来使线程间可以进行通信：</p><ul><li>1）PipedInputStream和PipedOutputStream</li><li>2）PipedReader和PipedWriter<br>创建测试用的项目pipeInputOutput。<br>类WriteData.java代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData.getBytes());</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-37所示：</p><p><img src="20190221140600.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">      PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代码inputStream.connect（outputStream）或outputStream.connect（inputStream）的作用使两个Stream之间产生通信链接，这样才可以将数据进行输出与输入。<br>程序运行结果如图3-38所示：</p><p><img src="20190221140753.png" alt=""></p><h1 id="2-通过管道进行线程间通信：字符流"><a href="#2-通过管道进行线程间通信：字符流" class="headerlink" title="2. 通过管道进行线程间通信：字符流"></a>2. 通过管道进行线程间通信：字符流</h1><p>当然，在管道中还可以传递字符流。<br>创建测试用的项目pipeReaderWriter。</p><p>类WriteData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedWriter out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"write :"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">        out.write(outData);</span><br><span class="line">        System.out.print(outData);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ReadData.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedReader input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"read  :"</span>);</span><br><span class="line">      <span class="keyword">char</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">      <span class="keyword">int</span> readLength = input.read(byteArray);</span><br><span class="line">      <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        String newData = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">        System.out.print(newData);</span><br><span class="line">        readLength = input.read(byteArray);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">      input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程代码如图3-39所示：</p><p><img src="20190221141249.png" alt=""></p><p>类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"><span class="keyword">import</span> service.ReadData;</span><br><span class="line"><span class="keyword">import</span> service.WriteData;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadRead;</span><br><span class="line"><span class="keyword">import</span> extthread.ThreadWrite;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">      ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">      PipedReader inputStream = <span class="keyword">new</span> PipedReader();</span><br><span class="line">      PipedWriter outputStream = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">      <span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">      outputStream.connect(inputStream);</span><br><span class="line">      ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</span><br><span class="line">      threadRead.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</span><br><span class="line">      threadWrite.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如图3-40所示：</p><p><img src="20190221141423.png" alt=""></p><p>打印的结果和前一个示例基本一样，此实验是在两个线程中通过管道流进行字符数据的传输。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-通过管道进行线程间通信：字节流&quot;&gt;&lt;a href=&quot;#1-通过管道进行线程间通信：字节流&quot; class=&quot;headerlink&quot; title=&quot;1. 通过管道进行线程间通信：字节流&quot;&gt;&lt;/a&gt;1. 通过管道进行线程间通信：字节流&lt;/h1&gt;&lt;p&gt;在Java语言中
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="线程通信" scheme="http://blog.shagle.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://blog.shagle.cn/2019/01/31/jvm/"/>
    <id>http://blog.shagle.cn/2019/01/31/jvm/</id>
    <published>2019-01-31T05:45:53.000Z</published>
    <updated>2019-02-01T03:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li>在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的</li><li>提供了更大的灵活性，增加了更多的可能性</li><li>Java虚拟机与程序的生命周期</li><li>在如下几种情况下，java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致java虚拟机进程终止 </li></ul></li></ul><h1 id="类的加载，连接与初始化"><a href="#类的加载，连接与初始化" class="headerlink" title="类的加载，连接与初始化"></a>类的加载，连接与初始化</h1><ul><li>加载：查找并加载类的二进制数据</li><li>连接<ul><li>-验证：确保被加载的类的正确性</li><li>-准备：为类的<code>静态变量</code>分配内存，并将其初始化为<code>默认值</code></li><li>-解析：<code>把类中的符号引用转换为直接引用</code></li></ul></li><li><code>初始化：为类的静态变量赋予正确的初始值</code></li><li>使用</li><li>卸载</li><li>Java程序对类的使用方式可以分为两种<ul><li>-主动使用(七种)<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.tet.Test””))</li><li>初始化一个类的子类</li><li>java虚拟机启动时被标明为类的类(java test)</li><li>JDK 1.7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化</li></ul></li><li>-被动使用</li></ul></li><li>所有的Java虚拟机实现必须在每个类或接口被Java程序<code>首次主动使用</code>时才初始化他们</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在java代码中，类型(类型指Class，Interface等信息)的加载，连接与初始化过程都是在程序运行期间完成的&lt;/
      
    
    </summary>
    
      <category term="Java技术" scheme="http://blog.shagle.cn/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jvm" scheme="http://blog.shagle.cn/tags/jvm/"/>
    
  </entry>
  
</feed>
